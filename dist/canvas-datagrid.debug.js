/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!*********************!*\
  !*** ./lib/main.js ***!
  \*********************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jslint browser: true, unparam: true, todo: true*/\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n    __webpack_require__(/*! ./draw */ 1),\n    __webpack_require__(/*! ./events */ 2),\n    __webpack_require__(/*! ./intf */ 3),\n    __webpack_require__(/*! ./contextMenu */ 4),\n    __webpack_require__(/*! ./defaults */ 5),\n    __webpack_require__(/*! ./dom */ 6),\n    __webpack_require__(/*! ./publicMethods */ 7)\n], __WEBPACK_AMD_DEFINE_RESULT__ = function context() {\n    'use strict';\n    var modules = Array.prototype.slice.call(arguments);\n    function grid(args) {\n        args = args || {};\n        var self = {};\n        self.args = args;\n        self.createGrid = grid;\n        self.orders = {\n            rows: [],\n            columns: []\n        };\n        self.hasFocus = false;\n        self.activeCell = {\n            columnIndex: 0,\n            rowIndex: 0\n        };\n        self.storageName = 'canvasDataGrid';\n        self.invalidSearchExpClass = 'canvas-datagrid-invalid-search-regExp';\n        self.uniqueId = '_canvasDataGridUniqueId';\n        self.orderBy = self.uniqueId;\n        self.orderDirection = 'asc';\n        self.columnFilters = {};\n        self.filters = {};\n        self.ellipsisCache = {};\n        self.scrollBox = {};\n        self.visibleRows = [];\n        self.sizes = {\n            rows: {},\n            columns: {},\n            trees: {}\n        };\n        self.currentFilter = function () {\n            return true;\n        };\n        self.selections = [];\n        self.hovers = {};\n        self.attributes = {};\n        self.style = {};\n        self.intf = {};\n        self.formatters = {};\n        self.sorters = {};\n        self.schemaHashes = {};\n        self.events = {};\n        self.uId = 0;\n        self.changes = [];\n        self.scrollIndexTop = 0;\n        self.scrollPixelTop = 0;\n        self.scrollIndexLeft = 0;\n        self.scrollPixelLeft = 0;\n        self.childGrids = {};\n        self.openChildren = {};\n        self.scrollModes = [\n            'vertical-scroll-box',\n            'vertical-scroll-top',\n            'vertical-scroll-bottom',\n            'horizontal-scroll-box',\n            'horizontal-scroll-right',\n            'horizontal-scroll-left'\n        ];\n        self.mouse = { x: 0, y: 0};\n        self.getSelectedData = function (expandToRow) {\n            var d = [], s = self.getSchema(), l = self.data.length;\n            self.selections.forEach(function (row, index) {\n                if (index === l) { return; }\n                d[index] = {};\n                if (expandToRow) {\n                    s.forEach(function (column) {\n                        d[index][column.name] = self.data[index][column.name];\n                    });\n                } else {\n                    row.forEach(function (col) {\n                        if (col === -1) { return; }\n                        d[index][s[col].name] = self.data[index][s[col].name];\n                    });\n                }\n            });\n            return d;\n        };\n        self.scrollOffset = function (e) {\n            var x = 0, y = 0;\n            while (e.parentNode) {\n                if (e.nodeType !== 'canvas-datagrid-tree'\n                        && e.nodeType !== 'canvas-datagrid-cell') {\n                    x -= e.scrollLeft;\n                    y -= e.scrollTop;\n                }\n                e = e.parentNode;\n            }\n            return {left: x, top: y};\n        };\n        self.position = function (e, ignoreScrollOffset) {\n            var x = 0, y = 0, s = e, h, w;\n            while (e.offsetParent) {\n                x += e.offsetLeft;\n                y += e.offsetTop;\n                h = e.offsetHeight;\n                w = e.offsetWidth;\n                e = e.offsetParent;\n            }\n            if (ignoreScrollOffset) {\n                return {left: x, top: y, height: h, width: w};\n            }\n            e = s;\n            s = self.scrollOffset(e);\n            return { left: x + s.left, top: y + s.top, height: h, width: w };\n        };\n        self.getLayerPos = function (e) {\n            var rect = self.canvas.getBoundingClientRect(),\n                pos = {\n                    x: e.clientX - rect.left,\n                    y: e.clientY - rect.top\n                };\n            if (self.isChildGrid) {\n                pos.x -= self.canvasOffsetLeft;\n                pos.y -= self.canvasOffsetTop;\n            }\n            return {\n                x: pos.x,\n                y: pos.y\n            };\n        };\n        self.fillArray = function (low, high, step) {\n            step = step || 1;\n            var i = [], x;\n            for (x = low; x <= high; x += step) {\n                i[x] = x;\n            }\n            return i;\n        };\n        self.getHeaderCellHeight = function () {\n            return self.sizes.rows[-1] || self.style.headerCellHeight;\n        };\n        self.getHeaderCellWidth = function () {\n            return self.attributes.showRowHeaders\n                ? (self.sizes.columns.cornerCell ||  self.style.headerRowWidth) : 0;\n        };\n        self.setStorageData = function () {\n            if (!self.attributes.saveAppearance) { return; }\n            localStorage.setItem(self.storageName + '-' + self.attributes.name, JSON.stringify({\n                sizes: {\n                    rows: self.sizes.rows,\n                    columns: self.sizes.columns\n                },\n                orders: {\n                    rows: self.orders.rows,\n                    columns: self.orders.columns\n                },\n                orderBy: self.orderBy,\n                orderDirection: self.orderDirection\n            }));\n        };\n        self.getSchema = function () {\n            return self.schema || self.tempSchema;\n        };\n        self.createColumnOrders = function () {\n            var s = self.getSchema();\n            self.orders.columns = self.fillArray(0, s.length - 1);\n        };\n        self.createRowOrders = function () {\n            self.orders.rows = self.fillArray(0, self.data.length - 1);\n        };\n        self.getVisibleSchema = function () {\n            return self.getSchema().filter(function (col) { return !col.hidden; });\n        };\n        self.createNewRowData = function () {\n            self.newRow = {};\n            self.newRow[self.uniqueId] = self.uId;\n            self.uId += 1;\n            self.getSchema().forEach(function forEachHeader(header, index) {\n                var d = header.defaultValue || '';\n                if (typeof d === 'function') {\n                    d = d.apply(self.intf, [header, index]);\n                }\n                self.newRow[header.name] = d;\n            });\n        };\n        self.addEllipsis = function (text, width) {\n            var o, i, c = self.style.cellPaddingRight + self.style.cellPaddingLeft;\n            if (self.ellipsisCache[text] && self.ellipsisCache[text][width]) {\n                return self.ellipsisCache[text][width];\n            }\n            if (self.ctx.measureText(text).width + c < width) {\n                o = text;\n            } else {\n                o = text.substring(0, 1);\n                i = 1;\n                while (width > (self.ctx.measureText(o).width + c)) {\n                    i += 1;\n                    o = text.substring(0, i) + \"...\";\n                }\n            }\n            self.ellipsisCache[text] = self.ellipsisCache[text] || {};\n            self.ellipsisCache[text][width] = o;\n            return o;\n        };\n        self.getSchemaNameHash = function (key) {\n            var n = 0;\n            while (self.schemaHashes[key]) {\n                n += 1;\n                key = key + n;\n            }\n            return key;\n        };\n        self.filter = function (type) {\n            var f = self.filters[type];\n            if (!f && type !== undefined) {\n                console.warn('Cannot find filter for type %s, falling back to substring match.', type);\n                f = self.filters.string;\n            }\n            return f;\n        };\n        self.getBestGuessDataType = function (columnName) {\n            var t, x, l = self.data.length;\n            for (x = 0; x < l; x += 1) {\n                if ([null, undefined].indexOf(self.data[x][columnName]) !== -1) {\n                    t = typeof self.data[x];\n                    return t === 'object' ? 'string' : t;\n                }\n            }\n            return 'string';\n        };\n        self.drawChildGrids = function () {\n            Object.keys(self.childGrids).forEach(function (gridKey) {\n                self.childGrids[gridKey].draw();\n            });\n        };\n        self.resizeChildGrids = function () {\n            Object.keys(self.childGrids).forEach(function (gridKey) {\n                self.childGrids[gridKey].resize();\n            });\n        };\n        self.getClippingRect = function (ele) {\n            var boundingRect = self.position(self.parentNode),\n                eleRect = self.position(ele),\n                clipRect = {\n                    x: 0,\n                    y: 0,\n                    h: 0,\n                    w: 0\n                },\n                parentRect = {\n                    x: -Infinity,\n                    y: -Infinity,\n                    h: Infinity,\n                    w: Infinity\n                },\n                headerCellHeight = self.getHeaderCellHeight(),\n                headerCellWidth = self.getHeaderCellWidth();\n            clipRect.h = boundingRect.top + boundingRect.height - ele.offsetTop - self.style.scrollBarWidth;\n            clipRect.w = boundingRect.left + boundingRect.width - ele.offsetLeft - self.style.scrollBarWidth;\n            clipRect.x = boundingRect.left + (eleRect.left * -1) + headerCellWidth;\n            clipRect.y = boundingRect.top + (eleRect.top * -1) + headerCellHeight;\n            return {\n                x: clipRect.x > parentRect.x ? clipRect.x : parentRect.x,\n                y: clipRect.y > parentRect.y ? clipRect.y : parentRect.y,\n                h: clipRect.h < parentRect.h ? clipRect.h : parentRect.h,\n                w: clipRect.w < parentRect.w ? clipRect.w : parentRect.w\n            };\n        };\n        self.clipElement = function (ele) {\n            var clipRect = self.getClippingRect(ele);\n            if (clipRect.w < 0) { clipRect.w = 0; }\n            if (clipRect.h < 0) { clipRect.h = 0; }\n            ele.style.clip = 'rect('\n                + clipRect.y + 'px,'\n                + clipRect.w + 'px,'\n                + clipRect.h + 'px,'\n                + clipRect.x + 'px'\n                + ')';\n            // INFO https://developer.mozilla.org/en-US/docs/Web/CSS/clip\n            // clip has been \"deprecated\" for clipPath.  Of course nothing but chrome\n            // supports clip path, so we'll keep using clip until someday clipPath becomes\n            // more widely support.  The code below works correctly, but setting clipPath and clip\n            // at the same time has undesirable results.\n            // ele.style.clipPath = 'polygon('\n            //     + clipRect.x + 'px ' + clipRect.y + 'px,'\n            //     + clipRect.x + 'px ' + clipRect.h + 'px,'\n            //     + clipRect.w + 'px ' + clipRect.h + 'px,'\n            //     + clipRect.w + 'px ' + clipRect.y + 'px'\n            //     + ')';\n        };\n        self.autoScrollZone = function (e, x, y, ctrl) {\n            var setTimer,\n                headerCellWidth = self.getHeaderCellWidth(),\n                headerCellHeight = self.getHeaderCellHeight();\n            if (x > self.width - self.attributes.selectionScrollZone && x < self.width) {\n                self.scrollBox.scrollLeft += self.attributes.selectionScrollIncrement;\n                setTimer = true;\n            }\n            if (y > self.height - self.attributes.selectionScrollZone && y < self.height) {\n                self.scrollBox.scrollTop += self.attributes.selectionScrollIncrement;\n                setTimer = true;\n            }\n            if (x - self.attributes.selectionScrollZone - headerCellWidth < 0) {\n                self.scrollBox.scrollLeft -= self.attributes.selectionScrollIncrement;\n                setTimer = true;\n            }\n            if (y - self.attributes.selectionScrollZone - headerCellHeight < 0) {\n                self.scrollBox.scrollTop -= self.attributes.selectionScrollIncrement;\n                setTimer = true;\n            }\n            if (setTimer && !ctrl && self.currentCell && self.currentCell.columnIndex !== -1) {\n                self.scrollTimer = setTimeout(self.mousemove, self.attributes.scrollRepeatRate, e);\n            }\n        };\n        self.refreshFromOrigialData = function () {\n            self.data = self.originalData.filter(function (row) {\n                return true;\n            });\n        };\n        self.validateColumn = function (c, s) {\n            if (!c.name) {\n                throw new Error('A column must contain at least a name.');\n            }\n            if (s.filter(function (i) { return i.name === c.name; }).length > 0) {\n                throw new Error('A column with the name '\n                    + c.name + ' already exists and cannot be added again.');\n            }\n            return true;\n        };\n        self.setDefaults = function (obj1, obj2, key, def) {\n            obj1[key] = obj2[key] === undefined ? def : obj2[key];\n        };\n        self.setAttributes = function () {\n            self.defaults.attributes.forEach(function eachAttribute(i) {\n                self.setDefaults(self.attributes, args, i[0], i[1]);\n            });\n        };\n        self.setStyle = function () {\n            self.defaults.styles.forEach(function eachStyle(i) {\n                self.setDefaults(self.style, args.style || {}, i[0], i[1]);\n            });\n        };\n        self.autosize = function (colName) {\n            self.getVisibleSchema().forEach(function (col) {\n                if (col.name === colName || colName === undefined) {\n                    self.fitColumnToValues(col.name);\n                }\n            });\n            self.fitColumnToValues('cornerCell');\n        };\n        self.dispose = function () {\n            if (!self.isChildGrid && self.canvas && self.canvas.parentNode) {\n                self.canvas.parentNode.removeChild(self.canvas);\n            }\n            self.eventParent.removeEventListener('mouseup', self.mouseup, false);\n            self.eventParent.removeEventListener('mousedown', self.mousedown, false);\n            self.eventParent.removeEventListener('dblclick', self.dblclick, false);\n            self.eventParent.removeEventListener('click', self.click, false);\n            self.eventParent.removeEventListener('mousemove', self.mousemove);\n            self.eventParent.removeEventListener('mousewheel', self.scrollWheel, false);\n            self.canvas.removeEventListener('contextmenu', self.contextmenu, false);\n            self.canvas.removeEventListener('copy', self.copy);\n            self.controlInput.removeEventListener('keypress', self.keypress, false);\n            self.controlInput.removeEventListener('keyup', self.keyup, false);\n            self.controlInput.removeEventListener('keydown', self.keydown, false);\n            window.removeEventListener('resize', self.resize);\n            if (self.observer && self.observer.disconnect) {\n                self.observer.disconnect();\n            }\n        };\n        self.tryLoadStoredOrders = function () {\n            var s;\n            if (self.storedSettings && typeof self.storedSettings.orders === 'object') {\n                if (self.storedSettings.orders.rows.length >= self.data.length) {\n                    self.orders.rows = self.storedSettings.orders.rows;\n                }\n                s = self.getSchema();\n                self.orders.columns = self.storedSettings.orders.columns;\n                s.forEach(function (h, i) {\n                    if (self.orders.columns.indexOf(i) === -1) {\n                        self.orders.columns.push(i);\n                    }\n                });\n                self.orderBy = self.storedSettings.orderBy === undefined\n                    ? self.uniqueId : self.storedSettings.orderBy;\n                self.orderDirection = self.storedSettings.orderDirection === undefined\n                    ? self.uniqueId : self.storedSettings.orderDirection;\n                if (self.getHeaderByName(self.orderBy) && self.orderDirection) {\n                    self.order(self.orderBy, self.orderDirection);\n                }\n            }\n        };\n        self.init = function () {\n            self.setAttributes();\n            self.setStyle();\n            self.initScrollBox();\n            self.setDom();\n            self.intf.type = 'canvas-datagrid';\n            self.intf.addEventListener = self.addEventListener;\n            self.intf.removeEventListener = self.removeEventListener;\n            self.intf.dispatchEvent = self.dispatchEvent;\n            self.intf.dispose = self.dispose;\n            self.intf.appendTo = self.appendTo;\n            self.intf.filters = self.filters;\n            self.intf.sorters = self.sorters;\n            self.intf.autosize = self.autosize;\n            self.intf.beginEditAt = self.beginEditAt;\n            self.intf.endEdit = self.endEdit;\n            self.intf.setActiveCell = self.setActiveCell;\n            self.intf.scrollIntoView = self.scrollIntoView;\n            self.intf.clearChangeLog = self.clearChangeLog;\n            self.intf.gotoCell = self.gotoCell;\n            self.intf.gotoRow = self.gotoRow;\n            self.intf.findColumnScrollLeft = self.findColumnScrollLeft;\n            self.intf.findRowScrollTop = self.findRowScrollTop;\n            self.intf.fitColumnToValues = self.fitColumnToValues;\n            self.intf.findColumnMaxTextLength = self.findColumnMaxTextLength;\n            self.intf.disposeContextMenu = self.disposeContextMenu;\n            self.intf.getCellAt = self.getCellAt;\n            self.intf.isCellVisible = self.isCellVisible;\n            self.intf.order = self.order;\n            self.intf.draw = self.draw;\n            self.intf.selectArea = self.selectArea;\n            self.intf.clipElement = self.clipElement;\n            self.intf.getSchemaFromData = self.getSchemaFromData;\n            self.intf.setFilter = self.setFilter;\n            self.intf.selectRow = self.selectRow;\n            self.intf.parentGrid = self.parentGrid;\n            self.intf.toggleTree = self.toggleTree;\n            self.intf.expandTree = self.expandTree;\n            self.intf.collapseTree = self.collapseTree;\n            self.intf.canvas = self.canvas;\n            self.intf.context = self.ctx;\n            self.intf.insertRow = self.insertRow;\n            self.intf.deleteRow = self.deleteRow;\n            self.intf.addRow = self.addRow;\n            self.intf.insertColumn = self.insertColumn;\n            self.intf.deleteColumn = self.deleteColumn;\n            self.intf.addColumn = self.addColumn;\n            self.intf.getClippingRect = self.getClippingRect;\n            self.intf.setRowHeight = self.setRowHeight;\n            self.intf.setColumnWidth = self.setColumnWidth;\n            self.intf.resetColumnWidths = self.resetColumnWidths;\n            self.intf.resetRowHeights = self.resetRowHeights;\n            self.intf.resize = self.resize;\n            self.intf.drawChildGrids = self.drawChildGrids;\n            Object.keys(self.style).forEach(function (key) {\n                Object.defineProperty(self.intf.style, key, {\n                    get: function () {\n                        return self.style[key];\n                    },\n                    set: function (value) {\n                        self.style[key] = value;\n                        self.draw(true);\n                    }\n                });\n            });\n            Object.keys(self.attributes).forEach(function (key) {\n                Object.defineProperty(self.intf.attributes, key, {\n                    get: function () {\n                        return self.attributes[key];\n                    },\n                    set: function (value) {\n                        self.attributes[key] = value;\n                        self.draw(true);\n                    }\n                });\n            });\n            self.filters.string = function (value, filterFor) {\n                if (!filterFor) { return true; }\n                var filterRegExp;\n                self.invalidFilterRegEx = undefined;\n                try {\n                    filterRegExp = new RegExp(filterFor, 'ig');\n                } catch (e) {\n                    self.invalidFilterRegEx = e;\n                    return;\n                }\n                return filterRegExp.test(value);\n            };\n            self.filters.number = function (value, filterFor) {\n                if (!filterFor) { return true; }\n                return value === filterFor;\n            };\n            if (self.attributes.name && self.attributes.saveAppearance) {\n                self.storedSettings = localStorage.getItem(self.storageName + '-' + self.attributes.name);\n                if (self.storedSettings) {\n                    try {\n                        self.storedSettings = JSON.parse(self.storedSettings);\n                    } catch (e) {\n                        console.warn('could not read settings from localStore', e);\n                        self.storedSettings = undefined;\n                    }\n                }\n                if (self.storedSettings) {\n                    if (typeof self.storedSettings.sizes === 'object') {\n                        self.sizes.rows = self.storedSettings.sizes.rows;\n                        self.sizes.columns = self.storedSettings.sizes.columns;\n                        ['trees', 'columns', 'rows'].forEach(function (i) {\n                            if (!self.sizes[i]) {\n                                self.sizes[i] = {};\n                            }\n                        });\n                    }\n                }\n            }\n            if (args.data) {\n                self.intf.data = args.data;\n            }\n            if (args.schema) {\n                self.intf.schema = args.schema;\n            }\n            if (!self.data) {\n                self.intf.data = [];\n            }\n            self.resize(true);\n        };\n        modules.forEach(function (module) {\n            module(self);\n        });\n        self.init();\n        return self.intf;\n    }\n    if (window && !window.canvasDatagrid) {\n        window.canvasDatagrid = grid;\n    }\n    return grid;\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi9tYWluLmpzPzhlNTQiXSwic291cmNlc0NvbnRlbnQiOlsiLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgdW5wYXJhbTogdHJ1ZSwgdG9kbzogdHJ1ZSovXG4vKmdsb2JhbHMgZGVmaW5lOiB0cnVlLCBNdXRhdGlvbk9ic2VydmVyOiBmYWxzZSwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lOiBmYWxzZSwgcGVyZm9ybWFuY2U6IGZhbHNlLCBidG9hOiBmYWxzZSovXG5kZWZpbmUoW1xuICAgICcuL2RyYXcnLFxuICAgICcuL2V2ZW50cycsXG4gICAgJy4vaW50ZicsXG4gICAgJy4vY29udGV4dE1lbnUnLFxuICAgICcuL2RlZmF1bHRzJyxcbiAgICAnLi9kb20nLFxuICAgICcuL3B1YmxpY01ldGhvZHMnXG5dLCBmdW5jdGlvbiBjb250ZXh0KCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgbW9kdWxlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgZnVuY3Rpb24gZ3JpZChhcmdzKSB7XG4gICAgICAgIGFyZ3MgPSBhcmdzIHx8IHt9O1xuICAgICAgICB2YXIgc2VsZiA9IHt9O1xuICAgICAgICBzZWxmLmFyZ3MgPSBhcmdzO1xuICAgICAgICBzZWxmLmNyZWF0ZUdyaWQgPSBncmlkO1xuICAgICAgICBzZWxmLm9yZGVycyA9IHtcbiAgICAgICAgICAgIHJvd3M6IFtdLFxuICAgICAgICAgICAgY29sdW1uczogW11cbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5oYXNGb2N1cyA9IGZhbHNlO1xuICAgICAgICBzZWxmLmFjdGl2ZUNlbGwgPSB7XG4gICAgICAgICAgICBjb2x1bW5JbmRleDogMCxcbiAgICAgICAgICAgIHJvd0luZGV4OiAwXG4gICAgICAgIH07XG4gICAgICAgIHNlbGYuc3RvcmFnZU5hbWUgPSAnY2FudmFzRGF0YUdyaWQnO1xuICAgICAgICBzZWxmLmludmFsaWRTZWFyY2hFeHBDbGFzcyA9ICdjYW52YXMtZGF0YWdyaWQtaW52YWxpZC1zZWFyY2gtcmVnRXhwJztcbiAgICAgICAgc2VsZi51bmlxdWVJZCA9ICdfY2FudmFzRGF0YUdyaWRVbmlxdWVJZCc7XG4gICAgICAgIHNlbGYub3JkZXJCeSA9IHNlbGYudW5pcXVlSWQ7XG4gICAgICAgIHNlbGYub3JkZXJEaXJlY3Rpb24gPSAnYXNjJztcbiAgICAgICAgc2VsZi5jb2x1bW5GaWx0ZXJzID0ge307XG4gICAgICAgIHNlbGYuZmlsdGVycyA9IHt9O1xuICAgICAgICBzZWxmLmVsbGlwc2lzQ2FjaGUgPSB7fTtcbiAgICAgICAgc2VsZi5zY3JvbGxCb3ggPSB7fTtcbiAgICAgICAgc2VsZi52aXNpYmxlUm93cyA9IFtdO1xuICAgICAgICBzZWxmLnNpemVzID0ge1xuICAgICAgICAgICAgcm93czoge30sXG4gICAgICAgICAgICBjb2x1bW5zOiB7fSxcbiAgICAgICAgICAgIHRyZWVzOiB7fVxuICAgICAgICB9O1xuICAgICAgICBzZWxmLmN1cnJlbnRGaWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5zZWxlY3Rpb25zID0gW107XG4gICAgICAgIHNlbGYuaG92ZXJzID0ge307XG4gICAgICAgIHNlbGYuYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICBzZWxmLnN0eWxlID0ge307XG4gICAgICAgIHNlbGYuaW50ZiA9IHt9O1xuICAgICAgICBzZWxmLmZvcm1hdHRlcnMgPSB7fTtcbiAgICAgICAgc2VsZi5zb3J0ZXJzID0ge307XG4gICAgICAgIHNlbGYuc2NoZW1hSGFzaGVzID0ge307XG4gICAgICAgIHNlbGYuZXZlbnRzID0ge307XG4gICAgICAgIHNlbGYudUlkID0gMDtcbiAgICAgICAgc2VsZi5jaGFuZ2VzID0gW107XG4gICAgICAgIHNlbGYuc2Nyb2xsSW5kZXhUb3AgPSAwO1xuICAgICAgICBzZWxmLnNjcm9sbFBpeGVsVG9wID0gMDtcbiAgICAgICAgc2VsZi5zY3JvbGxJbmRleExlZnQgPSAwO1xuICAgICAgICBzZWxmLnNjcm9sbFBpeGVsTGVmdCA9IDA7XG4gICAgICAgIHNlbGYuY2hpbGRHcmlkcyA9IHt9O1xuICAgICAgICBzZWxmLm9wZW5DaGlsZHJlbiA9IHt9O1xuICAgICAgICBzZWxmLnNjcm9sbE1vZGVzID0gW1xuICAgICAgICAgICAgJ3ZlcnRpY2FsLXNjcm9sbC1ib3gnLFxuICAgICAgICAgICAgJ3ZlcnRpY2FsLXNjcm9sbC10b3AnLFxuICAgICAgICAgICAgJ3ZlcnRpY2FsLXNjcm9sbC1ib3R0b20nLFxuICAgICAgICAgICAgJ2hvcml6b250YWwtc2Nyb2xsLWJveCcsXG4gICAgICAgICAgICAnaG9yaXpvbnRhbC1zY3JvbGwtcmlnaHQnLFxuICAgICAgICAgICAgJ2hvcml6b250YWwtc2Nyb2xsLWxlZnQnXG4gICAgICAgIF07XG4gICAgICAgIHNlbGYubW91c2UgPSB7IHg6IDAsIHk6IDB9O1xuICAgICAgICBzZWxmLmdldFNlbGVjdGVkRGF0YSA9IGZ1bmN0aW9uIChleHBhbmRUb1Jvdykge1xuICAgICAgICAgICAgdmFyIGQgPSBbXSwgcyA9IHNlbGYuZ2V0U2NoZW1hKCksIGwgPSBzZWxmLmRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgc2VsZi5zZWxlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKHJvdywgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IGwpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICAgICAgZFtpbmRleF0gPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwYW5kVG9Sb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgcy5mb3JFYWNoKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRbaW5kZXhdW2NvbHVtbi5uYW1lXSA9IHNlbGYuZGF0YVtpbmRleF1bY29sdW1uLm5hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByb3cuZm9yRWFjaChmdW5jdGlvbiAoY29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sID09PSAtMSkgeyByZXR1cm47IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRbaW5kZXhdW3NbY29sXS5uYW1lXSA9IHNlbGYuZGF0YVtpbmRleF1bc1tjb2xdLm5hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9O1xuICAgICAgICBzZWxmLnNjcm9sbE9mZnNldCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgeCA9IDAsIHkgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChlLm5vZGVUeXBlICE9PSAnY2FudmFzLWRhdGFncmlkLXRyZWUnXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBlLm5vZGVUeXBlICE9PSAnY2FudmFzLWRhdGFncmlkLWNlbGwnKSB7XG4gICAgICAgICAgICAgICAgICAgIHggLT0gZS5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgICAgICAgICB5IC09IGUuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlID0gZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtsZWZ0OiB4LCB0b3A6IHl9O1xuICAgICAgICB9O1xuICAgICAgICBzZWxmLnBvc2l0aW9uID0gZnVuY3Rpb24gKGUsIGlnbm9yZVNjcm9sbE9mZnNldCkge1xuICAgICAgICAgICAgdmFyIHggPSAwLCB5ID0gMCwgcyA9IGUsIGgsIHc7XG4gICAgICAgICAgICB3aGlsZSAoZS5vZmZzZXRQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB4ICs9IGUub2Zmc2V0TGVmdDtcbiAgICAgICAgICAgICAgICB5ICs9IGUub2Zmc2V0VG9wO1xuICAgICAgICAgICAgICAgIGggPSBlLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgICB3ID0gZS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgICAgICBlID0gZS5vZmZzZXRQYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaWdub3JlU2Nyb2xsT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtsZWZ0OiB4LCB0b3A6IHksIGhlaWdodDogaCwgd2lkdGg6IHd9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZSA9IHM7XG4gICAgICAgICAgICBzID0gc2VsZi5zY3JvbGxPZmZzZXQoZSk7XG4gICAgICAgICAgICByZXR1cm4geyBsZWZ0OiB4ICsgcy5sZWZ0LCB0b3A6IHkgKyBzLnRvcCwgaGVpZ2h0OiBoLCB3aWR0aDogdyB9O1xuICAgICAgICB9O1xuICAgICAgICBzZWxmLmdldExheWVyUG9zID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gc2VsZi5jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICAgICAgcG9zID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBlLmNsaWVudFggLSByZWN0LmxlZnQsXG4gICAgICAgICAgICAgICAgICAgIHk6IGUuY2xpZW50WSAtIHJlY3QudG9wXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChzZWxmLmlzQ2hpbGRHcmlkKSB7XG4gICAgICAgICAgICAgICAgcG9zLnggLT0gc2VsZi5jYW52YXNPZmZzZXRMZWZ0O1xuICAgICAgICAgICAgICAgIHBvcy55IC09IHNlbGYuY2FudmFzT2Zmc2V0VG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBwb3MueCxcbiAgICAgICAgICAgICAgICB5OiBwb3MueVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5maWxsQXJyYXkgPSBmdW5jdGlvbiAobG93LCBoaWdoLCBzdGVwKSB7XG4gICAgICAgICAgICBzdGVwID0gc3RlcCB8fCAxO1xuICAgICAgICAgICAgdmFyIGkgPSBbXSwgeDtcbiAgICAgICAgICAgIGZvciAoeCA9IGxvdzsgeCA8PSBoaWdoOyB4ICs9IHN0ZXApIHtcbiAgICAgICAgICAgICAgICBpW3hdID0geDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9O1xuICAgICAgICBzZWxmLmdldEhlYWRlckNlbGxIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5zaXplcy5yb3dzWy0xXSB8fCBzZWxmLnN0eWxlLmhlYWRlckNlbGxIZWlnaHQ7XG4gICAgICAgIH07XG4gICAgICAgIHNlbGYuZ2V0SGVhZGVyQ2VsbFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuYXR0cmlidXRlcy5zaG93Um93SGVhZGVyc1xuICAgICAgICAgICAgICAgID8gKHNlbGYuc2l6ZXMuY29sdW1ucy5jb3JuZXJDZWxsIHx8ICBzZWxmLnN0eWxlLmhlYWRlclJvd1dpZHRoKSA6IDA7XG4gICAgICAgIH07XG4gICAgICAgIHNlbGYuc2V0U3RvcmFnZURhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXNlbGYuYXR0cmlidXRlcy5zYXZlQXBwZWFyYW5jZSkgeyByZXR1cm47IH1cbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHNlbGYuc3RvcmFnZU5hbWUgKyAnLScgKyBzZWxmLmF0dHJpYnV0ZXMubmFtZSwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHNpemVzOiB7XG4gICAgICAgICAgICAgICAgICAgIHJvd3M6IHNlbGYuc2l6ZXMucm93cyxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uczogc2VsZi5zaXplcy5jb2x1bW5zXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvcmRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgcm93czogc2VsZi5vcmRlcnMucm93cyxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uczogc2VsZi5vcmRlcnMuY29sdW1uc1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb3JkZXJCeTogc2VsZi5vcmRlckJ5LFxuICAgICAgICAgICAgICAgIG9yZGVyRGlyZWN0aW9uOiBzZWxmLm9yZGVyRGlyZWN0aW9uXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHNlbGYuZ2V0U2NoZW1hID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuc2NoZW1hIHx8IHNlbGYudGVtcFNjaGVtYTtcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5jcmVhdGVDb2x1bW5PcmRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcyA9IHNlbGYuZ2V0U2NoZW1hKCk7XG4gICAgICAgICAgICBzZWxmLm9yZGVycy5jb2x1bW5zID0gc2VsZi5maWxsQXJyYXkoMCwgcy5sZW5ndGggLSAxKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5jcmVhdGVSb3dPcmRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLm9yZGVycy5yb3dzID0gc2VsZi5maWxsQXJyYXkoMCwgc2VsZi5kYXRhLmxlbmd0aCAtIDEpO1xuICAgICAgICB9O1xuICAgICAgICBzZWxmLmdldFZpc2libGVTY2hlbWEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5nZXRTY2hlbWEoKS5maWx0ZXIoZnVuY3Rpb24gKGNvbCkgeyByZXR1cm4gIWNvbC5oaWRkZW47IH0pO1xuICAgICAgICB9O1xuICAgICAgICBzZWxmLmNyZWF0ZU5ld1Jvd0RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLm5ld1JvdyA9IHt9O1xuICAgICAgICAgICAgc2VsZi5uZXdSb3dbc2VsZi51bmlxdWVJZF0gPSBzZWxmLnVJZDtcbiAgICAgICAgICAgIHNlbGYudUlkICs9IDE7XG4gICAgICAgICAgICBzZWxmLmdldFNjaGVtYSgpLmZvckVhY2goZnVuY3Rpb24gZm9yRWFjaEhlYWRlcihoZWFkZXIsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBoZWFkZXIuZGVmYXVsdFZhbHVlIHx8ICcnO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBkID0gZC5hcHBseShzZWxmLmludGYsIFtoZWFkZXIsIGluZGV4XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYubmV3Um93W2hlYWRlci5uYW1lXSA9IGQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5hZGRFbGxpcHNpcyA9IGZ1bmN0aW9uICh0ZXh0LCB3aWR0aCkge1xuICAgICAgICAgICAgdmFyIG8sIGksIGMgPSBzZWxmLnN0eWxlLmNlbGxQYWRkaW5nUmlnaHQgKyBzZWxmLnN0eWxlLmNlbGxQYWRkaW5nTGVmdDtcbiAgICAgICAgICAgIGlmIChzZWxmLmVsbGlwc2lzQ2FjaGVbdGV4dF0gJiYgc2VsZi5lbGxpcHNpc0NhY2hlW3RleHRdW3dpZHRoXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmVsbGlwc2lzQ2FjaGVbdGV4dF1bd2lkdGhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuY3R4Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoICsgYyA8IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgbyA9IHRleHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG8gPSB0ZXh0LnN1YnN0cmluZygwLCAxKTtcbiAgICAgICAgICAgICAgICBpID0gMTtcbiAgICAgICAgICAgICAgICB3aGlsZSAod2lkdGggPiAoc2VsZi5jdHgubWVhc3VyZVRleHQobykud2lkdGggKyBjKSkge1xuICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIG8gPSB0ZXh0LnN1YnN0cmluZygwLCBpKSArIFwiLi4uXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5lbGxpcHNpc0NhY2hlW3RleHRdID0gc2VsZi5lbGxpcHNpc0NhY2hlW3RleHRdIHx8IHt9O1xuICAgICAgICAgICAgc2VsZi5lbGxpcHNpc0NhY2hlW3RleHRdW3dpZHRoXSA9IG87XG4gICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5nZXRTY2hlbWFOYW1lSGFzaCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChzZWxmLnNjaGVtYUhhc2hlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgbiArPSAxO1xuICAgICAgICAgICAgICAgIGtleSA9IGtleSArIG47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9O1xuICAgICAgICBzZWxmLmZpbHRlciA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICB2YXIgZiA9IHNlbGYuZmlsdGVyc1t0eXBlXTtcbiAgICAgICAgICAgIGlmICghZiAmJiB0eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0Nhbm5vdCBmaW5kIGZpbHRlciBmb3IgdHlwZSAlcywgZmFsbGluZyBiYWNrIHRvIHN1YnN0cmluZyBtYXRjaC4nLCB0eXBlKTtcbiAgICAgICAgICAgICAgICBmID0gc2VsZi5maWx0ZXJzLnN0cmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9O1xuICAgICAgICBzZWxmLmdldEJlc3RHdWVzc0RhdGFUeXBlID0gZnVuY3Rpb24gKGNvbHVtbk5hbWUpIHtcbiAgICAgICAgICAgIHZhciB0LCB4LCBsID0gc2VsZi5kYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoeCA9IDA7IHggPCBsOyB4ICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoW251bGwsIHVuZGVmaW5lZF0uaW5kZXhPZihzZWxmLmRhdGFbeF1bY29sdW1uTmFtZV0pICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0ID0gdHlwZW9mIHNlbGYuZGF0YVt4XTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQgPT09ICdvYmplY3QnID8gJ3N0cmluZycgOiB0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnc3RyaW5nJztcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5kcmF3Q2hpbGRHcmlkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHNlbGYuY2hpbGRHcmlkcykuZm9yRWFjaChmdW5jdGlvbiAoZ3JpZEtleSkge1xuICAgICAgICAgICAgICAgIHNlbGYuY2hpbGRHcmlkc1tncmlkS2V5XS5kcmF3KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5yZXNpemVDaGlsZEdyaWRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoc2VsZi5jaGlsZEdyaWRzKS5mb3JFYWNoKGZ1bmN0aW9uIChncmlkS2V5KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jaGlsZEdyaWRzW2dyaWRLZXldLnJlc2l6ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHNlbGYuZ2V0Q2xpcHBpbmdSZWN0ID0gZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IHNlbGYucG9zaXRpb24oc2VsZi5wYXJlbnROb2RlKSxcbiAgICAgICAgICAgICAgICBlbGVSZWN0ID0gc2VsZi5wb3NpdGlvbihlbGUpLFxuICAgICAgICAgICAgICAgIGNsaXBSZWN0ID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgICAgICBoOiAwLFxuICAgICAgICAgICAgICAgICAgICB3OiAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwYXJlbnRSZWN0ID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiAtSW5maW5pdHksXG4gICAgICAgICAgICAgICAgICAgIHk6IC1JbmZpbml0eSxcbiAgICAgICAgICAgICAgICAgICAgaDogSW5maW5pdHksXG4gICAgICAgICAgICAgICAgICAgIHc6IEluZmluaXR5XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBoZWFkZXJDZWxsSGVpZ2h0ID0gc2VsZi5nZXRIZWFkZXJDZWxsSGVpZ2h0KCksXG4gICAgICAgICAgICAgICAgaGVhZGVyQ2VsbFdpZHRoID0gc2VsZi5nZXRIZWFkZXJDZWxsV2lkdGgoKTtcbiAgICAgICAgICAgIGNsaXBSZWN0LmggPSBib3VuZGluZ1JlY3QudG9wICsgYm91bmRpbmdSZWN0LmhlaWdodCAtIGVsZS5vZmZzZXRUb3AgLSBzZWxmLnN0eWxlLnNjcm9sbEJhcldpZHRoO1xuICAgICAgICAgICAgY2xpcFJlY3QudyA9IGJvdW5kaW5nUmVjdC5sZWZ0ICsgYm91bmRpbmdSZWN0LndpZHRoIC0gZWxlLm9mZnNldExlZnQgLSBzZWxmLnN0eWxlLnNjcm9sbEJhcldpZHRoO1xuICAgICAgICAgICAgY2xpcFJlY3QueCA9IGJvdW5kaW5nUmVjdC5sZWZ0ICsgKGVsZVJlY3QubGVmdCAqIC0xKSArIGhlYWRlckNlbGxXaWR0aDtcbiAgICAgICAgICAgIGNsaXBSZWN0LnkgPSBib3VuZGluZ1JlY3QudG9wICsgKGVsZVJlY3QudG9wICogLTEpICsgaGVhZGVyQ2VsbEhlaWdodDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogY2xpcFJlY3QueCA+IHBhcmVudFJlY3QueCA/IGNsaXBSZWN0LnggOiBwYXJlbnRSZWN0LngsXG4gICAgICAgICAgICAgICAgeTogY2xpcFJlY3QueSA+IHBhcmVudFJlY3QueSA/IGNsaXBSZWN0LnkgOiBwYXJlbnRSZWN0LnksXG4gICAgICAgICAgICAgICAgaDogY2xpcFJlY3QuaCA8IHBhcmVudFJlY3QuaCA/IGNsaXBSZWN0LmggOiBwYXJlbnRSZWN0LmgsXG4gICAgICAgICAgICAgICAgdzogY2xpcFJlY3QudyA8IHBhcmVudFJlY3QudyA/IGNsaXBSZWN0LncgOiBwYXJlbnRSZWN0LndcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHNlbGYuY2xpcEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgICB2YXIgY2xpcFJlY3QgPSBzZWxmLmdldENsaXBwaW5nUmVjdChlbGUpO1xuICAgICAgICAgICAgaWYgKGNsaXBSZWN0LncgPCAwKSB7IGNsaXBSZWN0LncgPSAwOyB9XG4gICAgICAgICAgICBpZiAoY2xpcFJlY3QuaCA8IDApIHsgY2xpcFJlY3QuaCA9IDA7IH1cbiAgICAgICAgICAgIGVsZS5zdHlsZS5jbGlwID0gJ3JlY3QoJ1xuICAgICAgICAgICAgICAgICsgY2xpcFJlY3QueSArICdweCwnXG4gICAgICAgICAgICAgICAgKyBjbGlwUmVjdC53ICsgJ3B4LCdcbiAgICAgICAgICAgICAgICArIGNsaXBSZWN0LmggKyAncHgsJ1xuICAgICAgICAgICAgICAgICsgY2xpcFJlY3QueCArICdweCdcbiAgICAgICAgICAgICAgICArICcpJztcbiAgICAgICAgICAgIC8vIElORk8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2NsaXBcbiAgICAgICAgICAgIC8vIGNsaXAgaGFzIGJlZW4gXCJkZXByZWNhdGVkXCIgZm9yIGNsaXBQYXRoLiAgT2YgY291cnNlIG5vdGhpbmcgYnV0IGNocm9tZVxuICAgICAgICAgICAgLy8gc3VwcG9ydHMgY2xpcCBwYXRoLCBzbyB3ZSdsbCBrZWVwIHVzaW5nIGNsaXAgdW50aWwgc29tZWRheSBjbGlwUGF0aCBiZWNvbWVzXG4gICAgICAgICAgICAvLyBtb3JlIHdpZGVseSBzdXBwb3J0LiAgVGhlIGNvZGUgYmVsb3cgd29ya3MgY29ycmVjdGx5LCBidXQgc2V0dGluZyBjbGlwUGF0aCBhbmQgY2xpcFxuICAgICAgICAgICAgLy8gYXQgdGhlIHNhbWUgdGltZSBoYXMgdW5kZXNpcmFibGUgcmVzdWx0cy5cbiAgICAgICAgICAgIC8vIGVsZS5zdHlsZS5jbGlwUGF0aCA9ICdwb2x5Z29uKCdcbiAgICAgICAgICAgIC8vICAgICArIGNsaXBSZWN0LnggKyAncHggJyArIGNsaXBSZWN0LnkgKyAncHgsJ1xuICAgICAgICAgICAgLy8gICAgICsgY2xpcFJlY3QueCArICdweCAnICsgY2xpcFJlY3QuaCArICdweCwnXG4gICAgICAgICAgICAvLyAgICAgKyBjbGlwUmVjdC53ICsgJ3B4ICcgKyBjbGlwUmVjdC5oICsgJ3B4LCdcbiAgICAgICAgICAgIC8vICAgICArIGNsaXBSZWN0LncgKyAncHggJyArIGNsaXBSZWN0LnkgKyAncHgnXG4gICAgICAgICAgICAvLyAgICAgKyAnKSc7XG4gICAgICAgIH07XG4gICAgICAgIHNlbGYuYXV0b1Njcm9sbFpvbmUgPSBmdW5jdGlvbiAoZSwgeCwgeSwgY3RybCkge1xuICAgICAgICAgICAgdmFyIHNldFRpbWVyLFxuICAgICAgICAgICAgICAgIGhlYWRlckNlbGxXaWR0aCA9IHNlbGYuZ2V0SGVhZGVyQ2VsbFdpZHRoKCksXG4gICAgICAgICAgICAgICAgaGVhZGVyQ2VsbEhlaWdodCA9IHNlbGYuZ2V0SGVhZGVyQ2VsbEhlaWdodCgpO1xuICAgICAgICAgICAgaWYgKHggPiBzZWxmLndpZHRoIC0gc2VsZi5hdHRyaWJ1dGVzLnNlbGVjdGlvblNjcm9sbFpvbmUgJiYgeCA8IHNlbGYud2lkdGgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNjcm9sbEJveC5zY3JvbGxMZWZ0ICs9IHNlbGYuYXR0cmlidXRlcy5zZWxlY3Rpb25TY3JvbGxJbmNyZW1lbnQ7XG4gICAgICAgICAgICAgICAgc2V0VGltZXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHkgPiBzZWxmLmhlaWdodCAtIHNlbGYuYXR0cmlidXRlcy5zZWxlY3Rpb25TY3JvbGxab25lICYmIHkgPCBzZWxmLmhlaWdodCkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2Nyb2xsQm94LnNjcm9sbFRvcCArPSBzZWxmLmF0dHJpYnV0ZXMuc2VsZWN0aW9uU2Nyb2xsSW5jcmVtZW50O1xuICAgICAgICAgICAgICAgIHNldFRpbWVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4IC0gc2VsZi5hdHRyaWJ1dGVzLnNlbGVjdGlvblNjcm9sbFpvbmUgLSBoZWFkZXJDZWxsV2lkdGggPCAwKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxCb3guc2Nyb2xsTGVmdCAtPSBzZWxmLmF0dHJpYnV0ZXMuc2VsZWN0aW9uU2Nyb2xsSW5jcmVtZW50O1xuICAgICAgICAgICAgICAgIHNldFRpbWVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5IC0gc2VsZi5hdHRyaWJ1dGVzLnNlbGVjdGlvblNjcm9sbFpvbmUgLSBoZWFkZXJDZWxsSGVpZ2h0IDwgMCkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2Nyb2xsQm94LnNjcm9sbFRvcCAtPSBzZWxmLmF0dHJpYnV0ZXMuc2VsZWN0aW9uU2Nyb2xsSW5jcmVtZW50O1xuICAgICAgICAgICAgICAgIHNldFRpbWVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZXRUaW1lciAmJiAhY3RybCAmJiBzZWxmLmN1cnJlbnRDZWxsICYmIHNlbGYuY3VycmVudENlbGwuY29sdW1uSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxUaW1lciA9IHNldFRpbWVvdXQoc2VsZi5tb3VzZW1vdmUsIHNlbGYuYXR0cmlidXRlcy5zY3JvbGxSZXBlYXRSYXRlLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5yZWZyZXNoRnJvbU9yaWdpYWxEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi5kYXRhID0gc2VsZi5vcmlnaW5hbERhdGEuZmlsdGVyKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBzZWxmLnZhbGlkYXRlQ29sdW1uID0gZnVuY3Rpb24gKGMsIHMpIHtcbiAgICAgICAgICAgIGlmICghYy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIGNvbHVtbiBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgYSBuYW1lLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHMuZmlsdGVyKGZ1bmN0aW9uIChpKSB7IHJldHVybiBpLm5hbWUgPT09IGMubmFtZTsgfSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSBjb2x1bW4gd2l0aCB0aGUgbmFtZSAnXG4gICAgICAgICAgICAgICAgICAgICsgYy5uYW1lICsgJyBhbHJlYWR5IGV4aXN0cyBhbmQgY2Fubm90IGJlIGFkZGVkIGFnYWluLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHNlbGYuc2V0RGVmYXVsdHMgPSBmdW5jdGlvbiAob2JqMSwgb2JqMiwga2V5LCBkZWYpIHtcbiAgICAgICAgICAgIG9iajFba2V5XSA9IG9iajJba2V5XSA9PT0gdW5kZWZpbmVkID8gZGVmIDogb2JqMltrZXldO1xuICAgICAgICB9O1xuICAgICAgICBzZWxmLnNldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLmRlZmF1bHRzLmF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbiBlYWNoQXR0cmlidXRlKGkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNldERlZmF1bHRzKHNlbGYuYXR0cmlidXRlcywgYXJncywgaVswXSwgaVsxXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5zZXRTdHlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYuZGVmYXVsdHMuc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gZWFjaFN0eWxlKGkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNldERlZmF1bHRzKHNlbGYuc3R5bGUsIGFyZ3Muc3R5bGUgfHwge30sIGlbMF0sIGlbMV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHNlbGYuYXV0b3NpemUgPSBmdW5jdGlvbiAoY29sTmFtZSkge1xuICAgICAgICAgICAgc2VsZi5nZXRWaXNpYmxlU2NoZW1hKCkuZm9yRWFjaChmdW5jdGlvbiAoY29sKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbC5uYW1lID09PSBjb2xOYW1lIHx8IGNvbE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmZpdENvbHVtblRvVmFsdWVzKGNvbC5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGYuZml0Q29sdW1uVG9WYWx1ZXMoJ2Nvcm5lckNlbGwnKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFzZWxmLmlzQ2hpbGRHcmlkICYmIHNlbGYuY2FudmFzICYmIHNlbGYuY2FudmFzLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNlbGYuY2FudmFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuZXZlbnRQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHNlbGYubW91c2V1cCwgZmFsc2UpO1xuICAgICAgICAgICAgc2VsZi5ldmVudFBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBzZWxmLm1vdXNlZG93biwgZmFsc2UpO1xuICAgICAgICAgICAgc2VsZi5ldmVudFBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIHNlbGYuZGJsY2xpY2ssIGZhbHNlKTtcbiAgICAgICAgICAgIHNlbGYuZXZlbnRQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzZWxmLmNsaWNrLCBmYWxzZSk7XG4gICAgICAgICAgICBzZWxmLmV2ZW50UGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHNlbGYubW91c2Vtb3ZlKTtcbiAgICAgICAgICAgIHNlbGYuZXZlbnRQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIHNlbGYuc2Nyb2xsV2hlZWwsIGZhbHNlKTtcbiAgICAgICAgICAgIHNlbGYuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51Jywgc2VsZi5jb250ZXh0bWVudSwgZmFsc2UpO1xuICAgICAgICAgICAgc2VsZi5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29weScsIHNlbGYuY29weSk7XG4gICAgICAgICAgICBzZWxmLmNvbnRyb2xJbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIHNlbGYua2V5cHJlc3MsIGZhbHNlKTtcbiAgICAgICAgICAgIHNlbGYuY29udHJvbElucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgc2VsZi5rZXl1cCwgZmFsc2UpO1xuICAgICAgICAgICAgc2VsZi5jb250cm9sSW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHNlbGYua2V5ZG93biwgZmFsc2UpO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHNlbGYucmVzaXplKTtcbiAgICAgICAgICAgIGlmIChzZWxmLm9ic2VydmVyICYmIHNlbGYub2JzZXJ2ZXIuZGlzY29ubmVjdCkge1xuICAgICAgICAgICAgICAgIHNlbGYub2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzZWxmLnRyeUxvYWRTdG9yZWRPcmRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcztcbiAgICAgICAgICAgIGlmIChzZWxmLnN0b3JlZFNldHRpbmdzICYmIHR5cGVvZiBzZWxmLnN0b3JlZFNldHRpbmdzLm9yZGVycyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5zdG9yZWRTZXR0aW5ncy5vcmRlcnMucm93cy5sZW5ndGggPj0gc2VsZi5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm9yZGVycy5yb3dzID0gc2VsZi5zdG9yZWRTZXR0aW5ncy5vcmRlcnMucm93cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcyA9IHNlbGYuZ2V0U2NoZW1hKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5vcmRlcnMuY29sdW1ucyA9IHNlbGYuc3RvcmVkU2V0dGluZ3Mub3JkZXJzLmNvbHVtbnM7XG4gICAgICAgICAgICAgICAgcy5mb3JFYWNoKGZ1bmN0aW9uIChoLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLm9yZGVycy5jb2x1bW5zLmluZGV4T2YoaSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm9yZGVycy5jb2x1bW5zLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzZWxmLm9yZGVyQnkgPSBzZWxmLnN0b3JlZFNldHRpbmdzLm9yZGVyQnkgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/IHNlbGYudW5pcXVlSWQgOiBzZWxmLnN0b3JlZFNldHRpbmdzLm9yZGVyQnk7XG4gICAgICAgICAgICAgICAgc2VsZi5vcmRlckRpcmVjdGlvbiA9IHNlbGYuc3RvcmVkU2V0dGluZ3Mub3JkZXJEaXJlY3Rpb24gPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/IHNlbGYudW5pcXVlSWQgOiBzZWxmLnN0b3JlZFNldHRpbmdzLm9yZGVyRGlyZWN0aW9uO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmdldEhlYWRlckJ5TmFtZShzZWxmLm9yZGVyQnkpICYmIHNlbGYub3JkZXJEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5vcmRlcihzZWxmLm9yZGVyQnksIHNlbGYub3JkZXJEaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi5zZXRBdHRyaWJ1dGVzKCk7XG4gICAgICAgICAgICBzZWxmLnNldFN0eWxlKCk7XG4gICAgICAgICAgICBzZWxmLmluaXRTY3JvbGxCb3goKTtcbiAgICAgICAgICAgIHNlbGYuc2V0RG9tKCk7XG4gICAgICAgICAgICBzZWxmLmludGYudHlwZSA9ICdjYW52YXMtZGF0YWdyaWQnO1xuICAgICAgICAgICAgc2VsZi5pbnRmLmFkZEV2ZW50TGlzdGVuZXIgPSBzZWxmLmFkZEV2ZW50TGlzdGVuZXI7XG4gICAgICAgICAgICBzZWxmLmludGYucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHNlbGYucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcbiAgICAgICAgICAgIHNlbGYuaW50Zi5kaXNwYXRjaEV2ZW50ID0gc2VsZi5kaXNwYXRjaEV2ZW50O1xuICAgICAgICAgICAgc2VsZi5pbnRmLmRpc3Bvc2UgPSBzZWxmLmRpc3Bvc2U7XG4gICAgICAgICAgICBzZWxmLmludGYuYXBwZW5kVG8gPSBzZWxmLmFwcGVuZFRvO1xuICAgICAgICAgICAgc2VsZi5pbnRmLmZpbHRlcnMgPSBzZWxmLmZpbHRlcnM7XG4gICAgICAgICAgICBzZWxmLmludGYuc29ydGVycyA9IHNlbGYuc29ydGVycztcbiAgICAgICAgICAgIHNlbGYuaW50Zi5hdXRvc2l6ZSA9IHNlbGYuYXV0b3NpemU7XG4gICAgICAgICAgICBzZWxmLmludGYuYmVnaW5FZGl0QXQgPSBzZWxmLmJlZ2luRWRpdEF0O1xuICAgICAgICAgICAgc2VsZi5pbnRmLmVuZEVkaXQgPSBzZWxmLmVuZEVkaXQ7XG4gICAgICAgICAgICBzZWxmLmludGYuc2V0QWN0aXZlQ2VsbCA9IHNlbGYuc2V0QWN0aXZlQ2VsbDtcbiAgICAgICAgICAgIHNlbGYuaW50Zi5zY3JvbGxJbnRvVmlldyA9IHNlbGYuc2Nyb2xsSW50b1ZpZXc7XG4gICAgICAgICAgICBzZWxmLmludGYuY2xlYXJDaGFuZ2VMb2cgPSBzZWxmLmNsZWFyQ2hhbmdlTG9nO1xuICAgICAgICAgICAgc2VsZi5pbnRmLmdvdG9DZWxsID0gc2VsZi5nb3RvQ2VsbDtcbiAgICAgICAgICAgIHNlbGYuaW50Zi5nb3RvUm93ID0gc2VsZi5nb3RvUm93O1xuICAgICAgICAgICAgc2VsZi5pbnRmLmZpbmRDb2x1bW5TY3JvbGxMZWZ0ID0gc2VsZi5maW5kQ29sdW1uU2Nyb2xsTGVmdDtcbiAgICAgICAgICAgIHNlbGYuaW50Zi5maW5kUm93U2Nyb2xsVG9wID0gc2VsZi5maW5kUm93U2Nyb2xsVG9wO1xuICAgICAgICAgICAgc2VsZi5pbnRmLmZpdENvbHVtblRvVmFsdWVzID0gc2VsZi5maXRDb2x1bW5Ub1ZhbHVlcztcbiAgICAgICAgICAgIHNlbGYuaW50Zi5maW5kQ29sdW1uTWF4VGV4dExlbmd0aCA9IHNlbGYuZmluZENvbHVtbk1heFRleHRMZW5ndGg7XG4gICAgICAgICAgICBzZWxmLmludGYuZGlzcG9zZUNvbnRleHRNZW51ID0gc2VsZi5kaXNwb3NlQ29udGV4dE1lbnU7XG4gICAgICAgICAgICBzZWxmLmludGYuZ2V0Q2VsbEF0ID0gc2VsZi5nZXRDZWxsQXQ7XG4gICAgICAgICAgICBzZWxmLmludGYuaXNDZWxsVmlzaWJsZSA9IHNlbGYuaXNDZWxsVmlzaWJsZTtcbiAgICAgICAgICAgIHNlbGYuaW50Zi5vcmRlciA9IHNlbGYub3JkZXI7XG4gICAgICAgICAgICBzZWxmLmludGYuZHJhdyA9IHNlbGYuZHJhdztcbiAgICAgICAgICAgIHNlbGYuaW50Zi5zZWxlY3RBcmVhID0gc2VsZi5zZWxlY3RBcmVhO1xuICAgICAgICAgICAgc2VsZi5pbnRmLmNsaXBFbGVtZW50ID0gc2VsZi5jbGlwRWxlbWVudDtcbiAgICAgICAgICAgIHNlbGYuaW50Zi5nZXRTY2hlbWFGcm9tRGF0YSA9IHNlbGYuZ2V0U2NoZW1hRnJvbURhdGE7XG4gICAgICAgICAgICBzZWxmLmludGYuc2V0RmlsdGVyID0gc2VsZi5zZXRGaWx0ZXI7XG4gICAgICAgICAgICBzZWxmLmludGYuc2VsZWN0Um93ID0gc2VsZi5zZWxlY3RSb3c7XG4gICAgICAgICAgICBzZWxmLmludGYucGFyZW50R3JpZCA9IHNlbGYucGFyZW50R3JpZDtcbiAgICAgICAgICAgIHNlbGYuaW50Zi50b2dnbGVUcmVlID0gc2VsZi50b2dnbGVUcmVlO1xuICAgICAgICAgICAgc2VsZi5pbnRmLmV4cGFuZFRyZWUgPSBzZWxmLmV4cGFuZFRyZWU7XG4gICAgICAgICAgICBzZWxmLmludGYuY29sbGFwc2VUcmVlID0gc2VsZi5jb2xsYXBzZVRyZWU7XG4gICAgICAgICAgICBzZWxmLmludGYuY2FudmFzID0gc2VsZi5jYW52YXM7XG4gICAgICAgICAgICBzZWxmLmludGYuY29udGV4dCA9IHNlbGYuY3R4O1xuICAgICAgICAgICAgc2VsZi5pbnRmLmluc2VydFJvdyA9IHNlbGYuaW5zZXJ0Um93O1xuICAgICAgICAgICAgc2VsZi5pbnRmLmRlbGV0ZVJvdyA9IHNlbGYuZGVsZXRlUm93O1xuICAgICAgICAgICAgc2VsZi5pbnRmLmFkZFJvdyA9IHNlbGYuYWRkUm93O1xuICAgICAgICAgICAgc2VsZi5pbnRmLmluc2VydENvbHVtbiA9IHNlbGYuaW5zZXJ0Q29sdW1uO1xuICAgICAgICAgICAgc2VsZi5pbnRmLmRlbGV0ZUNvbHVtbiA9IHNlbGYuZGVsZXRlQ29sdW1uO1xuICAgICAgICAgICAgc2VsZi5pbnRmLmFkZENvbHVtbiA9IHNlbGYuYWRkQ29sdW1uO1xuICAgICAgICAgICAgc2VsZi5pbnRmLmdldENsaXBwaW5nUmVjdCA9IHNlbGYuZ2V0Q2xpcHBpbmdSZWN0O1xuICAgICAgICAgICAgc2VsZi5pbnRmLnNldFJvd0hlaWdodCA9IHNlbGYuc2V0Um93SGVpZ2h0O1xuICAgICAgICAgICAgc2VsZi5pbnRmLnNldENvbHVtbldpZHRoID0gc2VsZi5zZXRDb2x1bW5XaWR0aDtcbiAgICAgICAgICAgIHNlbGYuaW50Zi5yZXNldENvbHVtbldpZHRocyA9IHNlbGYucmVzZXRDb2x1bW5XaWR0aHM7XG4gICAgICAgICAgICBzZWxmLmludGYucmVzZXRSb3dIZWlnaHRzID0gc2VsZi5yZXNldFJvd0hlaWdodHM7XG4gICAgICAgICAgICBzZWxmLmludGYucmVzaXplID0gc2VsZi5yZXNpemU7XG4gICAgICAgICAgICBzZWxmLmludGYuZHJhd0NoaWxkR3JpZHMgPSBzZWxmLmRyYXdDaGlsZEdyaWRzO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoc2VsZi5zdHlsZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuaW50Zi5zdHlsZSwga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuc3R5bGVba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc3R5bGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5kcmF3KHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHNlbGYuYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuaW50Zi5hdHRyaWJ1dGVzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5hdHRyaWJ1dGVzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5kcmF3KHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGYuZmlsdGVycy5zdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUsIGZpbHRlckZvcikge1xuICAgICAgICAgICAgICAgIGlmICghZmlsdGVyRm9yKSB7IHJldHVybiB0cnVlOyB9XG4gICAgICAgICAgICAgICAgdmFyIGZpbHRlclJlZ0V4cDtcbiAgICAgICAgICAgICAgICBzZWxmLmludmFsaWRGaWx0ZXJSZWdFeCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJSZWdFeHAgPSBuZXcgUmVnRXhwKGZpbHRlckZvciwgJ2lnJyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmludmFsaWRGaWx0ZXJSZWdFeCA9IGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlclJlZ0V4cC50ZXN0KHZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzZWxmLmZpbHRlcnMubnVtYmVyID0gZnVuY3Rpb24gKHZhbHVlLCBmaWx0ZXJGb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZpbHRlckZvcikgeyByZXR1cm4gdHJ1ZTsgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gZmlsdGVyRm9yO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChzZWxmLmF0dHJpYnV0ZXMubmFtZSAmJiBzZWxmLmF0dHJpYnV0ZXMuc2F2ZUFwcGVhcmFuY2UpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnN0b3JlZFNldHRpbmdzID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oc2VsZi5zdG9yYWdlTmFtZSArICctJyArIHNlbGYuYXR0cmlidXRlcy5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5zdG9yZWRTZXR0aW5ncykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zdG9yZWRTZXR0aW5ncyA9IEpTT04ucGFyc2Uoc2VsZi5zdG9yZWRTZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignY291bGQgbm90IHJlYWQgc2V0dGluZ3MgZnJvbSBsb2NhbFN0b3JlJywgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnN0b3JlZFNldHRpbmdzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWxmLnN0b3JlZFNldHRpbmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZi5zdG9yZWRTZXR0aW5ncy5zaXplcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2l6ZXMucm93cyA9IHNlbGYuc3RvcmVkU2V0dGluZ3Muc2l6ZXMucm93cztcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2l6ZXMuY29sdW1ucyA9IHNlbGYuc3RvcmVkU2V0dGluZ3Muc2l6ZXMuY29sdW1ucztcbiAgICAgICAgICAgICAgICAgICAgICAgIFsndHJlZXMnLCAnY29sdW1ucycsICdyb3dzJ10uZm9yRWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2VsZi5zaXplc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNpemVzW2ldID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXJncy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5pbnRmLmRhdGEgPSBhcmdzLmRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXJncy5zY2hlbWEpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmludGYuc2NoZW1hID0gYXJncy5zY2hlbWE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNlbGYuZGF0YSkge1xuICAgICAgICAgICAgICAgIHNlbGYuaW50Zi5kYXRhID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLnJlc2l6ZSh0cnVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgbW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAgICAgICAgIG1vZHVsZShzZWxmKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNlbGYuaW5pdCgpO1xuICAgICAgICByZXR1cm4gc2VsZi5pbnRmO1xuICAgIH1cbiAgICBpZiAod2luZG93ICYmICF3aW5kb3cuY2FudmFzRGF0YWdyaWQpIHtcbiAgICAgICAgd2luZG93LmNhbnZhc0RhdGFncmlkID0gZ3JpZDtcbiAgICB9XG4gICAgcmV0dXJuIGdyaWQ7XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL21haW4uanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/*!*********************!*\
  !*** ./lib/draw.js ***!
  \*********************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jslint browser: true, unparam: true, todo: true*/\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n    'use strict';\n    return function (self) {\n        function drawOrderByArrow(x, y) {\n            x += self.canvasOffsetLeft;\n            y += self.canvasOffsetTop;\n            self.ctx.fillStyle = self.style.headerOrderByArrowColor;\n            self.ctx.strokeStyle = self.style.headerOrderByArrowBorderColor;\n            self.ctx.beginPath();\n            x = x + self.style.headerOrderByArrowMarginLeft;\n            y = y + self.style.headerOrderByArrowMarginTop;\n            if (self.orderDirection === 'asc') {\n                self.ctx.moveTo(x, y);\n                self.ctx.lineTo(x + self.style.headerOrderByArrowWidth, y);\n                self.ctx.lineTo(x + (self.style.headerOrderByArrowWidth * 0.5), y + self.style.headerOrderByArrowHeight);\n                self.ctx.moveTo(x, y);\n            } else {\n                self.ctx.lineTo(x, y + self.style.headerOrderByArrowHeight);\n                self.ctx.lineTo(x + self.style.headerOrderByArrowWidth, y + self.style.headerOrderByArrowHeight);\n                self.ctx.lineTo(x + (self.style.headerOrderByArrowWidth * 0.5), y);\n                self.ctx.lineTo(x, y + self.style.headerOrderByArrowHeight);\n            }\n            self.ctx.stroke();\n            self.ctx.fill();\n            return self.style.headerOrderByArrowMarginLeft\n                + self.style.headerOrderByArrowWidth\n                + self.style.headerOrderByArrowMarginRight;\n        }\n        function drawTreeArrow(cell, x, y) {\n            x += self.canvasOffsetLeft;\n            y += self.canvasOffsetTop;\n            self.ctx.fillStyle = self.style.treeArrowColor;\n            self.ctx.strokeStyle = self.style.treeArrowBorderColor;\n            self.ctx.beginPath();\n            x = x + self.style.treeArrowMarginLeft;\n            y = y + self.style.treeArrowMarginTop;\n            if (self.openChildren[cell.data[self.uniqueId]]) {\n                self.ctx.moveTo(x, y);\n                self.ctx.lineTo(x + self.style.treeArrowWidth, y);\n                self.ctx.lineTo(x + (self.style.treeArrowWidth * 0.5), y + self.style.treeArrowHeight);\n                self.ctx.moveTo(x, y);\n            } else {\n                self.ctx.lineTo(x, y);\n                self.ctx.lineTo(x + self.style.treeArrowHeight, y + (self.style.treeArrowWidth * 0.5));\n                self.ctx.lineTo(x, y + self.style.treeArrowWidth);\n                self.ctx.lineTo(x, y);\n            }\n            self.ctx.stroke();\n            self.ctx.fill();\n            return self.style.treeArrowMarginLeft\n                + self.style.treeArrowWidth\n                + self.style.treeArrowMarginRight;\n        }\n        function radiusRect(x, y, w, h, radius) {\n            x += self.canvasOffsetLeft;\n            y += self.canvasOffsetTop;\n            var r = x + w, b = y + h;\n            self.ctx.beginPath();\n            self.ctx.moveTo(x + radius, y);\n            self.ctx.lineTo(r - radius, y);\n            self.ctx.quadraticCurveTo(r, y, r, y + radius);\n            self.ctx.lineTo(r, y + h - radius);\n            self.ctx.quadraticCurveTo(r, b, r - radius, b);\n            self.ctx.lineTo(x + radius, b);\n            self.ctx.quadraticCurveTo(x, b, x, b - radius);\n            self.ctx.lineTo(x, y + radius);\n            self.ctx.quadraticCurveTo(x, y, x + radius, y);\n        }\n        function fillRect(x, y, w, h) {\n            x += self.canvasOffsetLeft;\n            y += self.canvasOffsetTop;\n            self.ctx.fillRect(x, y, w, h);\n        }\n        function strokeRect(x, y, w, h) {\n            x += self.canvasOffsetLeft;\n            y += self.canvasOffsetTop;\n            self.ctx.strokeRect(x, y, w, h);\n        }\n        function fillText(text, x, y) {\n            x += self.canvasOffsetLeft;\n            y += self.canvasOffsetTop;\n            self.ctx.fillText(text, x, y);\n        }\n        function addBorderLine(c, pos) {\n            self.ctx.beginPath();\n            var p = {\n                t: function () {\n                    self.ctx.moveTo(c.x + self.canvasOffsetLeft, c.y + self.canvasOffsetTop);\n                    self.ctx.lineTo(c.x + self.canvasOffsetLeft + c.width, c.y + self.canvasOffsetTop);\n                },\n                r: function () {\n                    self.ctx.moveTo(c.x + self.canvasOffsetLeft + c.width, c.y + self.canvasOffsetTop);\n                    self.ctx.lineTo(c.x + self.canvasOffsetLeft + c.width, c.y + self.canvasOffsetTop + c.height);\n                },\n                b: function () {\n                    self.ctx.moveTo(c.x + self.canvasOffsetLeft, c.y + self.canvasOffsetTop + c.height);\n                    self.ctx.lineTo(c.x + self.canvasOffsetLeft + c.width, c.y + self.canvasOffsetTop + c.height);\n                },\n                l: function () {\n                    self.ctx.moveTo(c.x + self.canvasOffsetLeft, c.y + self.canvasOffsetTop);\n                    self.ctx.lineTo(c.x + self.canvasOffsetLeft, c.y + self.canvasOffsetTop + c.height);\n                },\n            };\n            p[pos]();\n            self.ctx.stroke();\n        }\n        /**\n         * Redraws the grid. No matter what the change, this is the only method required to refresh everything.\n         * @memberof canvasDataGrid#\n         * @method\n         */\n        self.draw = function (internal) {\n            if (!self.isChildGrid && (!self.height || !self.width)) {\n                return;\n            }\n            if (self.isChildGrid && internal) {\n                requestAnimationFrame(self.parentGrid.draw);\n                return;\n            }\n            if (self.intf.visible === false) {\n                return;\n            }\n            // initial values\n            var checkScrollHeight, borderWidth, rowHeaderCell, p, cx, cy, treeGrid, rowOpen,\n                rowHeight, cornerCell, y, x, c, h, w, s, r, rd, aCell,\n                l = self.data.length,\n                u = self.currentCell || {},\n                headerCellHeight = self.getHeaderCellHeight(),\n                headerCellWidth = self.getHeaderCellWidth(),\n                cellHeight = self.style.cellHeight;\n            // if data length has changed, there is no way to know\n            if (self.data.length > self.orders.rows.length) {\n                self.createRowOrders();\n            }\n            function drawScrollBars() {\n                var v = {\n                        x: 0,\n                        y: 0,\n                        height: 0,\n                        width: 0,\n                        style: 'vertical-scroll-bar'\n                    },\n                    n = {\n                        x: 0,\n                        y: 0,\n                        height: 0,\n                        width: 0,\n                        style: 'horizontal-scroll-bar'\n                    },\n                    vb = {\n                        x: 0,\n                        y: 0,\n                        height: 0,\n                        width: 0,\n                        style: 'vertical-scroll-box'\n                    },\n                    nb = {\n                        x: 0,\n                        y: 0,\n                        height: 0,\n                        width: 0,\n                        style: 'horizontal-scroll-box'\n                    },\n                    co = {\n                        x: 0,\n                        y: 0,\n                        height: 0,\n                        width: 0,\n                        style: 'scroll-box-corner'\n                    },\n                    m = (self.style.scrollBarBoxMargin * 2),\n                    d = self.style.scrollBarBoxMargin * 0.5;\n                self.ctx.strokeStyle = self.style.scrollBarBorderColor;\n                self.ctx.lineWidth = self.style.scrollBarBorderWidth;\n                // vertical\n                v.x += w - self.style.scrollBarWidth - self.style.scrollBarBorderWidth - d;\n                v.y += headerCellHeight;\n                v.width = self.style.scrollBarWidth + self.style.scrollBarBorderWidth + d;\n                v.height = h - headerCellHeight - self.style.scrollBarWidth - d - m;\n                self.ctx.fillStyle = self.style.scrollBarBackgroundColor;\n                fillRect(v.x, v.y, v.width, v.height + m);\n                strokeRect(v.x, v.y, v.width, v.height + m);\n                // vertical box\n                vb.x = v.x + self.style.scrollBarBoxMargin;\n                vb.y = headerCellHeight + self.style.scrollBarBoxMargin\n                    + ((v.height - self.scrollBox.scrollBoxHeight)\n                        * (self.scrollBox.scrollTop / self.scrollBox.scrollHeight));\n                vb.width = self.style.scrollBarBoxWidth;\n                vb.height = self.scrollBox.scrollBoxHeight;\n                self.ctx.fillStyle = self.style.scrollBarBoxColor;\n                if (/vertical/.test(u.context)) {\n                    self.ctx.fillStyle = self.style.scrollBarActiveColor;\n                }\n                if (vb.width < v.width) {\n                    radiusRect(vb.x, vb.y, vb.width, vb.height, self.style.scrollBarBoxBorderRadius);\n                    self.ctx.stroke();\n                    self.ctx.fill();\n                }\n                // horizontal\n                n.x += headerCellWidth;\n                n.y += h - self.style.scrollBarWidth - d;\n                n.width = w - self.style.scrollBarWidth - headerCellWidth - d - m;\n                n.height = self.style.scrollBarWidth + self.style.scrollBarBorderWidth + d;\n                self.ctx.fillStyle = self.style.scrollBarBackgroundColor;\n                fillRect(n.x, n.y, n.width + m, n.height);\n                strokeRect(n.x, n.y, n.width + m, n.height);\n                // horizontal box\n                nb.y = n.y + self.style.scrollBarBoxMargin;\n                nb.x = headerCellWidth + self.style.scrollBarBoxMargin\n                    + ((n.width - self.scrollBox.scrollBoxWidth)\n                        * (self.scrollBox.scrollLeft / self.scrollBox.scrollWidth));\n                nb.width = self.scrollBox.scrollBoxWidth;\n                nb.height = self.style.scrollBarBoxWidth;\n                self.ctx.fillStyle = self.style.scrollBarBoxColor;\n                if (/horizontal/.test(u.context)) {\n                    self.ctx.fillStyle = self.style.scrollBarActiveColor;\n                }\n                if (nb.width < n.width) {\n                    radiusRect(nb.x, nb.y, nb.width, nb.height, self.style.scrollBarBoxBorderRadius);\n                    self.ctx.stroke();\n                    self.ctx.fill();\n                }\n                //corner\n                self.ctx.strokeStyle = self.style.scrollBarCornerBorderColor;\n                self.ctx.fillStyle = self.style.scrollBarCornerBackground;\n                co.x = n.x + n.width + m;\n                co.y = v.y + v.height + m;\n                co.width = self.style.scrollBarWidth + self.style.scrollBarBorderWidth;\n                co.height = self.style.scrollBarWidth + self.style.scrollBarBorderWidth;\n                radiusRect(co.x, co.y, co.width, co.height, 0);\n                self.ctx.stroke();\n                self.ctx.fill();\n                self.visibleCells.unshift(v);\n                self.visibleCells.unshift(vb);\n                self.visibleCells.unshift(n);\n                self.visibleCells.unshift(nb);\n                self.visibleCells.unshift(co);\n                self.scrollBox.bar = {\n                    v: v,\n                    h: n\n                };\n                self.scrollBox.box = {\n                    v: vb,\n                    h: nb\n                };\n            }\n            function drawCell(d, rowIndex, rowOrderIndex) {\n                return function drawEach(header, headerIndex, columnOrderIndex) {\n                    var cellStyle = header.style || 'cell',\n                        childGridAttributes,\n                        cell,\n                        selected = self.selections[rowOrderIndex] && self.selections[rowOrderIndex].indexOf(columnOrderIndex) !== -1,\n                        hovered = self.hovers[d[self.uniqueId]] && self.hovers[d[self.uniqueId]].indexOf(columnOrderIndex) !== -1,\n                        active = self.activeCell.rowIndex === rowOrderIndex && self.activeCell.columnIndex === columnOrderIndex,\n                        isGrid = Array.isArray(d[header.name]),\n                        activeHeader = (self.orders.rows[self.activeCell.rowIndex] === rowOrderIndex\n                                || self.orders.columns[self.activeCell.columnIndex] === columnOrderIndex)\n                            && (columnOrderIndex === -1 || rowOrderIndex === -1),\n                        val,\n                        f = self.formatters[header.type || 'string'],\n                        orderByArrowSize = 0,\n                        treeArrowSize = 0,\n                        cellWidth = self.sizes.columns[cellStyle  === 'rowHeaderCell'\n                            ? 'cornerCell' : header[self.uniqueId]] || header.width;\n                    if (cellStyle === 'headerCellCap') {\n                        cellWidth = w - x;\n                    }\n                    // if no data or schema are defined, a width is provided to the stub column\n                    if (cellWidth === undefined) {\n                        cellWidth = self.style.columnWidth;\n                    }\n                    if (x + cellWidth + borderWidth < 0) {\n                        x += cellWidth + borderWidth;\n                    }\n                    if (active) {\n                        cellStyle = 'activeCell';\n                    }\n                    if (self.visibleRows.indexOf(rowIndex) === -1\n                            && ['headerCell', 'cornerCell'].indexOf(cellStyle) === -1) {\n                        self.visibleRows.push(rowIndex);\n                    }\n                    val = self.dispatchEvent('formatcellvalue', [self.ctx, d[header.name], d, header, cx, cy], self.intf);\n                    if (!self.dispatchEvent('beforerendercell', [{}, self.ctx, d[header.name], d, header, cx, cy], self.intf)) {\n                        cx = x;\n                        cy = y;\n                        if (cellStyle === 'cornerCell') {\n                            cx = 0;\n                            cy = 0;\n                        } else if (cellStyle === 'rowHeaderCell') {\n                            cx = 0;\n                        } else if (cellStyle === 'headerCell') {\n                            cy = 0;\n                        }\n                        cell = {\n                            type: isGrid ? 'canvas-datagrid-cell' : header.type,\n                            style: cellStyle,\n                            nodeType: 'canvas-datagrid-cell',\n                            x: cx,\n                            y: cy,\n                            offsetTop: self.canvasOffsetTop,\n                            offsetLeft: self.canvasOffsetLeft,\n                            scrollTop: self.scrollBox.scrollTop,\n                            scrollLeft: self.scrollBox.scrollLeft,\n                            active: active === true,\n                            hovered: hovered === true,\n                            selected: selected === true,\n                            width: cellWidth,\n                            height: cellHeight,\n                            offsetWidth: cellWidth,\n                            offsetHeight: cellHeight,\n                            parentNode: self.intf.parentNode,\n                            offsetParent: self.intf.parentNode,\n                            data: d,\n                            isHeader: /headerCell|cornerCell/.test(cellStyle),\n                            isRowHeader: 'rowHeaderCell' === cellStyle,\n                            rowOpen: rowOpen,\n                            header: header,\n                            columnIndex: columnOrderIndex,\n                            rowIndex: rowOrderIndex,\n                            sortColumnIndex: headerIndex,\n                            sortRowIndex: rowIndex,\n                            isGrid: isGrid,\n                            gridId: (self.attributes.name || '') + d[self.uniqueId] + ':' + header[self.uniqueId],\n                            parentGrid: self.intf,\n                            value: cellStyle === 'headerCell'\n                                ? (header.title || header.name) : d[header.name]\n                        };\n                        cell.userHeight = cell.isHeader ? self.sizes.rows[-1] : rowHeight;\n                        cell.userWidth = cell.isHeader ? self.sizes.columns.cornerCell : self.sizes.columns[header[self.uniqueId]];\n                        cell[self.uniqueId] = d[self.uniqueId];\n                        self.visibleCells.unshift(cell);\n                        self.ctx.fillStyle = self.style[cellStyle + 'BackgroundColor'];\n                        self.ctx.strokeStyle = self.style[cellStyle + 'BorderColor'];\n                        self.ctx.lineWidth = self.style[cellStyle + 'BorderWidth'];\n                        if (hovered) {\n                            self.ctx.fillStyle = self.style[cellStyle + 'HoverBackgroundColor'];\n                            self.ctx.strokeStyle = self.style[cellStyle + 'HoverBorderColor'];\n                        }\n                        if (selected) {\n                            self.ctx.fillStyle = self.style[cellStyle + 'SelectedBackgroundColor'];\n                            self.ctx.strokeStyle = self.style[cellStyle + 'SelectedBorderColor'];\n                        }\n                        if (activeHeader) {\n                            self.ctx.fillStyle = self.style[cellStyle + 'ActiveBackgroundColor'];\n                        }\n                        self.dispatchEvent('rendercell', [self.ctx, cell], self.intf);\n                        if (cell.isGrid) {\n                            if (cell.height !== rowHeight) {\n                                cell.height = rowHeight || self.style.cellHeightWithChildGrid;\n                                checkScrollHeight = true;\n                            }\n                            cell.width = self.sizes.columns[header[self.uniqueId]] || self.style.cellWidthWithChildGrid;\n                        }\n                        if (rowOpen && !cell.isRowHeader) {\n                            cell.height = self.sizes.rows[rd[self.uniqueId]] || self.style.cellHeight;\n                        }\n                        if (!cell.isGrid) {\n                            fillRect(cx, cy, cell.width, cell.height);\n                            strokeRect(cx, cy, cell.width, cell.height);\n                        }\n                        self.ctx.save();\n                        radiusRect(cell.x, cell.y, cell.width, cell.height, 0);\n                        self.ctx.clip();\n                        self.dispatchEvent('afterrendercell', [self.ctx, cell], self.intf);\n                        if (cell.height !== cellHeight && !(rowOpen && !cell.isRowHeader)) {\n                            self.sizes.rows[cellStyle === 'headerCell' ? -1 : d[self.uniqueId]] = cell.height;\n                            checkScrollHeight = true;\n                        }\n                        if (cell.width !== cellWidth) {\n                            self.sizes.columns[header[self.uniqueId]] = cell.width;\n                            checkScrollHeight = true;\n                        }\n                        if (cellStyle === 'rowHeaderCell' && self.attributes.tree) {\n                            if (!self.dispatchEvent('rendertreearrow', [{}, self.ctx, cell], self.intf)) {\n                                treeArrowSize = drawTreeArrow(cell, self.style[cellStyle + 'PaddingLeft'], cy, 0);\n                            }\n                        }\n                        if ((self.attributes.showRowNumbers && cellStyle === 'rowHeaderCell')\n                                || cellStyle !== 'rowHeaderCell') {\n                            if (cell.isGrid) {\n                                if (!self.childGrids[cell.gridId]) {\n                                    childGridAttributes = self.args.childGridAttributes || self.args;\n                                    childGridAttributes.name = self.attributes.saveAppearance ? cell.gridId : undefined;\n                                    childGridAttributes.parentNode = cell;\n                                    childGridAttributes.data = d[header.name];\n                                    self.childGrids[cell.gridId] = self.createGrid(childGridAttributes);\n                                    self.dispatchEvent('rendercellgrid', [self.ctx, cell, self.childGrids[cell.gridId]], self.intf);\n                                    checkScrollHeight = true;\n                                }\n                                cell.grid = self.childGrids[cell.gridId];\n                                cell.grid.parentNode = cell;\n                                cell.grid.visible = true;\n                                cell.grid.draw();\n                            } else {\n                                if (self.childGrids[cell.gridId]) {\n                                    self.childGrids[cell.gridId].parentNode.offsetHeight = 0;\n                                }\n                                self.ctx.font = self.style[cellStyle + 'Font'];\n                                val = val !== undefined ? val : f\n                                    ? f(self.ctx, cell) : '';\n                                if (val === undefined && !f) {\n                                    val = '';\n                                    console.warn('canvas-datagrid: I don\\'t know how to format a '\n                                        + header.type + ' add a cellFormater');\n                                }\n                                if (cellStyle === 'headerCell' && self.orderBy === header.name) {\n                                    if (!self.dispatchEvent('renderorderbyarrow', [{}, self.ctx, cell], self.intf)) {\n                                        orderByArrowSize = drawOrderByArrow(cx + self.style[cellStyle + 'PaddingLeft'], 0);\n                                    }\n                                }\n                                self.ctx.fillStyle = self.style[cellStyle + 'Color'];\n                                if (hovered) {\n                                    self.ctx.fillStyle = self.style[cellStyle + 'HoverColor'];\n                                }\n                                if (selected) {\n                                    self.ctx.fillStyle = self.style[cellStyle + 'SelectedColor'];\n                                }\n                                if (activeHeader) {\n                                    self.ctx.fillStyle = self.style[cellStyle + 'ActiveColor'];\n                                }\n                                if (self.columnFilters && self.columnFilters[val] !== undefined && cellStyle === 'headerCell') {\n                                    val = self.style.filterTextPrefix + val;\n                                }\n                                cell.formattedValue = ((val !== undefined && val !== null) ? val : '').toString();\n                                self.dispatchEvent('rendertext', [self.ctx, cell], self.intf);\n                                fillText(self.addEllipsis(cell.formattedValue, cell.width\n                                    - self.style[cellStyle + 'PaddingRight'] - orderByArrowSize - self.style.autosizePadding),\n                                    treeArrowSize + orderByArrowSize + cx + self.style[cellStyle + 'PaddingLeft'],\n                                    cy - (cell.height * 0.5) + self.style[cellStyle + 'PaddingTop'] + cell.height);\n                            }\n                        }\n                        if (active && !self.attributes.rowSelectionMode) {\n                            aCell = cell;\n                            self.ctx.lineWidth = self.style.activeCellOverlayBorderWidth;\n                            self.ctx.strokeStyle = self.style.activeCellOverlayBorderColor;\n                            strokeRect(aCell.x, aCell.y, aCell.width, aCell.height);\n                        }\n                        if (selected) {\n                            self.ctx.lineWidth = self.style.selectionOverlayBorderWidth;\n                            self.ctx.strokeStyle = self.style.selectionOverlayBorderColor;\n                            if (cell.selected && cell.style !== 'rowHeaderCell') {\n                                if ((!self.selections[cell.rowIndex - 1]\n                                        || self.selections[cell.rowIndex - 1].indexOf(cell.columnIndex) === -1\n                                        || cell.rowIndex === 0)\n                                        && !cell.isHeader) {\n                                    addBorderLine(cell, 't');\n                                }\n                                if (!self.selections[cell.rowIndex] || cell.columnIndex === s.length - 1\n                                        || self.selections[cell.rowIndex].indexOf(cell.columnIndex + 1) === -1) {\n                                    addBorderLine(cell, 'r');\n                                }\n                                if (!self.selections[cell.rowIndex + 1]\n                                        || self.selections[cell.rowIndex + 1].indexOf(cell.columnIndex) === -1) {\n                                    addBorderLine(cell, 'b');\n                                }\n                                if (!self.selections[cell.rowIndex] || cell.columnIndex === 0\n                                        || self.selections[cell.rowIndex].indexOf(cell.columnIndex - 1) === -1) {\n                                    addBorderLine(cell, 'l');\n                                }\n                            }\n                        }\n                        self.ctx.restore();\n                        x += cell.width + borderWidth;\n                        return cell.width;\n                    }\n                };\n            }\n            function drawHeaderRow() {\n                var d, g = s.length, i, o, headerCell, header;\n                if (self.attributes.showHeaders) {\n                    x = (self.scrollBox.scrollLeft * -1) + self.scrollPixelLeft;\n                    if (self.attributes.showRowHeaders) {\n                        x += headerCellWidth;\n                    }\n                    y = 0;\n                    // cell height might have changed during drawing\n                    cellHeight = self.getHeaderCellHeight();\n                    for (o = self.scrollIndexLeft; o < g; o += 1) {\n                        i = self.orders.columns[o];\n                        header = s[i];\n                        d = {\n                            title: header.title,\n                            name: header.name,\n                            width: header.width,\n                            style: 'headerCell',\n                            type: 'string',\n                            index: o,\n                            order: i\n                        };\n                        headerCell = {'headerCell': header.title || header.name};\n                        headerCell[self.uniqueId] = 'h' + header[self.uniqueId];\n                        d[self.uniqueId] = header[self.uniqueId];\n                        x += drawCell(headerCell, -1, -1)(d, o, i);\n                        if (x > self.width + self.scrollBox.scrollLeft) {\n                            break;\n                        }\n                    }\n                    // fill in the space right of the headers\n                    if (x < w) {\n                        c = {\n                            name: '',\n                            width: self.style.scrollBarWidth,\n                            style: 'headerCellCap',\n                            type: 'string',\n                            index: s.length\n                        };\n                        c[self.uniqueId] = 'headerCell';\n                        drawCell({endCap: ''}, -1, -1)(c, -1, -1);\n                    }\n                    // fill in the space left of the headers\n                    if (self.attributes.showRowHeaders) {\n                        cornerCell = {'cornerCell': '' };\n                        cornerCell[self.uniqueId] = 'cornerCell';\n                        x = 0;\n                        c = {\n                            name: 'cornerCell',\n                            width: self.style.headerRowWidth,\n                            style: 'cornerCell',\n                            type: 'string',\n                            index: -1\n                        };\n                        c[self.uniqueId] = 'cornerCell';\n                        drawCell(cornerCell, -1, -1)(c, -1, -1);\n                    }\n                }\n            }\n            function drawRowHeader(rowData, index, rowOrderIndex) {\n                var a;\n                if (self.attributes.showRowHeaders) {\n                    x = 0;\n                    rowHeaderCell = {'rowHeaderCell': index + 1 };\n                    rowHeaderCell[self.uniqueId] = rowData[self.uniqueId];\n                    a = {\n                        name: 'rowHeaderCell',\n                        width: self.style.headerRowWidth,\n                        style: 'rowHeaderCell',\n                        type: 'string',\n                        data: rowData[self.uniqueId],\n                        index: -1\n                    };\n                    a[self.uniqueId] = rowData[self.uniqueId];\n                    drawCell(rowHeaderCell, index, rowOrderIndex)(a, -1, -1);\n                }\n            }\n            function drawRow(r, d) {\n                var i, treeHeight, rowSansTreeHeight, o, g = s.length;\n                if (y - (cellHeight * 2) > h) {\n                    return false;\n                }\n                rd = self.data[r];\n                rowOpen = self.openChildren[rd[self.uniqueId]];\n                rowSansTreeHeight = self.sizes.rows[rd[self.uniqueId]] || self.style.cellHeight;\n                treeHeight = (rowOpen ? self.sizes.trees[rd[self.uniqueId]] : 0);\n                rowHeight = rowSansTreeHeight + treeHeight;\n                if (y < rowHeight * -1) {\n                    return false;\n                }\n                if (self.attributes.showRowHeaders) {\n                    x += headerCellWidth;\n                }\n                cellHeight = rowHeight;\n                for (o = self.scrollIndexLeft; o < g; o += 1) {\n                    i = self.orders.columns[o];\n                    x += drawCell(rd, r, d)(s[i], i, o);\n                    if (x > self.width) {\n                        break;\n                    }\n                }\n                drawRowHeader(rd, r, d);\n                // cell height might have changed during drawing\n                cellHeight = rowHeight;\n                x = (self.scrollBox.scrollLeft * -1) + self.scrollPixelLeft;\n                // don't draw a tree for the new row\n                treeGrid = self.childGrids[rd[self.uniqueId]];\n                if (r !== self.data.length && rowOpen) {\n                    treeGrid.visible = true;\n                    treeGrid.parentNode = {\n                        offsetTop: y + rowSansTreeHeight + self.canvasOffsetTop,\n                        offsetLeft: x + headerCellWidth - 1 + self.canvasOffsetLeft,\n                        offsetHeight: treeHeight,\n                        offsetWidth: self.width - headerCellWidth - self.style.scrollBarWidth - 1,\n                        offsetParent: self.intf.parentNode,\n                        parentNode: self.intf.parentNode,\n                        style: self.style,\n                        nodeType: 'canvas-datagrid-tree',\n                        scrollTop: self.scrollBox.scrollTop,\n                        scrollLeft: self.scrollBox.scrollLeft,\n                        rowIndex: r\n                    };\n                    self.visibleCells.unshift({\n                        rowIndex: x,\n                        columnIndex: 0,\n                        y: treeGrid.parentNode.offsetTop,\n                        x: treeGrid.parentNode.offsetLeft,\n                        height: treeGrid.parentNode.offsetHeight,\n                        width: treeGrid.parentNode.offsetWidth,\n                        style: 'tree-grid',\n                        type: treeGrid.parentNode.nodeType\n                    });\n                    treeGrid.draw();\n                } else if (treeGrid) {\n                    treeGrid.parentNode.offsetHeight = 0;\n                    delete self.sizes.trees[rd[self.uniqueId]];\n                }\n                if (self.attributes.rowSelectionMode\n                        && self.activeCell\n                        && self.activeCell.rowIndex === r) {\n                    self.ctx.lineWidth = self.style.activeCellOverlayBorderWidth;\n                    self.ctx.strokeStyle = self.style.activeCellOverlayBorderColor;\n                    strokeRect(0, y, self.getHeaderWidth(), rowHeight);\n                }\n                y += cellHeight + borderWidth;\n                return true;\n            }\n            function initDraw() {\n                if (self.attributes.showPerformance) {\n                    p = performance.now();\n                }\n                borderWidth = self.style.cellBorderWidth * 2;\n                self.visibleRows = [];\n                s = self.getVisibleSchema();\n                self.visibleCells = [];\n                self.canvasOffsetTop = self.isChildGrid ? self.parentNode.offsetTop : 0;\n                self.canvasOffsetLeft = self.isChildGrid ? self.parentNode.offsetLeft : 0;\n                h = self.height;\n                w = self.width;\n                if (!self.isChildGrid) {\n                    self.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);\n                }\n            }\n            function drawBackground() {\n                radiusRect(0, 0, w, h, 0);\n                self.ctx.clip();\n                self.ctx.fillStyle = self.style.backgroundColor;\n                fillRect(0, 0, w, h);\n            }\n            function drawRows() {\n                var o, n, i, g = s.length;\n                x = (self.scrollBox.scrollLeft * -1) + self.scrollPixelLeft;\n                y = (self.scrollBox.scrollTop * -1) + headerCellHeight + self.scrollPixelTop;\n                for (r = self.scrollIndexTop; r < l; r += 1) {\n                    n = self.orders.rows[r];\n                    if (!drawRow(n, r)) {\n                        break;\n                    }\n                }\n                if (self.attributes.showNewRow) {\n                    if (self.attributes.showRowHeaders) {\n                        x += headerCellWidth;\n                    }\n                    rowHeight = cellHeight = self.style.cellHeight;\n                    rowOpen = false;\n                    for (o = self.scrollIndexLeft; o < g; o += 1) {\n                        i = self.orders.columns[o];\n                        x += drawCell(self.newRow, self.data.length, self.data.length)(s[i], i, o);\n                        if (x > self.width + self.scrollBox.scrollLeft) {\n                            break;\n                        }\n                    }\n                    drawRowHeader(self.newRow, self.data.length, self.data.length);\n                }\n            }\n            function drawReorderMarkers() {\n                if (!self.reorderObject) { return; }\n                var b = {\n                        height: self.reorderObject.height,\n                        width: self.reorderObject.width,\n                        x: self.reorderObject.x + self.reorderObject.dragOffset.x,\n                        y: self.reorderObject.y + self.reorderObject.dragOffset.y\n                    },\n                    m = {\n                        width: w,\n                        heigth: h,\n                        x: 0,\n                        y: 0\n                    };\n                self.ctx.fillStyle = self.style.reorderMarkerBackgroundColor;\n                self.ctx.lineWidth = self.style.reorderMarkerBorderWidth;\n                self.ctx.strokeStyle = self.style.reorderMarkerBorderColor;\n                if (self.dragMode === 'row-reorder') {\n                    b.width = w;\n                    b.x = 0;\n                    m.width = w;\n                    m.y = self.currentCell.y;\n                    fillRect(b.x, b.y, b.width, b.height);\n                    strokeRect(b.x, b.y, b.width, b.height);\n                    self.ctx.lineWidth = self.style.reorderMarkerIndexBorderWidth;\n                    self.ctx.strokeStyle = self.style.reorderMarkerIndexBorderColor;\n                    if (self.currentCell.rowIndex !== self.reorderObject.rowIndex\n                            && self.currentCell.rowIndex - 1 !== self.reorderObject.rowIndex) {\n                        addBorderLine(m, 't');\n                    }\n                } else if (self.dragMode === 'column-reorder' && self.reorderObject) {\n                    b.height = h;\n                    b.y = 0;\n                    m.height = h;\n                    m.x = self.currentCell.x;\n                    fillRect(b.x, b.y, b.width, b.height);\n                    strokeRect(b.x, b.y, b.width, b.height);\n                    self.ctx.lineWidth = self.style.reorderMarkerIndexBorderWidth;\n                    self.ctx.strokeStyle = self.style.reorderMarkerIndexBorderColor;\n                    if (self.currentCell.columnIndex !== self.reorderObject.columnIndex\n                            && self.currentCell.columnIndex - 1 !== self.reorderObject.columnIndex) {\n                        addBorderLine(m, 'l');\n                    }\n                }\n            }\n            function drawBorder() {\n                self.ctx.lineWidth = self.style.gridBorderWidth;\n                self.ctx.strokeStyle = self.style.gridBorderColor;\n                strokeRect(0, 0, self.width, self.height);\n            }\n            function drawDebug() {\n                if (self.attributes.showPerformance) {\n                    self.ctx.fillStyle = 'black';\n                    p = (performance.now() - p).toFixed(2) + 'ms';\n                    self.ctx.font = '23px sans-serif';\n                    fillText(p, w - (w / 5), h - (h / 10));\n                }\n                if (self.attributes.debug) {\n                    self.ctx.font = '14px sans-serif';\n                    p = ('scrollLeft: %s, scrollTop: %s, topIndex: %s, topPixel: %s, leftIndex: %s, leftPixel: %s,'\n                        + '\\noffsetLeft: %s, offsetTop: %s, w: %s, h: %s, x: %s, y: %s,\\nvisible entities: %s, focus: %s, dragMode: %s'\n                        + '\\ncontext: %s')\n                        .replace('%s', self.scrollBox.scrollLeft)\n                        .replace('%s', self.scrollBox.scrollTop)\n                        .replace('%s', self.scrollIndexTop)\n                        .replace('%s', self.scrollPixelTop)\n                        .replace('%s', self.scrollIndexLeft)\n                        .replace('%s', self.scrollPixelLeft)\n                        .replace('%s', self.canvasOffsetLeft)\n                        .replace('%s', self.canvasOffsetTop)\n                        .replace('%s', self.width)\n                        .replace('%s', self.height)\n                        .replace('%s', self.mouse.x)\n                        .replace('%s', self.mouse.y)\n                        .replace('%s', self.visibleCells.length)\n                        .replace('%s', self.hasFocus)\n                        .replace('%s', self.dragMode)\n                        .replace('%s', self.currentCell\n                            ? (('(x: %s, y: %s, ox: %s, oy: %s, context: %s, dragContext: %s, style: %s, type: %s)')\n                                .replace('%s', self.currentCell.columnIndex)\n                                .replace('%s', self.currentCell.rowIndex)\n                                .replace('%s', self.currentCell.sortColumnIndex)\n                                .replace('%s', self.currentCell.sortRowIndex)\n                                .replace('%s', self.currentCell.context)\n                                .replace('%s', self.currentCell.dragContext)\n                                .replace('%s', self.currentCell.style)\n                                .replace('%s', self.currentCell.type)) : '');\n                    p.split('\\n').forEach(function (s, index) {\n                        self.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n                        fillRect(70, 39 + (index * 15), self.ctx.measureText(s).width + 20, 15);\n                        self.ctx.fillStyle = 'rgba(0, 0, 0, 1)';\n                        fillText(s, 80, 52 + (index * 15));\n                    });\n                }\n            }\n            self.ctx.save();\n            initDraw();\n            drawBackground();\n            drawRows();\n            drawHeaderRow();\n            drawReorderMarkers();\n            drawScrollBars();\n            if (checkScrollHeight) {\n                self.resize(true);\n            }\n            drawBorder();\n            drawDebug();\n            self.ctx.restore();\n        };\n    };\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi9kcmF3LmpzPzBhNmEiXSwic291cmNlc0NvbnRlbnQiOlsiLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgdW5wYXJhbTogdHJ1ZSwgdG9kbzogdHJ1ZSovXG4vKmdsb2JhbHMgZGVmaW5lOiB0cnVlLCBNdXRhdGlvbk9ic2VydmVyOiBmYWxzZSwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lOiBmYWxzZSwgcGVyZm9ybWFuY2U6IGZhbHNlLCBidG9hOiBmYWxzZSovXG5kZWZpbmUoW10sIGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzZWxmKSB7XG4gICAgICAgIGZ1bmN0aW9uIGRyYXdPcmRlckJ5QXJyb3coeCwgeSkge1xuICAgICAgICAgICAgeCArPSBzZWxmLmNhbnZhc09mZnNldExlZnQ7XG4gICAgICAgICAgICB5ICs9IHNlbGYuY2FudmFzT2Zmc2V0VG9wO1xuICAgICAgICAgICAgc2VsZi5jdHguZmlsbFN0eWxlID0gc2VsZi5zdHlsZS5oZWFkZXJPcmRlckJ5QXJyb3dDb2xvcjtcbiAgICAgICAgICAgIHNlbGYuY3R4LnN0cm9rZVN0eWxlID0gc2VsZi5zdHlsZS5oZWFkZXJPcmRlckJ5QXJyb3dCb3JkZXJDb2xvcjtcbiAgICAgICAgICAgIHNlbGYuY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgeCA9IHggKyBzZWxmLnN0eWxlLmhlYWRlck9yZGVyQnlBcnJvd01hcmdpbkxlZnQ7XG4gICAgICAgICAgICB5ID0geSArIHNlbGYuc3R5bGUuaGVhZGVyT3JkZXJCeUFycm93TWFyZ2luVG9wO1xuICAgICAgICAgICAgaWYgKHNlbGYub3JkZXJEaXJlY3Rpb24gPT09ICdhc2MnKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgIHNlbGYuY3R4LmxpbmVUbyh4ICsgc2VsZi5zdHlsZS5oZWFkZXJPcmRlckJ5QXJyb3dXaWR0aCwgeSk7XG4gICAgICAgICAgICAgICAgc2VsZi5jdHgubGluZVRvKHggKyAoc2VsZi5zdHlsZS5oZWFkZXJPcmRlckJ5QXJyb3dXaWR0aCAqIDAuNSksIHkgKyBzZWxmLnN0eWxlLmhlYWRlck9yZGVyQnlBcnJvd0hlaWdodCk7XG4gICAgICAgICAgICAgICAgc2VsZi5jdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLmN0eC5saW5lVG8oeCwgeSArIHNlbGYuc3R5bGUuaGVhZGVyT3JkZXJCeUFycm93SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBzZWxmLmN0eC5saW5lVG8oeCArIHNlbGYuc3R5bGUuaGVhZGVyT3JkZXJCeUFycm93V2lkdGgsIHkgKyBzZWxmLnN0eWxlLmhlYWRlck9yZGVyQnlBcnJvd0hlaWdodCk7XG4gICAgICAgICAgICAgICAgc2VsZi5jdHgubGluZVRvKHggKyAoc2VsZi5zdHlsZS5oZWFkZXJPcmRlckJ5QXJyb3dXaWR0aCAqIDAuNSksIHkpO1xuICAgICAgICAgICAgICAgIHNlbGYuY3R4LmxpbmVUbyh4LCB5ICsgc2VsZi5zdHlsZS5oZWFkZXJPcmRlckJ5QXJyb3dIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5jdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICBzZWxmLmN0eC5maWxsKCk7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5zdHlsZS5oZWFkZXJPcmRlckJ5QXJyb3dNYXJnaW5MZWZ0XG4gICAgICAgICAgICAgICAgKyBzZWxmLnN0eWxlLmhlYWRlck9yZGVyQnlBcnJvd1dpZHRoXG4gICAgICAgICAgICAgICAgKyBzZWxmLnN0eWxlLmhlYWRlck9yZGVyQnlBcnJvd01hcmdpblJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRyYXdUcmVlQXJyb3coY2VsbCwgeCwgeSkge1xuICAgICAgICAgICAgeCArPSBzZWxmLmNhbnZhc09mZnNldExlZnQ7XG4gICAgICAgICAgICB5ICs9IHNlbGYuY2FudmFzT2Zmc2V0VG9wO1xuICAgICAgICAgICAgc2VsZi5jdHguZmlsbFN0eWxlID0gc2VsZi5zdHlsZS50cmVlQXJyb3dDb2xvcjtcbiAgICAgICAgICAgIHNlbGYuY3R4LnN0cm9rZVN0eWxlID0gc2VsZi5zdHlsZS50cmVlQXJyb3dCb3JkZXJDb2xvcjtcbiAgICAgICAgICAgIHNlbGYuY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgeCA9IHggKyBzZWxmLnN0eWxlLnRyZWVBcnJvd01hcmdpbkxlZnQ7XG4gICAgICAgICAgICB5ID0geSArIHNlbGYuc3R5bGUudHJlZUFycm93TWFyZ2luVG9wO1xuICAgICAgICAgICAgaWYgKHNlbGYub3BlbkNoaWxkcmVuW2NlbGwuZGF0YVtzZWxmLnVuaXF1ZUlkXV0pIHtcbiAgICAgICAgICAgICAgICBzZWxmLmN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgc2VsZi5jdHgubGluZVRvKHggKyBzZWxmLnN0eWxlLnRyZWVBcnJvd1dpZHRoLCB5KTtcbiAgICAgICAgICAgICAgICBzZWxmLmN0eC5saW5lVG8oeCArIChzZWxmLnN0eWxlLnRyZWVBcnJvd1dpZHRoICogMC41KSwgeSArIHNlbGYuc3R5bGUudHJlZUFycm93SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBzZWxmLmN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYuY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICBzZWxmLmN0eC5saW5lVG8oeCArIHNlbGYuc3R5bGUudHJlZUFycm93SGVpZ2h0LCB5ICsgKHNlbGYuc3R5bGUudHJlZUFycm93V2lkdGggKiAwLjUpKTtcbiAgICAgICAgICAgICAgICBzZWxmLmN0eC5saW5lVG8oeCwgeSArIHNlbGYuc3R5bGUudHJlZUFycm93V2lkdGgpO1xuICAgICAgICAgICAgICAgIHNlbGYuY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgc2VsZi5jdHguZmlsbCgpO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuc3R5bGUudHJlZUFycm93TWFyZ2luTGVmdFxuICAgICAgICAgICAgICAgICsgc2VsZi5zdHlsZS50cmVlQXJyb3dXaWR0aFxuICAgICAgICAgICAgICAgICsgc2VsZi5zdHlsZS50cmVlQXJyb3dNYXJnaW5SaWdodDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByYWRpdXNSZWN0KHgsIHksIHcsIGgsIHJhZGl1cykge1xuICAgICAgICAgICAgeCArPSBzZWxmLmNhbnZhc09mZnNldExlZnQ7XG4gICAgICAgICAgICB5ICs9IHNlbGYuY2FudmFzT2Zmc2V0VG9wO1xuICAgICAgICAgICAgdmFyIHIgPSB4ICsgdywgYiA9IHkgKyBoO1xuICAgICAgICAgICAgc2VsZi5jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBzZWxmLmN0eC5tb3ZlVG8oeCArIHJhZGl1cywgeSk7XG4gICAgICAgICAgICBzZWxmLmN0eC5saW5lVG8ociAtIHJhZGl1cywgeSk7XG4gICAgICAgICAgICBzZWxmLmN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHIsIHksIHIsIHkgKyByYWRpdXMpO1xuICAgICAgICAgICAgc2VsZi5jdHgubGluZVRvKHIsIHkgKyBoIC0gcmFkaXVzKTtcbiAgICAgICAgICAgIHNlbGYuY3R4LnF1YWRyYXRpY0N1cnZlVG8ociwgYiwgciAtIHJhZGl1cywgYik7XG4gICAgICAgICAgICBzZWxmLmN0eC5saW5lVG8oeCArIHJhZGl1cywgYik7XG4gICAgICAgICAgICBzZWxmLmN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIGIsIHgsIGIgLSByYWRpdXMpO1xuICAgICAgICAgICAgc2VsZi5jdHgubGluZVRvKHgsIHkgKyByYWRpdXMpO1xuICAgICAgICAgICAgc2VsZi5jdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgcmFkaXVzLCB5KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmaWxsUmVjdCh4LCB5LCB3LCBoKSB7XG4gICAgICAgICAgICB4ICs9IHNlbGYuY2FudmFzT2Zmc2V0TGVmdDtcbiAgICAgICAgICAgIHkgKz0gc2VsZi5jYW52YXNPZmZzZXRUb3A7XG4gICAgICAgICAgICBzZWxmLmN0eC5maWxsUmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdHJva2VSZWN0KHgsIHksIHcsIGgpIHtcbiAgICAgICAgICAgIHggKz0gc2VsZi5jYW52YXNPZmZzZXRMZWZ0O1xuICAgICAgICAgICAgeSArPSBzZWxmLmNhbnZhc09mZnNldFRvcDtcbiAgICAgICAgICAgIHNlbGYuY3R4LnN0cm9rZVJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZmlsbFRleHQodGV4dCwgeCwgeSkge1xuICAgICAgICAgICAgeCArPSBzZWxmLmNhbnZhc09mZnNldExlZnQ7XG4gICAgICAgICAgICB5ICs9IHNlbGYuY2FudmFzT2Zmc2V0VG9wO1xuICAgICAgICAgICAgc2VsZi5jdHguZmlsbFRleHQodGV4dCwgeCwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWRkQm9yZGVyTGluZShjLCBwb3MpIHtcbiAgICAgICAgICAgIHNlbGYuY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgdmFyIHAgPSB7XG4gICAgICAgICAgICAgICAgdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmN0eC5tb3ZlVG8oYy54ICsgc2VsZi5jYW52YXNPZmZzZXRMZWZ0LCBjLnkgKyBzZWxmLmNhbnZhc09mZnNldFRvcCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY3R4LmxpbmVUbyhjLnggKyBzZWxmLmNhbnZhc09mZnNldExlZnQgKyBjLndpZHRoLCBjLnkgKyBzZWxmLmNhbnZhc09mZnNldFRvcCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY3R4Lm1vdmVUbyhjLnggKyBzZWxmLmNhbnZhc09mZnNldExlZnQgKyBjLndpZHRoLCBjLnkgKyBzZWxmLmNhbnZhc09mZnNldFRvcCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY3R4LmxpbmVUbyhjLnggKyBzZWxmLmNhbnZhc09mZnNldExlZnQgKyBjLndpZHRoLCBjLnkgKyBzZWxmLmNhbnZhc09mZnNldFRvcCArIGMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jdHgubW92ZVRvKGMueCArIHNlbGYuY2FudmFzT2Zmc2V0TGVmdCwgYy55ICsgc2VsZi5jYW52YXNPZmZzZXRUb3AgKyBjLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY3R4LmxpbmVUbyhjLnggKyBzZWxmLmNhbnZhc09mZnNldExlZnQgKyBjLndpZHRoLCBjLnkgKyBzZWxmLmNhbnZhc09mZnNldFRvcCArIGMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jdHgubW92ZVRvKGMueCArIHNlbGYuY2FudmFzT2Zmc2V0TGVmdCwgYy55ICsgc2VsZi5jYW52YXNPZmZzZXRUb3ApO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmN0eC5saW5lVG8oYy54ICsgc2VsZi5jYW52YXNPZmZzZXRMZWZ0LCBjLnkgKyBzZWxmLmNhbnZhc09mZnNldFRvcCArIGMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBbcG9zXSgpO1xuICAgICAgICAgICAgc2VsZi5jdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZHJhd3MgdGhlIGdyaWQuIE5vIG1hdHRlciB3aGF0IHRoZSBjaGFuZ2UsIHRoaXMgaXMgdGhlIG9ubHkgbWV0aG9kIHJlcXVpcmVkIHRvIHJlZnJlc2ggZXZlcnl0aGluZy5cbiAgICAgICAgICogQG1lbWJlcm9mIGNhbnZhc0RhdGFHcmlkI1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmRyYXcgPSBmdW5jdGlvbiAoaW50ZXJuYWwpIHtcbiAgICAgICAgICAgIGlmICghc2VsZi5pc0NoaWxkR3JpZCAmJiAoIXNlbGYuaGVpZ2h0IHx8ICFzZWxmLndpZHRoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmlzQ2hpbGRHcmlkICYmIGludGVybmFsKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHNlbGYucGFyZW50R3JpZC5kcmF3KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5pbnRmLnZpc2libGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaW5pdGlhbCB2YWx1ZXNcbiAgICAgICAgICAgIHZhciBjaGVja1Njcm9sbEhlaWdodCwgYm9yZGVyV2lkdGgsIHJvd0hlYWRlckNlbGwsIHAsIGN4LCBjeSwgdHJlZUdyaWQsIHJvd09wZW4sXG4gICAgICAgICAgICAgICAgcm93SGVpZ2h0LCBjb3JuZXJDZWxsLCB5LCB4LCBjLCBoLCB3LCBzLCByLCByZCwgYUNlbGwsXG4gICAgICAgICAgICAgICAgbCA9IHNlbGYuZGF0YS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgdSA9IHNlbGYuY3VycmVudENlbGwgfHwge30sXG4gICAgICAgICAgICAgICAgaGVhZGVyQ2VsbEhlaWdodCA9IHNlbGYuZ2V0SGVhZGVyQ2VsbEhlaWdodCgpLFxuICAgICAgICAgICAgICAgIGhlYWRlckNlbGxXaWR0aCA9IHNlbGYuZ2V0SGVhZGVyQ2VsbFdpZHRoKCksXG4gICAgICAgICAgICAgICAgY2VsbEhlaWdodCA9IHNlbGYuc3R5bGUuY2VsbEhlaWdodDtcbiAgICAgICAgICAgIC8vIGlmIGRhdGEgbGVuZ3RoIGhhcyBjaGFuZ2VkLCB0aGVyZSBpcyBubyB3YXkgdG8ga25vd1xuICAgICAgICAgICAgaWYgKHNlbGYuZGF0YS5sZW5ndGggPiBzZWxmLm9yZGVycy5yb3dzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNlbGYuY3JlYXRlUm93T3JkZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBkcmF3U2Nyb2xsQmFycygpIHtcbiAgICAgICAgICAgICAgICB2YXIgdiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ3ZlcnRpY2FsLXNjcm9sbC1iYXInXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG4gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICdob3Jpem9udGFsLXNjcm9sbC1iYXInXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHZiID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAndmVydGljYWwtc2Nyb2xsLWJveCdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbmIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICdob3Jpem9udGFsLXNjcm9sbC1ib3gnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAnc2Nyb2xsLWJveC1jb3JuZXInXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG0gPSAoc2VsZi5zdHlsZS5zY3JvbGxCYXJCb3hNYXJnaW4gKiAyKSxcbiAgICAgICAgICAgICAgICAgICAgZCA9IHNlbGYuc3R5bGUuc2Nyb2xsQmFyQm94TWFyZ2luICogMC41O1xuICAgICAgICAgICAgICAgIHNlbGYuY3R4LnN0cm9rZVN0eWxlID0gc2VsZi5zdHlsZS5zY3JvbGxCYXJCb3JkZXJDb2xvcjtcbiAgICAgICAgICAgICAgICBzZWxmLmN0eC5saW5lV2lkdGggPSBzZWxmLnN0eWxlLnNjcm9sbEJhckJvcmRlcldpZHRoO1xuICAgICAgICAgICAgICAgIC8vIHZlcnRpY2FsXG4gICAgICAgICAgICAgICAgdi54ICs9IHcgLSBzZWxmLnN0eWxlLnNjcm9sbEJhcldpZHRoIC0gc2VsZi5zdHlsZS5zY3JvbGxCYXJCb3JkZXJXaWR0aCAtIGQ7XG4gICAgICAgICAgICAgICAgdi55ICs9IGhlYWRlckNlbGxIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdi53aWR0aCA9IHNlbGYuc3R5bGUuc2Nyb2xsQmFyV2lkdGggKyBzZWxmLnN0eWxlLnNjcm9sbEJhckJvcmRlcldpZHRoICsgZDtcbiAgICAgICAgICAgICAgICB2LmhlaWdodCA9IGggLSBoZWFkZXJDZWxsSGVpZ2h0IC0gc2VsZi5zdHlsZS5zY3JvbGxCYXJXaWR0aCAtIGQgLSBtO1xuICAgICAgICAgICAgICAgIHNlbGYuY3R4LmZpbGxTdHlsZSA9IHNlbGYuc3R5bGUuc2Nyb2xsQmFyQmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgICAgIGZpbGxSZWN0KHYueCwgdi55LCB2LndpZHRoLCB2LmhlaWdodCArIG0pO1xuICAgICAgICAgICAgICAgIHN0cm9rZVJlY3Qodi54LCB2LnksIHYud2lkdGgsIHYuaGVpZ2h0ICsgbSk7XG4gICAgICAgICAgICAgICAgLy8gdmVydGljYWwgYm94XG4gICAgICAgICAgICAgICAgdmIueCA9IHYueCArIHNlbGYuc3R5bGUuc2Nyb2xsQmFyQm94TWFyZ2luO1xuICAgICAgICAgICAgICAgIHZiLnkgPSBoZWFkZXJDZWxsSGVpZ2h0ICsgc2VsZi5zdHlsZS5zY3JvbGxCYXJCb3hNYXJnaW5cbiAgICAgICAgICAgICAgICAgICAgKyAoKHYuaGVpZ2h0IC0gc2VsZi5zY3JvbGxCb3guc2Nyb2xsQm94SGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgKiAoc2VsZi5zY3JvbGxCb3guc2Nyb2xsVG9wIC8gc2VsZi5zY3JvbGxCb3guc2Nyb2xsSGVpZ2h0KSk7XG4gICAgICAgICAgICAgICAgdmIud2lkdGggPSBzZWxmLnN0eWxlLnNjcm9sbEJhckJveFdpZHRoO1xuICAgICAgICAgICAgICAgIHZiLmhlaWdodCA9IHNlbGYuc2Nyb2xsQm94LnNjcm9sbEJveEhlaWdodDtcbiAgICAgICAgICAgICAgICBzZWxmLmN0eC5maWxsU3R5bGUgPSBzZWxmLnN0eWxlLnNjcm9sbEJhckJveENvbG9yO1xuICAgICAgICAgICAgICAgIGlmICgvdmVydGljYWwvLnRlc3QodS5jb250ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmN0eC5maWxsU3R5bGUgPSBzZWxmLnN0eWxlLnNjcm9sbEJhckFjdGl2ZUNvbG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmIud2lkdGggPCB2LndpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhZGl1c1JlY3QodmIueCwgdmIueSwgdmIud2lkdGgsIHZiLmhlaWdodCwgc2VsZi5zdHlsZS5zY3JvbGxCYXJCb3hCb3JkZXJSYWRpdXMpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBob3Jpem9udGFsXG4gICAgICAgICAgICAgICAgbi54ICs9IGhlYWRlckNlbGxXaWR0aDtcbiAgICAgICAgICAgICAgICBuLnkgKz0gaCAtIHNlbGYuc3R5bGUuc2Nyb2xsQmFyV2lkdGggLSBkO1xuICAgICAgICAgICAgICAgIG4ud2lkdGggPSB3IC0gc2VsZi5zdHlsZS5zY3JvbGxCYXJXaWR0aCAtIGhlYWRlckNlbGxXaWR0aCAtIGQgLSBtO1xuICAgICAgICAgICAgICAgIG4uaGVpZ2h0ID0gc2VsZi5zdHlsZS5zY3JvbGxCYXJXaWR0aCArIHNlbGYuc3R5bGUuc2Nyb2xsQmFyQm9yZGVyV2lkdGggKyBkO1xuICAgICAgICAgICAgICAgIHNlbGYuY3R4LmZpbGxTdHlsZSA9IHNlbGYuc3R5bGUuc2Nyb2xsQmFyQmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgICAgIGZpbGxSZWN0KG4ueCwgbi55LCBuLndpZHRoICsgbSwgbi5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIHN0cm9rZVJlY3Qobi54LCBuLnksIG4ud2lkdGggKyBtLCBuLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgLy8gaG9yaXpvbnRhbCBib3hcbiAgICAgICAgICAgICAgICBuYi55ID0gbi55ICsgc2VsZi5zdHlsZS5zY3JvbGxCYXJCb3hNYXJnaW47XG4gICAgICAgICAgICAgICAgbmIueCA9IGhlYWRlckNlbGxXaWR0aCArIHNlbGYuc3R5bGUuc2Nyb2xsQmFyQm94TWFyZ2luXG4gICAgICAgICAgICAgICAgICAgICsgKChuLndpZHRoIC0gc2VsZi5zY3JvbGxCb3guc2Nyb2xsQm94V2lkdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAqIChzZWxmLnNjcm9sbEJveC5zY3JvbGxMZWZ0IC8gc2VsZi5zY3JvbGxCb3guc2Nyb2xsV2lkdGgpKTtcbiAgICAgICAgICAgICAgICBuYi53aWR0aCA9IHNlbGYuc2Nyb2xsQm94LnNjcm9sbEJveFdpZHRoO1xuICAgICAgICAgICAgICAgIG5iLmhlaWdodCA9IHNlbGYuc3R5bGUuc2Nyb2xsQmFyQm94V2lkdGg7XG4gICAgICAgICAgICAgICAgc2VsZi5jdHguZmlsbFN0eWxlID0gc2VsZi5zdHlsZS5zY3JvbGxCYXJCb3hDb2xvcjtcbiAgICAgICAgICAgICAgICBpZiAoL2hvcml6b250YWwvLnRlc3QodS5jb250ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmN0eC5maWxsU3R5bGUgPSBzZWxmLnN0eWxlLnNjcm9sbEJhckFjdGl2ZUNvbG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmIud2lkdGggPCBuLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhZGl1c1JlY3QobmIueCwgbmIueSwgbmIud2lkdGgsIG5iLmhlaWdodCwgc2VsZi5zdHlsZS5zY3JvbGxCYXJCb3hCb3JkZXJSYWRpdXMpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL2Nvcm5lclxuICAgICAgICAgICAgICAgIHNlbGYuY3R4LnN0cm9rZVN0eWxlID0gc2VsZi5zdHlsZS5zY3JvbGxCYXJDb3JuZXJCb3JkZXJDb2xvcjtcbiAgICAgICAgICAgICAgICBzZWxmLmN0eC5maWxsU3R5bGUgPSBzZWxmLnN0eWxlLnNjcm9sbEJhckNvcm5lckJhY2tncm91bmQ7XG4gICAgICAgICAgICAgICAgY28ueCA9IG4ueCArIG4ud2lkdGggKyBtO1xuICAgICAgICAgICAgICAgIGNvLnkgPSB2LnkgKyB2LmhlaWdodCArIG07XG4gICAgICAgICAgICAgICAgY28ud2lkdGggPSBzZWxmLnN0eWxlLnNjcm9sbEJhcldpZHRoICsgc2VsZi5zdHlsZS5zY3JvbGxCYXJCb3JkZXJXaWR0aDtcbiAgICAgICAgICAgICAgICBjby5oZWlnaHQgPSBzZWxmLnN0eWxlLnNjcm9sbEJhcldpZHRoICsgc2VsZi5zdHlsZS5zY3JvbGxCYXJCb3JkZXJXaWR0aDtcbiAgICAgICAgICAgICAgICByYWRpdXNSZWN0KGNvLngsIGNvLnksIGNvLndpZHRoLCBjby5oZWlnaHQsIDApO1xuICAgICAgICAgICAgICAgIHNlbGYuY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgIHNlbGYuY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICBzZWxmLnZpc2libGVDZWxscy51bnNoaWZ0KHYpO1xuICAgICAgICAgICAgICAgIHNlbGYudmlzaWJsZUNlbGxzLnVuc2hpZnQodmIpO1xuICAgICAgICAgICAgICAgIHNlbGYudmlzaWJsZUNlbGxzLnVuc2hpZnQobik7XG4gICAgICAgICAgICAgICAgc2VsZi52aXNpYmxlQ2VsbHMudW5zaGlmdChuYik7XG4gICAgICAgICAgICAgICAgc2VsZi52aXNpYmxlQ2VsbHMudW5zaGlmdChjbyk7XG4gICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxCb3guYmFyID0ge1xuICAgICAgICAgICAgICAgICAgICB2OiB2LFxuICAgICAgICAgICAgICAgICAgICBoOiBuXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzZWxmLnNjcm9sbEJveC5ib3ggPSB7XG4gICAgICAgICAgICAgICAgICAgIHY6IHZiLFxuICAgICAgICAgICAgICAgICAgICBoOiBuYlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBkcmF3Q2VsbChkLCByb3dJbmRleCwgcm93T3JkZXJJbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBkcmF3RWFjaChoZWFkZXIsIGhlYWRlckluZGV4LCBjb2x1bW5PcmRlckluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjZWxsU3R5bGUgPSBoZWFkZXIuc3R5bGUgfHwgJ2NlbGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRHcmlkQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IHNlbGYuc2VsZWN0aW9uc1tyb3dPcmRlckluZGV4XSAmJiBzZWxmLnNlbGVjdGlvbnNbcm93T3JkZXJJbmRleF0uaW5kZXhPZihjb2x1bW5PcmRlckluZGV4KSAhPT0gLTEsXG4gICAgICAgICAgICAgICAgICAgICAgICBob3ZlcmVkID0gc2VsZi5ob3ZlcnNbZFtzZWxmLnVuaXF1ZUlkXV0gJiYgc2VsZi5ob3ZlcnNbZFtzZWxmLnVuaXF1ZUlkXV0uaW5kZXhPZihjb2x1bW5PcmRlckluZGV4KSAhPT0gLTEsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmUgPSBzZWxmLmFjdGl2ZUNlbGwucm93SW5kZXggPT09IHJvd09yZGVySW5kZXggJiYgc2VsZi5hY3RpdmVDZWxsLmNvbHVtbkluZGV4ID09PSBjb2x1bW5PcmRlckluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNHcmlkID0gQXJyYXkuaXNBcnJheShkW2hlYWRlci5uYW1lXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVIZWFkZXIgPSAoc2VsZi5vcmRlcnMucm93c1tzZWxmLmFjdGl2ZUNlbGwucm93SW5kZXhdID09PSByb3dPcmRlckluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHNlbGYub3JkZXJzLmNvbHVtbnNbc2VsZi5hY3RpdmVDZWxsLmNvbHVtbkluZGV4XSA9PT0gY29sdW1uT3JkZXJJbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoY29sdW1uT3JkZXJJbmRleCA9PT0gLTEgfHwgcm93T3JkZXJJbmRleCA9PT0gLTEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZiA9IHNlbGYuZm9ybWF0dGVyc1toZWFkZXIudHlwZSB8fCAnc3RyaW5nJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmRlckJ5QXJyb3dTaXplID0gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWVBcnJvd1NpemUgPSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFdpZHRoID0gc2VsZi5zaXplcy5jb2x1bW5zW2NlbGxTdHlsZSAgPT09ICdyb3dIZWFkZXJDZWxsJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ2Nvcm5lckNlbGwnIDogaGVhZGVyW3NlbGYudW5pcXVlSWRdXSB8fCBoZWFkZXIud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjZWxsU3R5bGUgPT09ICdoZWFkZXJDZWxsQ2FwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFdpZHRoID0gdyAtIHg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm8gZGF0YSBvciBzY2hlbWEgYXJlIGRlZmluZWQsIGEgd2lkdGggaXMgcHJvdmlkZWQgdG8gdGhlIHN0dWIgY29sdW1uXG4gICAgICAgICAgICAgICAgICAgIGlmIChjZWxsV2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFdpZHRoID0gc2VsZi5zdHlsZS5jb2x1bW5XaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoeCArIGNlbGxXaWR0aCArIGJvcmRlcldpZHRoIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBjZWxsV2lkdGggKyBib3JkZXJXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsU3R5bGUgPSAnYWN0aXZlQ2VsbCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYudmlzaWJsZVJvd3MuaW5kZXhPZihyb3dJbmRleCkgPT09IC0xXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgWydoZWFkZXJDZWxsJywgJ2Nvcm5lckNlbGwnXS5pbmRleE9mKGNlbGxTdHlsZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnZpc2libGVSb3dzLnB1c2gocm93SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHNlbGYuZGlzcGF0Y2hFdmVudCgnZm9ybWF0Y2VsbHZhbHVlJywgW3NlbGYuY3R4LCBkW2hlYWRlci5uYW1lXSwgZCwgaGVhZGVyLCBjeCwgY3ldLCBzZWxmLmludGYpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGYuZGlzcGF0Y2hFdmVudCgnYmVmb3JlcmVuZGVyY2VsbCcsIFt7fSwgc2VsZi5jdHgsIGRbaGVhZGVyLm5hbWVdLCBkLCBoZWFkZXIsIGN4LCBjeV0sIHNlbGYuaW50ZikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxsU3R5bGUgPT09ICdjb3JuZXJDZWxsJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNlbGxTdHlsZSA9PT0gJ3Jvd0hlYWRlckNlbGwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3ggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjZWxsU3R5bGUgPT09ICdoZWFkZXJDZWxsJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogaXNHcmlkID8gJ2NhbnZhcy1kYXRhZ3JpZC1jZWxsJyA6IGhlYWRlci50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBjZWxsU3R5bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVR5cGU6ICdjYW52YXMtZGF0YWdyaWQtY2VsbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogY3gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogY3ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0VG9wOiBzZWxmLmNhbnZhc09mZnNldFRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRMZWZ0OiBzZWxmLmNhbnZhc09mZnNldExlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVG9wOiBzZWxmLnNjcm9sbEJveC5zY3JvbGxUb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsTGVmdDogc2VsZi5zY3JvbGxCb3guc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmU6IGFjdGl2ZSA9PT0gdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3ZlcmVkOiBob3ZlcmVkID09PSB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZCA9PT0gdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogY2VsbFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogY2VsbEhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRXaWR0aDogY2VsbFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldEhlaWdodDogY2VsbEhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlOiBzZWxmLmludGYucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRQYXJlbnQ6IHNlbGYuaW50Zi5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNIZWFkZXI6IC9oZWFkZXJDZWxsfGNvcm5lckNlbGwvLnRlc3QoY2VsbFN0eWxlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1Jvd0hlYWRlcjogJ3Jvd0hlYWRlckNlbGwnID09PSBjZWxsU3R5bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93T3Blbjogcm93T3BlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXI6IGhlYWRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5JbmRleDogY29sdW1uT3JkZXJJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dJbmRleDogcm93T3JkZXJJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3J0Q29sdW1uSW5kZXg6IGhlYWRlckluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRSb3dJbmRleDogcm93SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNHcmlkOiBpc0dyaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZElkOiAoc2VsZi5hdHRyaWJ1dGVzLm5hbWUgfHwgJycpICsgZFtzZWxmLnVuaXF1ZUlkXSArICc6JyArIGhlYWRlcltzZWxmLnVuaXF1ZUlkXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRHcmlkOiBzZWxmLmludGYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNlbGxTdHlsZSA9PT0gJ2hlYWRlckNlbGwnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKGhlYWRlci50aXRsZSB8fCBoZWFkZXIubmFtZSkgOiBkW2hlYWRlci5uYW1lXVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwudXNlckhlaWdodCA9IGNlbGwuaXNIZWFkZXIgPyBzZWxmLnNpemVzLnJvd3NbLTFdIDogcm93SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC51c2VyV2lkdGggPSBjZWxsLmlzSGVhZGVyID8gc2VsZi5zaXplcy5jb2x1bW5zLmNvcm5lckNlbGwgOiBzZWxmLnNpemVzLmNvbHVtbnNbaGVhZGVyW3NlbGYudW5pcXVlSWRdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxbc2VsZi51bmlxdWVJZF0gPSBkW3NlbGYudW5pcXVlSWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi52aXNpYmxlQ2VsbHMudW5zaGlmdChjZWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY3R4LmZpbGxTdHlsZSA9IHNlbGYuc3R5bGVbY2VsbFN0eWxlICsgJ0JhY2tncm91bmRDb2xvciddO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jdHguc3Ryb2tlU3R5bGUgPSBzZWxmLnN0eWxlW2NlbGxTdHlsZSArICdCb3JkZXJDb2xvciddO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jdHgubGluZVdpZHRoID0gc2VsZi5zdHlsZVtjZWxsU3R5bGUgKyAnQm9yZGVyV2lkdGgnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChob3ZlcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jdHguZmlsbFN0eWxlID0gc2VsZi5zdHlsZVtjZWxsU3R5bGUgKyAnSG92ZXJCYWNrZ3JvdW5kQ29sb3InXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmN0eC5zdHJva2VTdHlsZSA9IHNlbGYuc3R5bGVbY2VsbFN0eWxlICsgJ0hvdmVyQm9yZGVyQ29sb3InXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY3R4LmZpbGxTdHlsZSA9IHNlbGYuc3R5bGVbY2VsbFN0eWxlICsgJ1NlbGVjdGVkQmFja2dyb3VuZENvbG9yJ107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jdHguc3Ryb2tlU3R5bGUgPSBzZWxmLnN0eWxlW2NlbGxTdHlsZSArICdTZWxlY3RlZEJvcmRlckNvbG9yJ107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlSGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jdHguZmlsbFN0eWxlID0gc2VsZi5zdHlsZVtjZWxsU3R5bGUgKyAnQWN0aXZlQmFja2dyb3VuZENvbG9yJ107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ3JlbmRlcmNlbGwnLCBbc2VsZi5jdHgsIGNlbGxdLCBzZWxmLmludGYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGwuaXNHcmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGwuaGVpZ2h0ICE9PSByb3dIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5oZWlnaHQgPSByb3dIZWlnaHQgfHwgc2VsZi5zdHlsZS5jZWxsSGVpZ2h0V2l0aENoaWxkR3JpZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tTY3JvbGxIZWlnaHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLndpZHRoID0gc2VsZi5zaXplcy5jb2x1bW5zW2hlYWRlcltzZWxmLnVuaXF1ZUlkXV0gfHwgc2VsZi5zdHlsZS5jZWxsV2lkdGhXaXRoQ2hpbGRHcmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvd09wZW4gJiYgIWNlbGwuaXNSb3dIZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLmhlaWdodCA9IHNlbGYuc2l6ZXMucm93c1tyZFtzZWxmLnVuaXF1ZUlkXV0gfHwgc2VsZi5zdHlsZS5jZWxsSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjZWxsLmlzR3JpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxSZWN0KGN4LCBjeSwgY2VsbC53aWR0aCwgY2VsbC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVJlY3QoY3gsIGN5LCBjZWxsLndpZHRoLCBjZWxsLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByYWRpdXNSZWN0KGNlbGwueCwgY2VsbC55LCBjZWxsLndpZHRoLCBjZWxsLmhlaWdodCwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmN0eC5jbGlwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2FmdGVycmVuZGVyY2VsbCcsIFtzZWxmLmN0eCwgY2VsbF0sIHNlbGYuaW50Zik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbC5oZWlnaHQgIT09IGNlbGxIZWlnaHQgJiYgIShyb3dPcGVuICYmICFjZWxsLmlzUm93SGVhZGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2l6ZXMucm93c1tjZWxsU3R5bGUgPT09ICdoZWFkZXJDZWxsJyA/IC0xIDogZFtzZWxmLnVuaXF1ZUlkXV0gPSBjZWxsLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja1Njcm9sbEhlaWdodCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbC53aWR0aCAhPT0gY2VsbFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zaXplcy5jb2x1bW5zW2hlYWRlcltzZWxmLnVuaXF1ZUlkXV0gPSBjZWxsLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrU2Nyb2xsSGVpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxsU3R5bGUgPT09ICdyb3dIZWFkZXJDZWxsJyAmJiBzZWxmLmF0dHJpYnV0ZXMudHJlZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2VsZi5kaXNwYXRjaEV2ZW50KCdyZW5kZXJ0cmVlYXJyb3cnLCBbe30sIHNlbGYuY3R4LCBjZWxsXSwgc2VsZi5pbnRmKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmVlQXJyb3dTaXplID0gZHJhd1RyZWVBcnJvdyhjZWxsLCBzZWxmLnN0eWxlW2NlbGxTdHlsZSArICdQYWRkaW5nTGVmdCddLCBjeSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChzZWxmLmF0dHJpYnV0ZXMuc2hvd1Jvd051bWJlcnMgJiYgY2VsbFN0eWxlID09PSAncm93SGVhZGVyQ2VsbCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGNlbGxTdHlsZSAhPT0gJ3Jvd0hlYWRlckNlbGwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGwuaXNHcmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2VsZi5jaGlsZEdyaWRzW2NlbGwuZ3JpZElkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRHcmlkQXR0cmlidXRlcyA9IHNlbGYuYXJncy5jaGlsZEdyaWRBdHRyaWJ1dGVzIHx8IHNlbGYuYXJncztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkR3JpZEF0dHJpYnV0ZXMubmFtZSA9IHNlbGYuYXR0cmlidXRlcy5zYXZlQXBwZWFyYW5jZSA/IGNlbGwuZ3JpZElkIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRHcmlkQXR0cmlidXRlcy5wYXJlbnROb2RlID0gY2VsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkR3JpZEF0dHJpYnV0ZXMuZGF0YSA9IGRbaGVhZGVyLm5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jaGlsZEdyaWRzW2NlbGwuZ3JpZElkXSA9IHNlbGYuY3JlYXRlR3JpZChjaGlsZEdyaWRBdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgncmVuZGVyY2VsbGdyaWQnLCBbc2VsZi5jdHgsIGNlbGwsIHNlbGYuY2hpbGRHcmlkc1tjZWxsLmdyaWRJZF1dLCBzZWxmLmludGYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tTY3JvbGxIZWlnaHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuZ3JpZCA9IHNlbGYuY2hpbGRHcmlkc1tjZWxsLmdyaWRJZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuZ3JpZC5wYXJlbnROb2RlID0gY2VsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5ncmlkLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLmdyaWQuZHJhdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmNoaWxkR3JpZHNbY2VsbC5ncmlkSWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNoaWxkR3JpZHNbY2VsbC5ncmlkSWRdLnBhcmVudE5vZGUub2Zmc2V0SGVpZ2h0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmN0eC5mb250ID0gc2VsZi5zdHlsZVtjZWxsU3R5bGUgKyAnRm9udCddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSB2YWwgIT09IHVuZGVmaW5lZCA/IHZhbCA6IGZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZihzZWxmLmN0eCwgY2VsbCkgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkICYmICFmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignY2FudmFzLWRhdGFncmlkOiBJIGRvblxcJ3Qga25vdyBob3cgdG8gZm9ybWF0IGEgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgaGVhZGVyLnR5cGUgKyAnIGFkZCBhIGNlbGxGb3JtYXRlcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxsU3R5bGUgPT09ICdoZWFkZXJDZWxsJyAmJiBzZWxmLm9yZGVyQnkgPT09IGhlYWRlci5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGYuZGlzcGF0Y2hFdmVudCgncmVuZGVyb3JkZXJieWFycm93JywgW3t9LCBzZWxmLmN0eCwgY2VsbF0sIHNlbGYuaW50ZikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmRlckJ5QXJyb3dTaXplID0gZHJhd09yZGVyQnlBcnJvdyhjeCArIHNlbGYuc3R5bGVbY2VsbFN0eWxlICsgJ1BhZGRpbmdMZWZ0J10sIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY3R4LmZpbGxTdHlsZSA9IHNlbGYuc3R5bGVbY2VsbFN0eWxlICsgJ0NvbG9yJ107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChob3ZlcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmN0eC5maWxsU3R5bGUgPSBzZWxmLnN0eWxlW2NlbGxTdHlsZSArICdIb3ZlckNvbG9yJ107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmN0eC5maWxsU3R5bGUgPSBzZWxmLnN0eWxlW2NlbGxTdHlsZSArICdTZWxlY3RlZENvbG9yJ107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZUhlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jdHguZmlsbFN0eWxlID0gc2VsZi5zdHlsZVtjZWxsU3R5bGUgKyAnQWN0aXZlQ29sb3InXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb2x1bW5GaWx0ZXJzICYmIHNlbGYuY29sdW1uRmlsdGVyc1t2YWxdICE9PSB1bmRlZmluZWQgJiYgY2VsbFN0eWxlID09PSAnaGVhZGVyQ2VsbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHNlbGYuc3R5bGUuZmlsdGVyVGV4dFByZWZpeCArIHZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLmZvcm1hdHRlZFZhbHVlID0gKCh2YWwgIT09IHVuZGVmaW5lZCAmJiB2YWwgIT09IG51bGwpID8gdmFsIDogJycpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgncmVuZGVydGV4dCcsIFtzZWxmLmN0eCwgY2VsbF0sIHNlbGYuaW50Zik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxUZXh0KHNlbGYuYWRkRWxsaXBzaXMoY2VsbC5mb3JtYXR0ZWRWYWx1ZSwgY2VsbC53aWR0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBzZWxmLnN0eWxlW2NlbGxTdHlsZSArICdQYWRkaW5nUmlnaHQnXSAtIG9yZGVyQnlBcnJvd1NpemUgLSBzZWxmLnN0eWxlLmF1dG9zaXplUGFkZGluZyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmVlQXJyb3dTaXplICsgb3JkZXJCeUFycm93U2l6ZSArIGN4ICsgc2VsZi5zdHlsZVtjZWxsU3R5bGUgKyAnUGFkZGluZ0xlZnQnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN5IC0gKGNlbGwuaGVpZ2h0ICogMC41KSArIHNlbGYuc3R5bGVbY2VsbFN0eWxlICsgJ1BhZGRpbmdUb3AnXSArIGNlbGwuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlICYmICFzZWxmLmF0dHJpYnV0ZXMucm93U2VsZWN0aW9uTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFDZWxsID0gY2VsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmN0eC5saW5lV2lkdGggPSBzZWxmLnN0eWxlLmFjdGl2ZUNlbGxPdmVybGF5Qm9yZGVyV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jdHguc3Ryb2tlU3R5bGUgPSBzZWxmLnN0eWxlLmFjdGl2ZUNlbGxPdmVybGF5Qm9yZGVyQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlUmVjdChhQ2VsbC54LCBhQ2VsbC55LCBhQ2VsbC53aWR0aCwgYUNlbGwuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY3R4LmxpbmVXaWR0aCA9IHNlbGYuc3R5bGUuc2VsZWN0aW9uT3ZlcmxheUJvcmRlcldpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY3R4LnN0cm9rZVN0eWxlID0gc2VsZi5zdHlsZS5zZWxlY3Rpb25PdmVybGF5Qm9yZGVyQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGwuc2VsZWN0ZWQgJiYgY2VsbC5zdHlsZSAhPT0gJ3Jvd0hlYWRlckNlbGwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoIXNlbGYuc2VsZWN0aW9uc1tjZWxsLnJvd0luZGV4IC0gMV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBzZWxmLnNlbGVjdGlvbnNbY2VsbC5yb3dJbmRleCAtIDFdLmluZGV4T2YoY2VsbC5jb2x1bW5JbmRleCkgPT09IC0xXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgY2VsbC5yb3dJbmRleCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAhY2VsbC5pc0hlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQm9yZGVyTGluZShjZWxsLCAndCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2VsZi5zZWxlY3Rpb25zW2NlbGwucm93SW5kZXhdIHx8IGNlbGwuY29sdW1uSW5kZXggPT09IHMubGVuZ3RoIC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHNlbGYuc2VsZWN0aW9uc1tjZWxsLnJvd0luZGV4XS5pbmRleE9mKGNlbGwuY29sdW1uSW5kZXggKyAxKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZEJvcmRlckxpbmUoY2VsbCwgJ3InKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGYuc2VsZWN0aW9uc1tjZWxsLnJvd0luZGV4ICsgMV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBzZWxmLnNlbGVjdGlvbnNbY2VsbC5yb3dJbmRleCArIDFdLmluZGV4T2YoY2VsbC5jb2x1bW5JbmRleCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRCb3JkZXJMaW5lKGNlbGwsICdiJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxmLnNlbGVjdGlvbnNbY2VsbC5yb3dJbmRleF0gfHwgY2VsbC5jb2x1bW5JbmRleCA9PT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHNlbGYuc2VsZWN0aW9uc1tjZWxsLnJvd0luZGV4XS5pbmRleE9mKGNlbGwuY29sdW1uSW5kZXggLSAxKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZEJvcmRlckxpbmUoY2VsbCwgJ2wnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gY2VsbC53aWR0aCArIGJvcmRlcldpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNlbGwud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZHJhd0hlYWRlclJvdygpIHtcbiAgICAgICAgICAgICAgICB2YXIgZCwgZyA9IHMubGVuZ3RoLCBpLCBvLCBoZWFkZXJDZWxsLCBoZWFkZXI7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuYXR0cmlidXRlcy5zaG93SGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICB4ID0gKHNlbGYuc2Nyb2xsQm94LnNjcm9sbExlZnQgKiAtMSkgKyBzZWxmLnNjcm9sbFBpeGVsTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuYXR0cmlidXRlcy5zaG93Um93SGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBoZWFkZXJDZWxsV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNlbGwgaGVpZ2h0IG1pZ2h0IGhhdmUgY2hhbmdlZCBkdXJpbmcgZHJhd2luZ1xuICAgICAgICAgICAgICAgICAgICBjZWxsSGVpZ2h0ID0gc2VsZi5nZXRIZWFkZXJDZWxsSGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobyA9IHNlbGYuc2Nyb2xsSW5kZXhMZWZ0OyBvIDwgZzsgbyArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gc2VsZi5vcmRlcnMuY29sdW1uc1tvXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlciA9IHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBoZWFkZXIudGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogaGVhZGVyLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGhlYWRlci53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ2hlYWRlckNlbGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyOiBpXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyQ2VsbCA9IHsnaGVhZGVyQ2VsbCc6IGhlYWRlci50aXRsZSB8fCBoZWFkZXIubmFtZX07XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJDZWxsW3NlbGYudW5pcXVlSWRdID0gJ2gnICsgaGVhZGVyW3NlbGYudW5pcXVlSWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZFtzZWxmLnVuaXF1ZUlkXSA9IGhlYWRlcltzZWxmLnVuaXF1ZUlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gZHJhd0NlbGwoaGVhZGVyQ2VsbCwgLTEsIC0xKShkLCBvLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4ID4gc2VsZi53aWR0aCArIHNlbGYuc2Nyb2xsQm94LnNjcm9sbExlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBmaWxsIGluIHRoZSBzcGFjZSByaWdodCBvZiB0aGUgaGVhZGVyc1xuICAgICAgICAgICAgICAgICAgICBpZiAoeCA8IHcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHNlbGYuc3R5bGUuc2Nyb2xsQmFyV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICdoZWFkZXJDZWxsQ2FwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogcy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjW3NlbGYudW5pcXVlSWRdID0gJ2hlYWRlckNlbGwnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhd0NlbGwoe2VuZENhcDogJyd9LCAtMSwgLTEpKGMsIC0xLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZmlsbCBpbiB0aGUgc3BhY2UgbGVmdCBvZiB0aGUgaGVhZGVyc1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5hdHRyaWJ1dGVzLnNob3dSb3dIZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3JuZXJDZWxsID0geydjb3JuZXJDZWxsJzogJycgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcm5lckNlbGxbc2VsZi51bmlxdWVJZF0gPSAnY29ybmVyQ2VsbCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2Nvcm5lckNlbGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBzZWxmLnN0eWxlLmhlYWRlclJvd1dpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAnY29ybmVyQ2VsbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IC0xXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY1tzZWxmLnVuaXF1ZUlkXSA9ICdjb3JuZXJDZWxsJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdDZWxsKGNvcm5lckNlbGwsIC0xLCAtMSkoYywgLTEsIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGRyYXdSb3dIZWFkZXIocm93RGF0YSwgaW5kZXgsIHJvd09yZGVySW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5hdHRyaWJ1dGVzLnNob3dSb3dIZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgICAgICAgICByb3dIZWFkZXJDZWxsID0geydyb3dIZWFkZXJDZWxsJzogaW5kZXggKyAxIH07XG4gICAgICAgICAgICAgICAgICAgIHJvd0hlYWRlckNlbGxbc2VsZi51bmlxdWVJZF0gPSByb3dEYXRhW3NlbGYudW5pcXVlSWRdO1xuICAgICAgICAgICAgICAgICAgICBhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3Jvd0hlYWRlckNlbGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHNlbGYuc3R5bGUuaGVhZGVyUm93V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ3Jvd0hlYWRlckNlbGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiByb3dEYXRhW3NlbGYudW5pcXVlSWRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IC0xXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGFbc2VsZi51bmlxdWVJZF0gPSByb3dEYXRhW3NlbGYudW5pcXVlSWRdO1xuICAgICAgICAgICAgICAgICAgICBkcmF3Q2VsbChyb3dIZWFkZXJDZWxsLCBpbmRleCwgcm93T3JkZXJJbmRleCkoYSwgLTEsIC0xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBkcmF3Um93KHIsIGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSwgdHJlZUhlaWdodCwgcm93U2Fuc1RyZWVIZWlnaHQsIG8sIGcgPSBzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoeSAtIChjZWxsSGVpZ2h0ICogMikgPiBoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmQgPSBzZWxmLmRhdGFbcl07XG4gICAgICAgICAgICAgICAgcm93T3BlbiA9IHNlbGYub3BlbkNoaWxkcmVuW3JkW3NlbGYudW5pcXVlSWRdXTtcbiAgICAgICAgICAgICAgICByb3dTYW5zVHJlZUhlaWdodCA9IHNlbGYuc2l6ZXMucm93c1tyZFtzZWxmLnVuaXF1ZUlkXV0gfHwgc2VsZi5zdHlsZS5jZWxsSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRyZWVIZWlnaHQgPSAocm93T3BlbiA/IHNlbGYuc2l6ZXMudHJlZXNbcmRbc2VsZi51bmlxdWVJZF1dIDogMCk7XG4gICAgICAgICAgICAgICAgcm93SGVpZ2h0ID0gcm93U2Fuc1RyZWVIZWlnaHQgKyB0cmVlSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmICh5IDwgcm93SGVpZ2h0ICogLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5hdHRyaWJ1dGVzLnNob3dSb3dIZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHggKz0gaGVhZGVyQ2VsbFdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjZWxsSGVpZ2h0ID0gcm93SGVpZ2h0O1xuICAgICAgICAgICAgICAgIGZvciAobyA9IHNlbGYuc2Nyb2xsSW5kZXhMZWZ0OyBvIDwgZzsgbyArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBzZWxmLm9yZGVycy5jb2x1bW5zW29dO1xuICAgICAgICAgICAgICAgICAgICB4ICs9IGRyYXdDZWxsKHJkLCByLCBkKShzW2ldLCBpLCBvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHggPiBzZWxmLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkcmF3Um93SGVhZGVyKHJkLCByLCBkKTtcbiAgICAgICAgICAgICAgICAvLyBjZWxsIGhlaWdodCBtaWdodCBoYXZlIGNoYW5nZWQgZHVyaW5nIGRyYXdpbmdcbiAgICAgICAgICAgICAgICBjZWxsSGVpZ2h0ID0gcm93SGVpZ2h0O1xuICAgICAgICAgICAgICAgIHggPSAoc2VsZi5zY3JvbGxCb3guc2Nyb2xsTGVmdCAqIC0xKSArIHNlbGYuc2Nyb2xsUGl4ZWxMZWZ0O1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IGRyYXcgYSB0cmVlIGZvciB0aGUgbmV3IHJvd1xuICAgICAgICAgICAgICAgIHRyZWVHcmlkID0gc2VsZi5jaGlsZEdyaWRzW3JkW3NlbGYudW5pcXVlSWRdXTtcbiAgICAgICAgICAgICAgICBpZiAociAhPT0gc2VsZi5kYXRhLmxlbmd0aCAmJiByb3dPcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyZWVHcmlkLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0cmVlR3JpZC5wYXJlbnROb2RlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0VG9wOiB5ICsgcm93U2Fuc1RyZWVIZWlnaHQgKyBzZWxmLmNhbnZhc09mZnNldFRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldExlZnQ6IHggKyBoZWFkZXJDZWxsV2lkdGggLSAxICsgc2VsZi5jYW52YXNPZmZzZXRMZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0SGVpZ2h0OiB0cmVlSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0V2lkdGg6IHNlbGYud2lkdGggLSBoZWFkZXJDZWxsV2lkdGggLSBzZWxmLnN0eWxlLnNjcm9sbEJhcldpZHRoIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldFBhcmVudDogc2VsZi5pbnRmLnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlOiBzZWxmLmludGYucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBzZWxmLnN0eWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVR5cGU6ICdjYW52YXMtZGF0YWdyaWQtdHJlZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxUb3A6IHNlbGYuc2Nyb2xsQm94LnNjcm9sbFRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbExlZnQ6IHNlbGYuc2Nyb2xsQm94LnNjcm9sbExlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dJbmRleDogclxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnZpc2libGVDZWxscy51bnNoaWZ0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0luZGV4OiB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uSW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB0cmVlR3JpZC5wYXJlbnROb2RlLm9mZnNldFRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHRyZWVHcmlkLnBhcmVudE5vZGUub2Zmc2V0TGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogdHJlZUdyaWQucGFyZW50Tm9kZS5vZmZzZXRIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdHJlZUdyaWQucGFyZW50Tm9kZS5vZmZzZXRXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAndHJlZS1ncmlkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHRyZWVHcmlkLnBhcmVudE5vZGUubm9kZVR5cGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRyZWVHcmlkLmRyYXcoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRyZWVHcmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyZWVHcmlkLnBhcmVudE5vZGUub2Zmc2V0SGVpZ2h0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNlbGYuc2l6ZXMudHJlZXNbcmRbc2VsZi51bmlxdWVJZF1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5hdHRyaWJ1dGVzLnJvd1NlbGVjdGlvbk1vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHNlbGYuYWN0aXZlQ2VsbFxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgc2VsZi5hY3RpdmVDZWxsLnJvd0luZGV4ID09PSByKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY3R4LmxpbmVXaWR0aCA9IHNlbGYuc3R5bGUuYWN0aXZlQ2VsbE92ZXJsYXlCb3JkZXJXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jdHguc3Ryb2tlU3R5bGUgPSBzZWxmLnN0eWxlLmFjdGl2ZUNlbGxPdmVybGF5Qm9yZGVyQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZVJlY3QoMCwgeSwgc2VsZi5nZXRIZWFkZXJXaWR0aCgpLCByb3dIZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB5ICs9IGNlbGxIZWlnaHQgKyBib3JkZXJXaWR0aDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGluaXREcmF3KCkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmF0dHJpYnV0ZXMuc2hvd1BlcmZvcm1hbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYm9yZGVyV2lkdGggPSBzZWxmLnN0eWxlLmNlbGxCb3JkZXJXaWR0aCAqIDI7XG4gICAgICAgICAgICAgICAgc2VsZi52aXNpYmxlUm93cyA9IFtdO1xuICAgICAgICAgICAgICAgIHMgPSBzZWxmLmdldFZpc2libGVTY2hlbWEoKTtcbiAgICAgICAgICAgICAgICBzZWxmLnZpc2libGVDZWxscyA9IFtdO1xuICAgICAgICAgICAgICAgIHNlbGYuY2FudmFzT2Zmc2V0VG9wID0gc2VsZi5pc0NoaWxkR3JpZCA/IHNlbGYucGFyZW50Tm9kZS5vZmZzZXRUb3AgOiAwO1xuICAgICAgICAgICAgICAgIHNlbGYuY2FudmFzT2Zmc2V0TGVmdCA9IHNlbGYuaXNDaGlsZEdyaWQgPyBzZWxmLnBhcmVudE5vZGUub2Zmc2V0TGVmdCA6IDA7XG4gICAgICAgICAgICAgICAgaCA9IHNlbGYuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHcgPSBzZWxmLndpZHRoO1xuICAgICAgICAgICAgICAgIGlmICghc2VsZi5pc0NoaWxkR3JpZCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmN0eC5zY2FsZSh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbywgd2luZG93LmRldmljZVBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGRyYXdCYWNrZ3JvdW5kKCkge1xuICAgICAgICAgICAgICAgIHJhZGl1c1JlY3QoMCwgMCwgdywgaCwgMCk7XG4gICAgICAgICAgICAgICAgc2VsZi5jdHguY2xpcCgpO1xuICAgICAgICAgICAgICAgIHNlbGYuY3R4LmZpbGxTdHlsZSA9IHNlbGYuc3R5bGUuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgICAgIGZpbGxSZWN0KDAsIDAsIHcsIGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZHJhd1Jvd3MoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG8sIG4sIGksIGcgPSBzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB4ID0gKHNlbGYuc2Nyb2xsQm94LnNjcm9sbExlZnQgKiAtMSkgKyBzZWxmLnNjcm9sbFBpeGVsTGVmdDtcbiAgICAgICAgICAgICAgICB5ID0gKHNlbGYuc2Nyb2xsQm94LnNjcm9sbFRvcCAqIC0xKSArIGhlYWRlckNlbGxIZWlnaHQgKyBzZWxmLnNjcm9sbFBpeGVsVG9wO1xuICAgICAgICAgICAgICAgIGZvciAociA9IHNlbGYuc2Nyb2xsSW5kZXhUb3A7IHIgPCBsOyByICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbiA9IHNlbGYub3JkZXJzLnJvd3Nbcl07XG4gICAgICAgICAgICAgICAgICAgIGlmICghZHJhd1JvdyhuLCByKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuYXR0cmlidXRlcy5zaG93TmV3Um93KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmF0dHJpYnV0ZXMuc2hvd1Jvd0hlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gaGVhZGVyQ2VsbFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJvd0hlaWdodCA9IGNlbGxIZWlnaHQgPSBzZWxmLnN0eWxlLmNlbGxIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHJvd09wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChvID0gc2VsZi5zY3JvbGxJbmRleExlZnQ7IG8gPCBnOyBvICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBzZWxmLm9yZGVycy5jb2x1bW5zW29dO1xuICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBkcmF3Q2VsbChzZWxmLm5ld1Jvdywgc2VsZi5kYXRhLmxlbmd0aCwgc2VsZi5kYXRhLmxlbmd0aCkoc1tpXSwgaSwgbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeCA+IHNlbGYud2lkdGggKyBzZWxmLnNjcm9sbEJveC5zY3JvbGxMZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZHJhd1Jvd0hlYWRlcihzZWxmLm5ld1Jvdywgc2VsZi5kYXRhLmxlbmd0aCwgc2VsZi5kYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZHJhd1Jlb3JkZXJNYXJrZXJzKCkge1xuICAgICAgICAgICAgICAgIGlmICghc2VsZi5yZW9yZGVyT2JqZWN0KSB7IHJldHVybjsgfVxuICAgICAgICAgICAgICAgIHZhciBiID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBzZWxmLnJlb3JkZXJPYmplY3QuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHNlbGYucmVvcmRlck9iamVjdC53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHNlbGYucmVvcmRlck9iamVjdC54ICsgc2VsZi5yZW9yZGVyT2JqZWN0LmRyYWdPZmZzZXQueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHNlbGYucmVvcmRlck9iamVjdC55ICsgc2VsZi5yZW9yZGVyT2JqZWN0LmRyYWdPZmZzZXQueVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBtID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlndGg6IGgsXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNlbGYuY3R4LmZpbGxTdHlsZSA9IHNlbGYuc3R5bGUucmVvcmRlck1hcmtlckJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgICAgICBzZWxmLmN0eC5saW5lV2lkdGggPSBzZWxmLnN0eWxlLnJlb3JkZXJNYXJrZXJCb3JkZXJXaWR0aDtcbiAgICAgICAgICAgICAgICBzZWxmLmN0eC5zdHJva2VTdHlsZSA9IHNlbGYuc3R5bGUucmVvcmRlck1hcmtlckJvcmRlckNvbG9yO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmRyYWdNb2RlID09PSAncm93LXJlb3JkZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGIud2lkdGggPSB3O1xuICAgICAgICAgICAgICAgICAgICBiLnggPSAwO1xuICAgICAgICAgICAgICAgICAgICBtLndpZHRoID0gdztcbiAgICAgICAgICAgICAgICAgICAgbS55ID0gc2VsZi5jdXJyZW50Q2VsbC55O1xuICAgICAgICAgICAgICAgICAgICBmaWxsUmVjdChiLngsIGIueSwgYi53aWR0aCwgYi5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBzdHJva2VSZWN0KGIueCwgYi55LCBiLndpZHRoLCBiLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY3R4LmxpbmVXaWR0aCA9IHNlbGYuc3R5bGUucmVvcmRlck1hcmtlckluZGV4Qm9yZGVyV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY3R4LnN0cm9rZVN0eWxlID0gc2VsZi5zdHlsZS5yZW9yZGVyTWFya2VySW5kZXhCb3JkZXJDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuY3VycmVudENlbGwucm93SW5kZXggIT09IHNlbGYucmVvcmRlck9iamVjdC5yb3dJbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIHNlbGYuY3VycmVudENlbGwucm93SW5kZXggLSAxICE9PSBzZWxmLnJlb3JkZXJPYmplY3Qucm93SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEJvcmRlckxpbmUobSwgJ3QnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZi5kcmFnTW9kZSA9PT0gJ2NvbHVtbi1yZW9yZGVyJyAmJiBzZWxmLnJlb3JkZXJPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgYi5oZWlnaHQgPSBoO1xuICAgICAgICAgICAgICAgICAgICBiLnkgPSAwO1xuICAgICAgICAgICAgICAgICAgICBtLmhlaWdodCA9IGg7XG4gICAgICAgICAgICAgICAgICAgIG0ueCA9IHNlbGYuY3VycmVudENlbGwueDtcbiAgICAgICAgICAgICAgICAgICAgZmlsbFJlY3QoYi54LCBiLnksIGIud2lkdGgsIGIuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlUmVjdChiLngsIGIueSwgYi53aWR0aCwgYi5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmN0eC5saW5lV2lkdGggPSBzZWxmLnN0eWxlLnJlb3JkZXJNYXJrZXJJbmRleEJvcmRlcldpZHRoO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmN0eC5zdHJva2VTdHlsZSA9IHNlbGYuc3R5bGUucmVvcmRlck1hcmtlckluZGV4Qm9yZGVyQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmN1cnJlbnRDZWxsLmNvbHVtbkluZGV4ICE9PSBzZWxmLnJlb3JkZXJPYmplY3QuY29sdW1uSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBzZWxmLmN1cnJlbnRDZWxsLmNvbHVtbkluZGV4IC0gMSAhPT0gc2VsZi5yZW9yZGVyT2JqZWN0LmNvbHVtbkluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRCb3JkZXJMaW5lKG0sICdsJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBkcmF3Qm9yZGVyKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuY3R4LmxpbmVXaWR0aCA9IHNlbGYuc3R5bGUuZ3JpZEJvcmRlcldpZHRoO1xuICAgICAgICAgICAgICAgIHNlbGYuY3R4LnN0cm9rZVN0eWxlID0gc2VsZi5zdHlsZS5ncmlkQm9yZGVyQ29sb3I7XG4gICAgICAgICAgICAgICAgc3Ryb2tlUmVjdCgwLCAwLCBzZWxmLndpZHRoLCBzZWxmLmhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBkcmF3RGVidWcoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuYXR0cmlidXRlcy5zaG93UGVyZm9ybWFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jdHguZmlsbFN0eWxlID0gJ2JsYWNrJztcbiAgICAgICAgICAgICAgICAgICAgcCA9IChwZXJmb3JtYW5jZS5ub3coKSAtIHApLnRvRml4ZWQoMikgKyAnbXMnO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmN0eC5mb250ID0gJzIzcHggc2Fucy1zZXJpZic7XG4gICAgICAgICAgICAgICAgICAgIGZpbGxUZXh0KHAsIHcgLSAodyAvIDUpLCBoIC0gKGggLyAxMCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5hdHRyaWJ1dGVzLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY3R4LmZvbnQgPSAnMTRweCBzYW5zLXNlcmlmJztcbiAgICAgICAgICAgICAgICAgICAgcCA9ICgnc2Nyb2xsTGVmdDogJXMsIHNjcm9sbFRvcDogJXMsIHRvcEluZGV4OiAlcywgdG9wUGl4ZWw6ICVzLCBsZWZ0SW5kZXg6ICVzLCBsZWZ0UGl4ZWw6ICVzLCdcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJ1xcbm9mZnNldExlZnQ6ICVzLCBvZmZzZXRUb3A6ICVzLCB3OiAlcywgaDogJXMsIHg6ICVzLCB5OiAlcyxcXG52aXNpYmxlIGVudGl0aWVzOiAlcywgZm9jdXM6ICVzLCBkcmFnTW9kZTogJXMnXG4gICAgICAgICAgICAgICAgICAgICAgICArICdcXG5jb250ZXh0OiAlcycpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgnJXMnLCBzZWxmLnNjcm9sbEJveC5zY3JvbGxMZWZ0KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoJyVzJywgc2VsZi5zY3JvbGxCb3guc2Nyb2xsVG9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoJyVzJywgc2VsZi5zY3JvbGxJbmRleFRvcClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCclcycsIHNlbGYuc2Nyb2xsUGl4ZWxUb3ApXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgnJXMnLCBzZWxmLnNjcm9sbEluZGV4TGVmdClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCclcycsIHNlbGYuc2Nyb2xsUGl4ZWxMZWZ0KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoJyVzJywgc2VsZi5jYW52YXNPZmZzZXRMZWZ0KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoJyVzJywgc2VsZi5jYW52YXNPZmZzZXRUb3ApXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgnJXMnLCBzZWxmLndpZHRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoJyVzJywgc2VsZi5oZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgnJXMnLCBzZWxmLm1vdXNlLngpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgnJXMnLCBzZWxmLm1vdXNlLnkpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgnJXMnLCBzZWxmLnZpc2libGVDZWxscy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgnJXMnLCBzZWxmLmhhc0ZvY3VzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoJyVzJywgc2VsZi5kcmFnTW9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCclcycsIHNlbGYuY3VycmVudENlbGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICgoJyh4OiAlcywgeTogJXMsIG94OiAlcywgb3k6ICVzLCBjb250ZXh0OiAlcywgZHJhZ0NvbnRleHQ6ICVzLCBzdHlsZTogJXMsIHR5cGU6ICVzKScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCclcycsIHNlbGYuY3VycmVudENlbGwuY29sdW1uSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCclcycsIHNlbGYuY3VycmVudENlbGwucm93SW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCclcycsIHNlbGYuY3VycmVudENlbGwuc29ydENvbHVtbkluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgnJXMnLCBzZWxmLmN1cnJlbnRDZWxsLnNvcnRSb3dJbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoJyVzJywgc2VsZi5jdXJyZW50Q2VsbC5jb250ZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgnJXMnLCBzZWxmLmN1cnJlbnRDZWxsLmRyYWdDb250ZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgnJXMnLCBzZWxmLmN1cnJlbnRDZWxsLnN0eWxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgnJXMnLCBzZWxmLmN1cnJlbnRDZWxsLnR5cGUpKSA6ICcnKTtcbiAgICAgICAgICAgICAgICAgICAgcC5zcGxpdCgnXFxuJykuZm9yRWFjaChmdW5jdGlvbiAocywgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY3R4LmZpbGxTdHlsZSA9ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOCknO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbFJlY3QoNzAsIDM5ICsgKGluZGV4ICogMTUpLCBzZWxmLmN0eC5tZWFzdXJlVGV4dChzKS53aWR0aCArIDIwLCAxNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmN0eC5maWxsU3R5bGUgPSAncmdiYSgwLCAwLCAwLCAxKSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsVGV4dChzLCA4MCwgNTIgKyAoaW5kZXggKiAxNSkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmN0eC5zYXZlKCk7XG4gICAgICAgICAgICBpbml0RHJhdygpO1xuICAgICAgICAgICAgZHJhd0JhY2tncm91bmQoKTtcbiAgICAgICAgICAgIGRyYXdSb3dzKCk7XG4gICAgICAgICAgICBkcmF3SGVhZGVyUm93KCk7XG4gICAgICAgICAgICBkcmF3UmVvcmRlck1hcmtlcnMoKTtcbiAgICAgICAgICAgIGRyYXdTY3JvbGxCYXJzKCk7XG4gICAgICAgICAgICBpZiAoY2hlY2tTY3JvbGxIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnJlc2l6ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRyYXdCb3JkZXIoKTtcbiAgICAgICAgICAgIGRyYXdEZWJ1ZygpO1xuICAgICAgICAgICAgc2VsZi5jdHgucmVzdG9yZSgpO1xuICAgICAgICB9O1xuICAgIH07XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2RyYXcuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/*!***********************!*\
  !*** ./lib/events.js ***!
  \***********************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jslint browser: true, unparam: true, todo: true*/\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n    'use strict';\n    return function (self) {\n        self.stopPropagation = function (e) { e.stopPropagation(); };\n        self.addEventListener = function (ev, fn) {\n            self.events[ev] = self.events[ev] || [];\n            self.events[ev].unshift(fn);\n        };\n        self.removeEventListener = function (ev, fn) {\n            (self.events[ev] || []).forEach(function removeEachListener(sfn, idx) {\n                if (fn === sfn) {\n                    self.events[ev].splice(idx, 1);\n                }\n            });\n        };\n        self.dispatchEvent = function (ev, args, context) {\n            args = args || {};\n            context = context || self.intf;\n            var defaultPrevented;\n            function preventDefault() {\n                defaultPrevented = true;\n            }\n            if (!self.events[ev]) { return; }\n            self.events[ev].forEach(function dispatchEachEvent(fn) {\n                args[0].preventDefault = preventDefault;\n                fn.apply(context, args);\n            });\n            return defaultPrevented;\n        };\n        self.resize = function (drawAfterResize) {\n            var cellBorder = self.style.cellBorderWidth * 2,\n                headerCellBorder =  self.style.headerCellBorderWidth * 2,\n                scrollHeight,\n                scrollWidth,\n                headerCellHeight = self.getHeaderCellHeight(),\n                headerCellWidth = self.getHeaderCellWidth(),\n                // TODO: What the hell are these numbers!?  They are probably some value in the style.\n                scrollDragPositionOffsetY = 30,\n                scrollDragPositionOffsetX = 15;\n            if (self.isChildGrid) {\n                self.height = self.parentNode.offsetHeight;\n                self.width = self.parentNode.offsetWidth;\n            } else {\n                self.height = self.parentDOMNode.offsetHeight - self.style.scrollBarBoxMargin;\n                self.width = self.parentDOMNode.offsetWidth - self.style.scrollBarBoxMargin;\n                self.parentNode = self.parentDOMNode;\n                self.canvas.height = self.height * window.devicePixelRatio;\n                self.canvas.width = self.width * window.devicePixelRatio;\n                self.canvas.style.height = self.height + 'px';\n                self.canvas.style.width = self.width + 'px';\n                self.canvasOffsetTop = 0;\n                self.canvasOffsetLeft = 0;\n            }\n            scrollHeight = self.data.reduce(function reduceData(accumulator, row) {\n                return accumulator\n                    + (self.sizes.rows[row[self.uniqueId]] || self.style.cellHeight)\n                    + (self.sizes.trees[row[self.uniqueId]] || 0)\n                    + cellBorder;\n            }, 0) || 0;\n            scrollWidth = self.getVisibleSchema().reduce(function reduceSchema(accumulator, column) {\n                if (column.hidden) { return accumulator; }\n                return accumulator + (self.sizes.columns[column[self.uniqueId]] || column.width || self.style.columnWidth) + cellBorder;\n            }, 0) || 0;\n            if (self.attributes.showNewRow) {\n                scrollHeight += self.style.cellHeight + cellBorder;\n            }\n            self.scrollBox.width = self.width - headerCellWidth;\n            self.scrollBox.height = self.height - headerCellHeight - headerCellBorder;\n            self.scrollBox.top = headerCellHeight + headerCellBorder;\n            self.scrollBox.left = headerCellWidth;\n            self.scrollBox.scrollHeight = scrollHeight + self.style.scrollBarWidth - self.scrollBox.height;\n            self.scrollBox.scrollWidth = scrollWidth + self.style.scrollBarWidth - self.scrollBox.width;\n            self.scrollBox.widthBoxRatio = ((self.scrollBox.width - scrollDragPositionOffsetX)\n                / (self.scrollBox.scrollWidth + self.scrollBox.width - scrollDragPositionOffsetX));\n            self.scrollBox.scrollBoxWidth = self.scrollBox.width\n                * self.scrollBox.widthBoxRatio\n                - self.style.scrollBarWidth;\n            self.scrollBox.heightBoxRatio = ((self.scrollBox.height - scrollDragPositionOffsetY)\n                / (self.scrollBox.scrollHeight + (self.scrollBox.height - scrollDragPositionOffsetY)));\n            self.scrollBox.scrollBoxHeight = self.scrollBox.height\n                * self.scrollBox.heightBoxRatio\n                - self.style.scrollBarWidth;\n            self.scrollBox.scrollBoxWidth = Math.max(self.scrollBox.scrollBoxWidth, self.style.scrollBarBoxMinSize);\n            self.scrollBox.scrollBoxHeight = Math.max(self.scrollBox.scrollBoxHeight, self.style.scrollBarBoxMinSize);\n            self.page = self.visibleRows.length - 3 - self.attributes.pageUpDownOverlap;\n            if (drawAfterResize) {\n                self.draw(true);\n            }\n            self.dispatchEvent('resize', [{}], self.intf);\n            return true;\n        };\n        self.scroll = function (e) {\n            var pos,\n                s = self.getVisibleSchema(),\n                cellBorder = self.style.cellBorderWidth * 2;\n            self.scrollIndexTop = 0;\n            self.scrollPixelTop = 0;\n            self.scrollIndexLeft = 0;\n            self.scrollPixelLeft = 0;\n            while (self.scrollPixelTop < self.scrollBox.scrollTop && self.scrollIndexTop < self.data.length) {\n                self.scrollPixelTop +=\n                    (self.sizes.rows[self.data[self.scrollIndexTop][self.uniqueId]] || self.style.cellHeight)\n                    + (self.sizes.trees[self.data[self.scrollIndexTop][self.uniqueId]] || 0)\n                    + cellBorder;\n                self.scrollIndexTop += 1;\n            }\n            while (self.scrollPixelLeft < self.scrollBox.scrollLeft && self.scrollIndexLeft < s.length) {\n                self.scrollPixelLeft +=\n                    (self.sizes.columns[s[self.scrollIndexLeft][self.uniqueId]] || s[self.scrollIndexLeft].width);\n                self.scrollIndexLeft += 1;\n            }\n            if (self.data.length > 0) {\n                self.scrollIndexLeft = Math.max(self.scrollIndexLeft - 1, 0);\n                self.scrollPixelLeft = Math.max(self.scrollPixelLeft\n                    - (self.sizes.columns[s[self.scrollIndexLeft][self.uniqueId]] || s[self.scrollIndexLeft].width), 0);\n                self.scrollIndexTop = Math.max(self.scrollIndexTop - 1, 0);\n                self.scrollPixelTop = Math.max(self.scrollPixelTop\n                    - (self.sizes.rows[self.data[self.scrollIndexTop][self.uniqueId]] || self.style.cellHeight)\n                    - (self.sizes.trees[self.data[self.scrollIndexTop][self.uniqueId]] || 0), 0);\n            }\n            self.ellipsisCache = {};\n            self.draw(true);\n            if (self.input) {\n                pos = self.position(self.parentNode, true);\n                self.input.style.top = pos.top + self.scrollEdit.inputTop\n                    + (self.scrollEdit.scrollTop - self.scrollBox.scrollTop) + 'px';\n                self.input.style.left = pos.left + self.scrollEdit.inputLeft\n                    + (self.scrollEdit.scrollLeft - self.scrollBox.scrollLeft) + 'px';\n                self.clipElement(self.input);\n            }\n            self.dispatchEvent('scroll', [{top: self.scrollBox.scrollTop, left: self.scrollBox.scrollLeft }], self.intf);\n        };\n        self.mousemove = function (e) {\n            if (self.contextMenu || self.input) {\n                return;\n            }\n            self.mouse = self.getLayerPos(e);\n            var ctrl = (e.controlKey || e.metaKey || self.attributes.persistantSelectionMode),\n                i,\n                s = self.getSchema(),\n                dragBounds,\n                sBounds,\n                x = self.mouse.x,\n                y = self.mouse.y,\n                o,\n                delta;\n            clearTimeout(self.scrollTimer);\n            if (self.dispatchEvent('mousemove', [e, o], self.intf)) {\n                return;\n            }\n            if (!self.isInGrid({x: x, y: y})) {\n                self.hasFocus = false;\n            }\n            o = self.getCellAt(x, y);\n            if (o && self.currentCell && (self.currentCell.rowIndex !== o.rowIndex\n                    || self.currentCell.columnIndex !== o.columnIndex)) {\n                self.cellBoundaryCrossed = true;\n                self.dispatchEvent('cellmouseover', [e, o], self.intf);\n                self.dispatchEvent('cellmouseout', [e, self.currentCell], self.intf);\n            }\n            self.currentCell = o;\n            if (!self.hasFocus) {\n                return;\n            }\n            self.hovers = {};\n            if (!self.draggingItem\n                    && o\n                    && self.scrollModes.indexOf(o.context) === -1) {\n                self.dragItem = o;\n                self.dragMode = o.dragContext;\n                self.canvas.style.cursor = o.context;\n                if (o.context === 'cell' && o.data) {\n                    self.canvas.style.cursor = 'pointer';\n                    self.hovers[o.data[self.uniqueId]] = [o.rowIndex];\n                }\n                if ((self.selecting || self.reorderObject)\n                        && o.context === 'cell'\n                        && o.data) {\n                    sBounds = self.getSelectionBounds();\n                    delta = {\n                        x: Math.abs(self.dragStart.x - x),\n                        y: Math.abs(self.dragStart.y - y),\n                    };\n                    if (self.dragStartObject.columnIndex !== -1 && e.shiftKey) {\n                        self.dragStartObject = {\n                            rowIndex: self.activeCell.rowIndex,\n                            columnIndex: self.activeCell.columnIndex\n                        };\n                    }\n                    dragBounds = {\n                        top: Math.min(self.dragStartObject.rowIndex, o.rowIndex),\n                        left: Math.min(self.dragStartObject.columnIndex, o.columnIndex),\n                        bottom: Math.max(self.dragStartObject.rowIndex, o.rowIndex),\n                        right: Math.max(self.dragStartObject.columnIndex, o.columnIndex)\n                    };\n                    if (self.dragStartObject.columnIndex === -1) {\n                        dragBounds.left = -1;\n                        dragBounds.right = s.length - 1;\n                        dragBounds.top = Math.min(sBounds.top, o.rowIndex);\n                        dragBounds.bottom = Math.max(sBounds.bottom, o.rowIndex);\n                    }\n                    if (self.dragStartObject.rowIndex !== o.rowIndex\n                                || self.dragStartObject.columnIndex !== o.columnIndex) {\n                        self.ignoreNextClick = true;\n                    }\n                    if (self.cellBoundaryCrossed || (delta.x === 0 && delta.y === 0) || self.attributes.rowSelectionMode) {\n                        if (self.attributes.rowSelectionMode || self.dragStartObject.columnIndex === -1) {\n                            self.selectRow(o.rowIndex, ctrl, true);\n                        } else {\n                            if (!self.dragAddToSelection && o.rowIndex) {\n                                if (self.selections[o.rowIndex] && self.selections[o.rowIndex].indexOf(o.columnIndex) !== -1) {\n                                    self.selections[o.rowIndex].splice(self.selections[o.rowIndex].indexOf(o.columnIndex), 1);\n                                }\n                            } else {\n                                self.selections[o.rowIndex] = self.selections[o.rowIndex] || [];\n                                if (self.selections[o.rowIndex].indexOf(o.columnIndex) === -1) {\n                                    self.selections[o.rowIndex].push(o.columnIndex);\n                                }\n                            }\n                        }\n                    }\n                    if ((!self.selectionBounds || (dragBounds.top !== self.selectionBounds.top\n                            || dragBounds.left !== self.selectionBounds.left\n                            || dragBounds.bottom !== self.selectionBounds.bottom\n                            || dragBounds.right !== self.selectionBounds.right)) && !ctrl) {\n                        self.selections = [];\n                        sBounds = dragBounds;\n                        if (self.attributes.rowSelectionMode) {\n                            for (i = sBounds.top; i <= sBounds.bottom; i += 1) {\n                                self.selectRow(i, true, true);\n                            }\n                        } else {\n                            self.selectArea(sBounds, true);\n                        }\n                    }\n                    self.autoScrollZone(e, x, y, ctrl);\n                }\n            }\n            self.cellBoundaryCrossed = false;\n            self.draw(true);\n        };\n        /**\n         * Ends editing, optionally aborting the edit.\n         * @memberof canvasDataGrid#\n         * @method\n         * @param {boolean} abort When true, abort the edit.\n         */\n        self.endEdit = function (abort) {\n            var cell = self.input.editCell,\n                y = cell.rowIndex;\n            function abortEdit() {\n                abort = true;\n            }\n            if (self.dispatchEvent('beforeendedit', [{}, cell, self.input.value, cell.value,\n                    abortEdit, self.input], self.intf)) { return false; }\n            if (self.input.value !== cell.value && !abort) {\n                self.changes[y] = self.changes[y] || {};\n                self.changes[y][cell.header.name] = self.input.value;\n                cell.data[cell.header.name] = self.input.value;\n                if (y === self.data.length) {\n                    if (self.dispatchEvent('newrow', [self.input.value, cell.value,\n                            abort, cell, self.input], self.intf)) { return false; }\n                    self.uId += 1;\n                    self.addRow(cell.data);\n                    self.createNewRowData();\n                }\n                self.draw(true);\n            }\n            document.body.removeChild(self.input);\n            self.controlInput.focus();\n            self.dispatchEvent('endedit', [{}, cell, self.input.value, abort, self.input], self.intf);\n            self.input = undefined;\n            return true;\n        };\n        /**\n         * Begins editing at cell x, row y.\n         * @memberof canvasDataGrid#\n         * @method\n         * @param {number} x The column index of the cell to edit.\n         * @param {number} y The row index of the cell to edit.\n         */\n        self.beginEditAt = function (x, y) {\n            if (!self.attributes.editable) { return; }\n            var top, left, cell, s = self.getVisibleSchema();\n            cell = self.visibleCells.filter(function (vCell) {\n                return vCell.columnIndex === x && vCell.rowIndex === y;\n            })[0];\n            if (self.dispatchEvent('beforebeginedit', [{}, cell], self.intf)) { return false; }\n            self.scrollIntoView(x, y);\n            self.setActiveCell(x, y);\n            function postDraw() {\n                var pos = self.position(self.parentNode, true);\n                cell = self.visibleCells.filter(function (vCell) {\n                    return vCell.columnIndex === x && vCell.rowIndex === y;\n                })[0];\n                top = cell.y + self.style.cellBorderWidth;\n                left = cell.x + self.style.cellBorderWidth;\n                self.scrollEdit = {\n                    scrollTop: self.scrollBox.scrollTop,\n                    scrollLeft: self.scrollBox.scrollLeft,\n                    inputTop: top,\n                    inputLeft: left\n                };\n                self.input = document.createElement(self.attributes.multiLine ? 'textarea' : 'input');\n                document.body.appendChild(self.input);\n                self.input.className = 'canvas-datagrid-edit-input';\n                self.input.style.position = 'absolute';\n                self.input.style.top = pos.top - 1 + top + 'px';\n                self.input.style.left = pos.left - 1 + left + 'px';\n                self.input.style.height = cell.height - (self.style.cellBorderWidth * 2) + 'px';\n                self.input.style.width = cell.width - (self.style.cellBorderWidth * 2)\n                    - self.style.cellPaddingLeft + 'px';\n                self.input.style.zIndex = '2';\n                self.input.value = cell.value;\n                self.input.editCell = cell;\n                self.clipElement(self.input);\n                self.input.focus();\n                self.input.addEventListener('click', self.stopPropagation);\n                self.input.addEventListener('dblclick', self.stopPropagation);\n                self.input.addEventListener('mouseup', self.stopPropagation);\n                self.input.addEventListener('mousedown', self.stopPropagation);\n                self.input.addEventListener('keydown', function (e) {\n                    var nx = cell.columnIndex,\n                        ny = cell.rowIndex;\n                    // esc\n                    if (e.keyCode === 27) {\n                        self.endEdit(true);\n                        self.draw(true);\n                    // enter\n                    } else if (e.keyCode === 13) {\n                        self.endEdit();\n                        self.draw(true);\n                    } else if (e.keyCode === 9) {\n                        e.preventDefault();\n                        if (!self.endEdit()) {\n                            return;\n                        }\n                        if (e.shiftKey) {\n                            nx -= 1;\n                        } else {\n                            nx += 1;\n                        }\n                        if (nx < 0) {\n                            nx = s.length - 1;\n                            ny -= 1;\n                        }\n                        if (nx > s.length - 1) {\n                            nx = 0;\n                            ny += 1;\n                        }\n                        if (ny < 0) {\n                            ny = self.data.length - 1;\n                        }\n                        if (ny > self.data.length - 1) {\n                            ny = 0;\n                        }\n                        self.beginEditAt(nx, ny);\n                    }\n                });\n            }\n            requestAnimationFrame(postDraw);\n            self.dispatchEvent('beginedit', [cell, self.input], self.intf);\n        };\n        self.click = function (e) {\n            var i,\n                selectionChanged,\n                ctrl = (e.controlKey || e.metaKey || self.attributes.persistantSelectionMode),\n                pos = self.getLayerPos(e);\n            self.currentCell = self.getCellAt(pos.x, pos.y);\n            if (self.currentCell.grid !== undefined) {\n                return;\n            }\n            function checkSelectionChange() {\n                if (!selectionChanged) { return; }\n                self.dispatchEvent('selectionchanged',\n                    [self.getSelectedData(), self.selections, self.selectionBounds], self.intf);\n            }\n            if (self.input) {\n                self.endEdit();\n            }\n            if (self.ignoreNextClick) {\n                self.ignoreNextClick = false;\n                return;\n            }\n            i = self.currentCell;\n            if (self.dispatchEvent('click', [e, self.currentCell], self.intf)) { return; }\n            if (!self.hasFocus) {\n                return;\n            }\n            if (self.currentCell.context === 'cell') {\n                if (self.currentCell.style === 'cornerCell') {\n                    self.order(self.uniqueId, 'asc');\n                    self.setFilter();\n                    checkSelectionChange();\n                    return;\n                }\n                if (self.currentCell.style === 'headerCell') {\n                    if (self.orderBy === i.header.name) {\n                        self.orderDirection = self.orderDirection === 'asc' ? 'desc' : 'asc';\n                    } else {\n                        self.orderDirection = 'asc';\n                    }\n                    self.order(i.header.name, self.orderDirection);\n                    checkSelectionChange();\n                    return;\n                }\n                if (['rowHeaderCell', 'headerCell'].indexOf(self.currentCell.style) === -1 && !ctrl) {\n                    self.setActiveCell(i.columnIndex, i.rowIndex);\n                }\n                self.selections[i.rowIndex] = self.selections[i.rowIndex] || [];\n                if ((self.attributes.rowSelectionMode || self.currentCell.style === 'rowHeaderCell')) {\n                    if (self.currentCell.style === 'rowHeaderCell'\n                            && self.attributes.tree && pos.x > 0\n                            && pos.x - self.currentCell.x < self.style.treeArrowWidth\n                            + self.style.treeArrowMarginLeft\n                            + self.style.treeArrowMarginRight + self.style.treeArrowClickRadius\n                            && pos.y - self.currentCell.y < self.style.treeArrowHeight\n                            + self.style.treeArrowMarginTop + self.style.treeArrowClickRadius\n                            && pos.y > 0) {\n                        self.toggleTree(i.rowIndex);\n                        return;\n                    }\n                    selectionChanged = true;\n                    self.selectRow(i.rowIndex, ctrl, true);\n                }\n                if (e.shiftKey && !ctrl) {\n                    self.selectionBounds = self.getSelectionBounds();\n                    self.selectArea(undefined, false);\n                }\n            }\n            checkSelectionChange();\n            self.draw(true);\n        };\n        self.dragResizeColumn = function (e) {\n            var pos, x, y;\n            pos = self.getLayerPos(e);\n            x = self.resizingStartingWidth + pos.x - self.dragStart.x;\n            y = self.resizingStartingHeight + pos.y - self.dragStart.y;\n            if (x < self.style.minColumnWidth) {\n                x = self.style.minColumnWidth;\n            }\n            if (y < self.style.minRowHeight) {\n                y = self.style.minRowHeight;\n            }\n            if (self.dispatchEvent('resizecolumn', [{}, x, y, self.draggingItem], self.intf)) { return false; }\n            if (self.scrollBox.scrollLeft > self.scrollBox.scrollWidth - self.attributes.resizeScrollZone\n                    && self.dragMode === 'ew-resize') {\n                self.resize(true);\n                self.scrollBox.scrollLeft += x;\n            }\n            if (self.dragMode === 'ew-resize') {\n                self.sizes.columns[self.draggingItem.header.style === 'rowHeaderCell'\n                       ? 'cornerCell' : self.draggingItem.header[self.uniqueId]] = x;\n                if (['rowHeaderCell', 'cornerCell'].indexOf(self.draggingItem.header.style) !== -1) {\n                    self.resize(true);\n                }\n                self.resizeChildGrids();\n                return;\n            }\n            if (self.dragMode === 'ns-resize') {\n                if (self.draggingItem.rowOpen) {\n                    self.sizes.trees[self.draggingItem.data[self.uniqueId]] = y;\n                } else if (self.attributes.globalRowResize) {\n                    self.style.cellHeight = y;\n                } else {\n                    self.sizes.rows[self.draggingItem.data[self.uniqueId]] = y;\n                }\n                self.dispatchEvent('resizerow', [y], self.intf);\n                self.resizeChildGrids();\n                return;\n            }\n            self.ellipsisCache = {};\n        };\n        self.stopDragResize = function () {\n            self.resize();\n            document.body.removeEventListener('mousemove', self.dragResizeColumn, false);\n            document.body.removeEventListener('mouseup', self.stopDragResize, false);\n            self.setStorageData();\n            self.draw(true);\n            self.ignoreNextClick = true;\n        };\n        self.scrollGrid = function (e) {\n            var pos = self.getLayerPos(e);\n            self.scrollMode = self.getCellAt(pos.x, pos.y).context;\n            if (self.scrollMode === 'horizontal-scroll-box' && self.scrollStartMode !== 'horizontal-scroll-box') {\n                self.scrollStartMode = 'horizontal-scroll-box';\n                self.dragStart = pos;\n                self.scrollStart.left = self.scrollBox.scrollLeft;\n                clearTimeout(self.scrollTimer);\n                return;\n            }\n            if (self.scrollMode === 'vertical-scroll-box' && self.scrollStartMode !== 'vertical-scroll-box') {\n                self.scrollStartMode = 'vertical-scroll-box';\n                self.dragStart = pos;\n                self.scrollStart.top = self.scrollBox.scrollTop;\n                clearTimeout(self.scrollTimer);\n                return;\n            }\n            if (self.scrollStartMode === 'vertical-scroll-box'\n                    && self.scrollMode !== 'vertical-scroll-box') {\n                self.scrollMode = 'vertical-scroll-box';\n            }\n            if (self.scrollStartMode === 'horizontal-scroll-box'\n                    && self.scrollMode !== 'horizontal-scroll-box') {\n                self.scrollMode = 'horizontal-scroll-box';\n            }\n            clearTimeout(self.scrollTimer);\n            if (self.scrollModes.indexOf(self.scrollMode) === -1) {\n                return;\n            }\n            if (self.scrollMode === 'vertical-scroll-box') {\n                self.scrollBox.scrollTop = self.scrollStart.top + ((pos.y - self.dragStart.y)\n                    / self.scrollBox.heightBoxRatio);\n            } else if (self.scrollMode === 'vertical-scroll-top') {\n                self.scrollBox.scrollTop -= (self.page * self.style.cellHeight);\n                self.scrollTimer = setTimeout(self.scrollGrid, self.attributes.scrollRepeatRate, e);\n            } else if (self.scrollMode === 'vertical-scroll-bottom') {\n                self.scrollBox.scrollTop += (self.page * self.style.cellHeight);\n                self.scrollTimer = setTimeout(self.scrollGrid, self.attributes.scrollRepeatRate, e);\n            }\n            if (self.scrollMode === 'horizontal-scroll-box') {\n                self.scrollBox.scrollLeft = self.scrollStart.left + ((pos.x - self.dragStart.x)\n                    / self.scrollBox.widthBoxRatio);\n            } else if (self.scrollMode === 'horizontal-scroll-right') {\n                self.scrollBox.scrollLeft += self.attributes.selectionScrollIncrement;\n                self.scrollTimer = setTimeout(self.scrollGrid, self.attributes.scrollRepeatRate, e);\n            } else if (self.scrollMode === 'horizontal-scroll-left') {\n                self.scrollBox.scrollLeft -= self.attributes.selectionScrollIncrement;\n                self.scrollTimer = setTimeout(self.scrollGrid, self.attributes.scrollRepeatRate, e);\n            }\n        };\n        self.stopScrollGrid = function () {\n            clearTimeout(self.scrollTimer);\n            document.body.removeEventListener('mousemove', self.scrollGrid, false);\n        };\n        self.dragReorder = function (e) {\n            var pos, x, y;\n            pos = self.getLayerPos(e);\n            x = pos.x - self.dragStart.x;\n            y = pos.y - self.dragStart.y;\n            if (!self.attributes.allowColumnReordering && self.dragMode === 'column-reorder') {\n                return;\n            }\n            if (!self.attributes.allowRowReordering && self.dragMode === 'row-reorder') {\n                return;\n            }\n            if (self.dispatchEvent('reordering', [e, self.dragStartObject, self.currentCell, self.dragMode], self.intf)) {\n                return;\n            }\n            if (Math.abs(x) > self.attributes.reorderDeadZone || Math.abs(y) > self.attributes.reorderDeadZone) {\n                self.reorderObject = self.dragStartObject;\n                self.reorderTarget = self.currentCell;\n                self.reorderObject.dragOffset = {\n                    x: x,\n                    y: y\n                };\n                self.autoScrollZone(e, pos.x, pos.x, false);\n            }\n        };\n        self.stopDragReorder = function (e) {\n            var cr = {\n                    'row-reorder': self.orders.rows,\n                    'column-reorder': self.orders.columns\n                },\n                i = {\n                    'row-reorder': 'rowIndex',\n                    'column-reorder': 'columnIndex'\n                }[self.dragMode];\n            document.body.removeEventListener('mousemove', self.dragReorder, false);\n            document.body.removeEventListener('mouseup', self.stopDragReorder, false);\n            if (self.reorderObject\n                    && self.reorderTarget) {\n                self.ignoreNextClick = true;\n                if (self.reorderObject[i] !== self.reorderTarget[i]\n                        && !self.dispatchEvent('reorder', [e, self.reorderObject, self.reorderTarget, self.dragMode], self.intf)) {\n                    cr[self.dragMode].splice(cr[self.dragMode].indexOf(self.reorderObject[i]), 1);\n                    cr[self.dragMode].splice(cr[self.dragMode].indexOf(self.reorderTarget[i]), 0, self.reorderObject[i]);\n                    self.setStorageData();\n                }\n            }\n            self.reorderObject = undefined;\n            self.reorderTarget = undefined;\n            self.draw(true);\n        };\n        self.mousedown = function (e) {\n            if (self.dispatchEvent('mousedown', [e, self.currentCell], self.intf)) { return; }\n            if (!self.hasFocus) {\n                return;\n            }\n            if (e.button === 2 || self.input) { return; }\n            var ctrl = (e.controlKey || e.metaKey);\n            self.dragStart = self.getLayerPos(e);\n            self.scrollStart = {\n                left: self.scrollBox.scrollLeft,\n                top: self.scrollBox.scrollTop\n            };\n            self.dragStartObject = self.getCellAt(self.dragStart.x, self.dragStart.y);\n            self.dragAddToSelection = !self.dragStartObject.selected;\n            if (!ctrl && !e.shiftKey && !/(vertical|horizontal)-scroll-(bar|box)/\n                    .test(self.dragStartObject.context)) {\n                self.selections = [];\n            }\n            if (self.dragStartObject.isGrid) {\n                return;\n            }\n            if (self.scrollModes.indexOf(self.dragStartObject.context) !== -1) {\n                self.scrollMode = self.dragStartObject.context;\n                self.scrollStartMode = self.dragStartObject.context;\n                self.scrollGrid(e);\n                document.body.addEventListener('mousemove', self.scrollGrid, false);\n                document.body.addEventListener('mouseup', self.stopScrollGrid, false);\n                self.ignoreNextClick = true;\n                return;\n            }\n            if (self.dragMode === 'cell') {\n                self.selecting = true;\n                if (self.attributes.rowSelectionMode) {\n                    self.selectRow(self.dragStartObject.rowIndex, ctrl, true);\n                }\n                return self.mousemove(e);\n            }\n            if (['ns-resize', 'ew-resize'].indexOf(self.dragMode) !== -1) {\n                self.draggingItem = self.dragItem;\n                if (self.draggingItem.rowOpen) {\n                    self.resizingStartingHeight = self.sizes.trees[self.draggingItem.data[self.uniqueId]];\n                } else {\n                    self.resizingStartingHeight = self.sizes.rows[self.draggingItem.data[self.uniqueId]] || self.style.cellHeight;\n                }\n                self.resizingStartingWidth = self.sizes.columns[self.draggingItem.header.style === 'rowHeaderCell'\n                       ? 'cornerCell' : self.draggingItem.header[self.uniqueId]] || self.draggingItem.header.width;\n                document.body.addEventListener('mousemove', self.dragResizeColumn, false);\n                document.body.addEventListener('mouseup', self.stopDragResize, false);\n            }\n            if (['row-reorder', 'column-reorder'].indexOf(self.dragMode) !== -1) {\n                self.draggingItem = self.dragItem;\n                document.body.addEventListener('mousemove', self.dragReorder, false);\n                document.body.addEventListener('mouseup', self.stopDragReorder, false);\n            }\n        };\n        self.mouseup = function (e) {\n            clearTimeout(self.scrollTimer);\n            self.cellBoundaryCrossed = true;\n            self.dispatchEvent('mouseup', [e, self.currentCell], self.intf);\n            if (!self.hasFocus) {\n                return;\n            }\n            if (self.currentCell && self.currentCell.grid !== undefined) {\n                return;\n            }\n            if (self.ontextMenu || self.input) { return; }\n            self.selecting = undefined;\n            self.draggingItem = undefined;\n            if (self.dragStart && self.isInGrid(self.dragStart)) {\n                self.controlInput.focus();\n            }\n            self.dragStartObject = undefined;\n            e.preventDefault();\n        };\n        self.keydown = function (e) {\n            var i,\n                x = self.activeCell.columnIndex,\n                y = self.activeCell.rowIndex,\n                ctrl = (e.controlKey || e.metaKey),\n                last = self.data.length - 1,\n                cols = self.getVisibleSchema().length - 1;\n            if (self.dispatchEvent('keydown', [e, self.currentCell], self.intf)) { return; }\n            if (!self.hasFocus) {\n                return;\n            }\n            self.page = self.visibleRows.length - 3 - self.attributes.pageUpDownOverlap;\n            if (self.attributes.showNewRow) {\n                last += 1;\n            }\n            if (e.keyCode === 'Tab') {\n                e.preventDefault();\n            }\n            //ArrowDown\n            if (e.keyCode === 40) {\n                y += 1;\n            //ArrowUp\n            } else if (e.keyCode === 38) {\n                y -= 1;\n            //ArrowLeft Tab\n            } else if (e.keyCode === 37 || (e.shiftKey && e.keyCode === 9)) {\n                x -= 1;\n            //ArrowRight Tab\n            } else if (e.keyCode === 39 || (!e.shiftKey && e.keyCode === 9)) {\n                x += 1;\n            //PageUp\n            } else if (e.keyCode === 33) {\n                y -= self.page;\n                e.preventDefault();\n            //PageDown\n            } else if (e.keyCode === 34) {\n                y += self.page;\n                e.preventDefault();\n            //Home ArrowUp\n            } else if (e.keyCode === 36 || (ctrl && e.keyCode === 38)) {\n                y = 0;\n            //End ArrowDown\n            } else if (e.keyCode === 35 || (ctrl && e.keyCode === 40)) {\n                y = self.data.length - 1;\n            //ArrowRight\n            } else if (ctrl && e.keyCode === 39) {\n                x = cols;\n            //ArrowLeft\n            } else if (ctrl && e.keyCode === 37) {\n                x = 0;\n            }\n            //Enter\n            if (e.keyCode === 13) {\n                return self.beginEditAt(x, y);\n            }\n            //Space\n            if (e.keyCode === 32) {\n                self.selections = [];\n                self.selections[Math.max(y, 0)] = [];\n                self.selections[Math.max(y, 0)].push(x);\n                self.selectionBounds = self.getSelectionBounds();\n                if (self.attributes.rowSelectionMode) {\n                    for (i = self.selectionBounds.top; i <= self.selectionBounds.bottom; i += 1) {\n                        self.selectRow(i, ctrl, true);\n                    }\n                } else {\n                    self.selectArea(undefined, ctrl);\n                }\n                e.preventDefault();\n                self.draw(true);\n                return;\n            }\n            if (x < 0) {\n                x = 0;\n            }\n            if (y > last) {\n                y = last;\n            }\n            if (y < 0) {\n                y = 0;\n            }\n            if (x > cols) {\n                x = cols;\n            }\n            // Arrows\n            if (e.shiftKey && [37, 38, 39, 40].indexOf(e.keyCode) !== -1) {\n                self.selections[Math.max(y, 0)] = self.selections[Math.max(y, 0)] || [];\n                self.selections[Math.max(y, 0)].push(x);\n                self.selectionBounds = self.getSelectionBounds();\n                self.selectArea(undefined, ctrl);\n                self.draw(true);\n            }\n            if (x !== self.activeCell.columnIndex || y !== self.activeCell.rowIndex) {\n                self.scrollIntoView(x !== self.activeCell.columnIndex ? x : undefined, y !== self.activeCell.rowIndex ? y : undefined);\n                self.setActiveCell(x, y);\n                if (!e.shiftKey && self.attributes.selectionFollowsActiveCell) {\n                    if (!ctrl) {\n                        self.selections = [];\n                    }\n                    self.selections[y] = self.selections[y] || [];\n                    self.selections[y].push(x);\n                    self.dispatchEvent('selectionchanged', [self.getSelectedData(), self.selections, self.selectionBounds], self.intf);\n                }\n                self.draw(true);\n            }\n        };\n        self.keyup = function (e) {\n            if (self.dispatchEvent('keyup', [e, self.currentCell], self.intf)) { return; }\n            if (!self.hasFocus) {\n                return;\n            }\n            self.controlInput.value = '';\n        };\n        self.keypress = function (e) {\n            if (!self.hasFocus) {\n                return;\n            }\n            if (self.dispatchEvent('keypress', [e, self.currentCell], self.intf)) { return; }\n        };\n        self.dblclick = function (e) {\n            if (self.dispatchEvent('dblclick', [e, self.currentCell], self.intf)) { return; }\n            if (!self.hasFocus) {\n                return;\n            }\n            if (self.currentCell.context === 'ew-resize'\n                    && self.currentCell.style === 'headerCell') {\n                self.fitColumnToValues(self.currentCell.header.name);\n            } else if (self.currentCell.context === 'ew-resize'\n                    && self.currentCell.style === 'cornerCell') {\n                self.autosize();\n            } else if (['cell', 'activeCell'].indexOf(self.currentCell.style) !== -1) {\n                self.beginEditAt(self.currentCell.columnIndex, self.currentCell.rowIndex);\n            }\n        };\n        self.scrollWheel = function (e) {\n            if (self.dispatchEvent('mousewheel', [e, self.ctx], self.intf)) {\n                return;\n            }\n            var l = self.scrollBox.scrollLeft,\n                t = self.scrollBox.scrollTop;\n            if (self.hasFocus) {\n                self.scrollBox.scrollTop -= e.wheelDeltaY;\n                self.scrollBox.scrollLeft -= e.wheelDeltaX;\n            }\n            if (t !== self.scrollBox.scrollTop || l !== self.scrollBox.scrollLeft) {\n                e.preventDefault();\n            }\n        };\n        self.copy = function (e) {\n            var rows = [], sData = self.getSelectedData();\n            sData.forEach(function (row) {\n                if (row) {\n                    var r = [];\n                    Object.keys(row).forEach(function (key) {\n                        r.push(row[key]);\n                    });\n                    r.join(',');\n                    rows.push(r);\n                }\n            });\n            e.clipboardData.setData('text/plain', rows.join('\\n'));\n            e.preventDefault();\n        };\n        return;\n    };\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi9ldmVudHMuanM/NWNkZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmpzbGludCBicm93c2VyOiB0cnVlLCB1bnBhcmFtOiB0cnVlLCB0b2RvOiB0cnVlKi9cbi8qZ2xvYmFscyBkZWZpbmU6IHRydWUsIE11dGF0aW9uT2JzZXJ2ZXI6IGZhbHNlLCByZXF1ZXN0QW5pbWF0aW9uRnJhbWU6IGZhbHNlLCBwZXJmb3JtYW5jZTogZmFsc2UsIGJ0b2E6IGZhbHNlKi9cbmRlZmluZShbXSwgZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNlbGYpIHtcbiAgICAgICAgc2VsZi5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbiAoZSkgeyBlLnN0b3BQcm9wYWdhdGlvbigpOyB9O1xuICAgICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gICAgICAgICAgICBzZWxmLmV2ZW50c1tldl0gPSBzZWxmLmV2ZW50c1tldl0gfHwgW107XG4gICAgICAgICAgICBzZWxmLmV2ZW50c1tldl0udW5zaGlmdChmbik7XG4gICAgICAgIH07XG4gICAgICAgIHNlbGYucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgICAgICAgICAgIChzZWxmLmV2ZW50c1tldl0gfHwgW10pLmZvckVhY2goZnVuY3Rpb24gcmVtb3ZlRWFjaExpc3RlbmVyKHNmbiwgaWR4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGZuID09PSBzZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5ldmVudHNbZXZdLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiAoZXYsIGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGFyZ3MgPSBhcmdzIHx8IHt9O1xuICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgc2VsZi5pbnRmO1xuICAgICAgICAgICAgdmFyIGRlZmF1bHRQcmV2ZW50ZWQ7XG4gICAgICAgICAgICBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2VsZi5ldmVudHNbZXZdKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgc2VsZi5ldmVudHNbZXZdLmZvckVhY2goZnVuY3Rpb24gZGlzcGF0Y2hFYWNoRXZlbnQoZm4pIHtcbiAgICAgICAgICAgICAgICBhcmdzWzBdLnByZXZlbnREZWZhdWx0ID0gcHJldmVudERlZmF1bHQ7XG4gICAgICAgICAgICAgICAgZm4uYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0UHJldmVudGVkO1xuICAgICAgICB9O1xuICAgICAgICBzZWxmLnJlc2l6ZSA9IGZ1bmN0aW9uIChkcmF3QWZ0ZXJSZXNpemUpIHtcbiAgICAgICAgICAgIHZhciBjZWxsQm9yZGVyID0gc2VsZi5zdHlsZS5jZWxsQm9yZGVyV2lkdGggKiAyLFxuICAgICAgICAgICAgICAgIGhlYWRlckNlbGxCb3JkZXIgPSAgc2VsZi5zdHlsZS5oZWFkZXJDZWxsQm9yZGVyV2lkdGggKiAyLFxuICAgICAgICAgICAgICAgIHNjcm9sbEhlaWdodCxcbiAgICAgICAgICAgICAgICBzY3JvbGxXaWR0aCxcbiAgICAgICAgICAgICAgICBoZWFkZXJDZWxsSGVpZ2h0ID0gc2VsZi5nZXRIZWFkZXJDZWxsSGVpZ2h0KCksXG4gICAgICAgICAgICAgICAgaGVhZGVyQ2VsbFdpZHRoID0gc2VsZi5nZXRIZWFkZXJDZWxsV2lkdGgoKSxcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBXaGF0IHRoZSBoZWxsIGFyZSB0aGVzZSBudW1iZXJzIT8gIFRoZXkgYXJlIHByb2JhYmx5IHNvbWUgdmFsdWUgaW4gdGhlIHN0eWxlLlxuICAgICAgICAgICAgICAgIHNjcm9sbERyYWdQb3NpdGlvbk9mZnNldFkgPSAzMCxcbiAgICAgICAgICAgICAgICBzY3JvbGxEcmFnUG9zaXRpb25PZmZzZXRYID0gMTU7XG4gICAgICAgICAgICBpZiAoc2VsZi5pc0NoaWxkR3JpZCkge1xuICAgICAgICAgICAgICAgIHNlbGYuaGVpZ2h0ID0gc2VsZi5wYXJlbnROb2RlLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgICBzZWxmLndpZHRoID0gc2VsZi5wYXJlbnROb2RlLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLmhlaWdodCA9IHNlbGYucGFyZW50RE9NTm9kZS5vZmZzZXRIZWlnaHQgLSBzZWxmLnN0eWxlLnNjcm9sbEJhckJveE1hcmdpbjtcbiAgICAgICAgICAgICAgICBzZWxmLndpZHRoID0gc2VsZi5wYXJlbnRET01Ob2RlLm9mZnNldFdpZHRoIC0gc2VsZi5zdHlsZS5zY3JvbGxCYXJCb3hNYXJnaW47XG4gICAgICAgICAgICAgICAgc2VsZi5wYXJlbnROb2RlID0gc2VsZi5wYXJlbnRET01Ob2RlO1xuICAgICAgICAgICAgICAgIHNlbGYuY2FudmFzLmhlaWdodCA9IHNlbGYuaGVpZ2h0ICogd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgICAgICAgICAgc2VsZi5jYW52YXMud2lkdGggPSBzZWxmLndpZHRoICogd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgICAgICAgICAgc2VsZi5jYW52YXMuc3R5bGUuaGVpZ2h0ID0gc2VsZi5oZWlnaHQgKyAncHgnO1xuICAgICAgICAgICAgICAgIHNlbGYuY2FudmFzLnN0eWxlLndpZHRoID0gc2VsZi53aWR0aCArICdweCc7XG4gICAgICAgICAgICAgICAgc2VsZi5jYW52YXNPZmZzZXRUb3AgPSAwO1xuICAgICAgICAgICAgICAgIHNlbGYuY2FudmFzT2Zmc2V0TGVmdCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzY3JvbGxIZWlnaHQgPSBzZWxmLmRhdGEucmVkdWNlKGZ1bmN0aW9uIHJlZHVjZURhdGEoYWNjdW11bGF0b3IsIHJvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bXVsYXRvclxuICAgICAgICAgICAgICAgICAgICArIChzZWxmLnNpemVzLnJvd3Nbcm93W3NlbGYudW5pcXVlSWRdXSB8fCBzZWxmLnN0eWxlLmNlbGxIZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgICsgKHNlbGYuc2l6ZXMudHJlZXNbcm93W3NlbGYudW5pcXVlSWRdXSB8fCAwKVxuICAgICAgICAgICAgICAgICAgICArIGNlbGxCb3JkZXI7XG4gICAgICAgICAgICB9LCAwKSB8fCAwO1xuICAgICAgICAgICAgc2Nyb2xsV2lkdGggPSBzZWxmLmdldFZpc2libGVTY2hlbWEoKS5yZWR1Y2UoZnVuY3Rpb24gcmVkdWNlU2NoZW1hKGFjY3VtdWxhdG9yLCBjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoY29sdW1uLmhpZGRlbikgeyByZXR1cm4gYWNjdW11bGF0b3I7IH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW11bGF0b3IgKyAoc2VsZi5zaXplcy5jb2x1bW5zW2NvbHVtbltzZWxmLnVuaXF1ZUlkXV0gfHwgY29sdW1uLndpZHRoIHx8IHNlbGYuc3R5bGUuY29sdW1uV2lkdGgpICsgY2VsbEJvcmRlcjtcbiAgICAgICAgICAgIH0sIDApIHx8IDA7XG4gICAgICAgICAgICBpZiAoc2VsZi5hdHRyaWJ1dGVzLnNob3dOZXdSb3cpIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxIZWlnaHQgKz0gc2VsZi5zdHlsZS5jZWxsSGVpZ2h0ICsgY2VsbEJvcmRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuc2Nyb2xsQm94LndpZHRoID0gc2VsZi53aWR0aCAtIGhlYWRlckNlbGxXaWR0aDtcbiAgICAgICAgICAgIHNlbGYuc2Nyb2xsQm94LmhlaWdodCA9IHNlbGYuaGVpZ2h0IC0gaGVhZGVyQ2VsbEhlaWdodCAtIGhlYWRlckNlbGxCb3JkZXI7XG4gICAgICAgICAgICBzZWxmLnNjcm9sbEJveC50b3AgPSBoZWFkZXJDZWxsSGVpZ2h0ICsgaGVhZGVyQ2VsbEJvcmRlcjtcbiAgICAgICAgICAgIHNlbGYuc2Nyb2xsQm94LmxlZnQgPSBoZWFkZXJDZWxsV2lkdGg7XG4gICAgICAgICAgICBzZWxmLnNjcm9sbEJveC5zY3JvbGxIZWlnaHQgPSBzY3JvbGxIZWlnaHQgKyBzZWxmLnN0eWxlLnNjcm9sbEJhcldpZHRoIC0gc2VsZi5zY3JvbGxCb3guaGVpZ2h0O1xuICAgICAgICAgICAgc2VsZi5zY3JvbGxCb3guc2Nyb2xsV2lkdGggPSBzY3JvbGxXaWR0aCArIHNlbGYuc3R5bGUuc2Nyb2xsQmFyV2lkdGggLSBzZWxmLnNjcm9sbEJveC53aWR0aDtcbiAgICAgICAgICAgIHNlbGYuc2Nyb2xsQm94LndpZHRoQm94UmF0aW8gPSAoKHNlbGYuc2Nyb2xsQm94LndpZHRoIC0gc2Nyb2xsRHJhZ1Bvc2l0aW9uT2Zmc2V0WClcbiAgICAgICAgICAgICAgICAvIChzZWxmLnNjcm9sbEJveC5zY3JvbGxXaWR0aCArIHNlbGYuc2Nyb2xsQm94LndpZHRoIC0gc2Nyb2xsRHJhZ1Bvc2l0aW9uT2Zmc2V0WCkpO1xuICAgICAgICAgICAgc2VsZi5zY3JvbGxCb3guc2Nyb2xsQm94V2lkdGggPSBzZWxmLnNjcm9sbEJveC53aWR0aFxuICAgICAgICAgICAgICAgICogc2VsZi5zY3JvbGxCb3gud2lkdGhCb3hSYXRpb1xuICAgICAgICAgICAgICAgIC0gc2VsZi5zdHlsZS5zY3JvbGxCYXJXaWR0aDtcbiAgICAgICAgICAgIHNlbGYuc2Nyb2xsQm94LmhlaWdodEJveFJhdGlvID0gKChzZWxmLnNjcm9sbEJveC5oZWlnaHQgLSBzY3JvbGxEcmFnUG9zaXRpb25PZmZzZXRZKVxuICAgICAgICAgICAgICAgIC8gKHNlbGYuc2Nyb2xsQm94LnNjcm9sbEhlaWdodCArIChzZWxmLnNjcm9sbEJveC5oZWlnaHQgLSBzY3JvbGxEcmFnUG9zaXRpb25PZmZzZXRZKSkpO1xuICAgICAgICAgICAgc2VsZi5zY3JvbGxCb3guc2Nyb2xsQm94SGVpZ2h0ID0gc2VsZi5zY3JvbGxCb3guaGVpZ2h0XG4gICAgICAgICAgICAgICAgKiBzZWxmLnNjcm9sbEJveC5oZWlnaHRCb3hSYXRpb1xuICAgICAgICAgICAgICAgIC0gc2VsZi5zdHlsZS5zY3JvbGxCYXJXaWR0aDtcbiAgICAgICAgICAgIHNlbGYuc2Nyb2xsQm94LnNjcm9sbEJveFdpZHRoID0gTWF0aC5tYXgoc2VsZi5zY3JvbGxCb3guc2Nyb2xsQm94V2lkdGgsIHNlbGYuc3R5bGUuc2Nyb2xsQmFyQm94TWluU2l6ZSk7XG4gICAgICAgICAgICBzZWxmLnNjcm9sbEJveC5zY3JvbGxCb3hIZWlnaHQgPSBNYXRoLm1heChzZWxmLnNjcm9sbEJveC5zY3JvbGxCb3hIZWlnaHQsIHNlbGYuc3R5bGUuc2Nyb2xsQmFyQm94TWluU2l6ZSk7XG4gICAgICAgICAgICBzZWxmLnBhZ2UgPSBzZWxmLnZpc2libGVSb3dzLmxlbmd0aCAtIDMgLSBzZWxmLmF0dHJpYnV0ZXMucGFnZVVwRG93bk92ZXJsYXA7XG4gICAgICAgICAgICBpZiAoZHJhd0FmdGVyUmVzaXplKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5kcmF3KHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdyZXNpemUnLCBbe31dLCBzZWxmLmludGYpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHNlbGYuc2Nyb2xsID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBwb3MsXG4gICAgICAgICAgICAgICAgcyA9IHNlbGYuZ2V0VmlzaWJsZVNjaGVtYSgpLFxuICAgICAgICAgICAgICAgIGNlbGxCb3JkZXIgPSBzZWxmLnN0eWxlLmNlbGxCb3JkZXJXaWR0aCAqIDI7XG4gICAgICAgICAgICBzZWxmLnNjcm9sbEluZGV4VG9wID0gMDtcbiAgICAgICAgICAgIHNlbGYuc2Nyb2xsUGl4ZWxUb3AgPSAwO1xuICAgICAgICAgICAgc2VsZi5zY3JvbGxJbmRleExlZnQgPSAwO1xuICAgICAgICAgICAgc2VsZi5zY3JvbGxQaXhlbExlZnQgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKHNlbGYuc2Nyb2xsUGl4ZWxUb3AgPCBzZWxmLnNjcm9sbEJveC5zY3JvbGxUb3AgJiYgc2VsZi5zY3JvbGxJbmRleFRvcCA8IHNlbGYuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNjcm9sbFBpeGVsVG9wICs9XG4gICAgICAgICAgICAgICAgICAgIChzZWxmLnNpemVzLnJvd3Nbc2VsZi5kYXRhW3NlbGYuc2Nyb2xsSW5kZXhUb3BdW3NlbGYudW5pcXVlSWRdXSB8fCBzZWxmLnN0eWxlLmNlbGxIZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgICsgKHNlbGYuc2l6ZXMudHJlZXNbc2VsZi5kYXRhW3NlbGYuc2Nyb2xsSW5kZXhUb3BdW3NlbGYudW5pcXVlSWRdXSB8fCAwKVxuICAgICAgICAgICAgICAgICAgICArIGNlbGxCb3JkZXI7XG4gICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxJbmRleFRvcCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKHNlbGYuc2Nyb2xsUGl4ZWxMZWZ0IDwgc2VsZi5zY3JvbGxCb3guc2Nyb2xsTGVmdCAmJiBzZWxmLnNjcm9sbEluZGV4TGVmdCA8IHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxQaXhlbExlZnQgKz1cbiAgICAgICAgICAgICAgICAgICAgKHNlbGYuc2l6ZXMuY29sdW1uc1tzW3NlbGYuc2Nyb2xsSW5kZXhMZWZ0XVtzZWxmLnVuaXF1ZUlkXV0gfHwgc1tzZWxmLnNjcm9sbEluZGV4TGVmdF0ud2lkdGgpO1xuICAgICAgICAgICAgICAgIHNlbGYuc2Nyb2xsSW5kZXhMZWZ0ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5kYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNjcm9sbEluZGV4TGVmdCA9IE1hdGgubWF4KHNlbGYuc2Nyb2xsSW5kZXhMZWZ0IC0gMSwgMCk7XG4gICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxQaXhlbExlZnQgPSBNYXRoLm1heChzZWxmLnNjcm9sbFBpeGVsTGVmdFxuICAgICAgICAgICAgICAgICAgICAtIChzZWxmLnNpemVzLmNvbHVtbnNbc1tzZWxmLnNjcm9sbEluZGV4TGVmdF1bc2VsZi51bmlxdWVJZF1dIHx8IHNbc2VsZi5zY3JvbGxJbmRleExlZnRdLndpZHRoKSwgMCk7XG4gICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxJbmRleFRvcCA9IE1hdGgubWF4KHNlbGYuc2Nyb2xsSW5kZXhUb3AgLSAxLCAwKTtcbiAgICAgICAgICAgICAgICBzZWxmLnNjcm9sbFBpeGVsVG9wID0gTWF0aC5tYXgoc2VsZi5zY3JvbGxQaXhlbFRvcFxuICAgICAgICAgICAgICAgICAgICAtIChzZWxmLnNpemVzLnJvd3Nbc2VsZi5kYXRhW3NlbGYuc2Nyb2xsSW5kZXhUb3BdW3NlbGYudW5pcXVlSWRdXSB8fCBzZWxmLnN0eWxlLmNlbGxIZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgIC0gKHNlbGYuc2l6ZXMudHJlZXNbc2VsZi5kYXRhW3NlbGYuc2Nyb2xsSW5kZXhUb3BdW3NlbGYudW5pcXVlSWRdXSB8fCAwKSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmVsbGlwc2lzQ2FjaGUgPSB7fTtcbiAgICAgICAgICAgIHNlbGYuZHJhdyh0cnVlKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmlucHV0KSB7XG4gICAgICAgICAgICAgICAgcG9zID0gc2VsZi5wb3NpdGlvbihzZWxmLnBhcmVudE5vZGUsIHRydWUpO1xuICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQuc3R5bGUudG9wID0gcG9zLnRvcCArIHNlbGYuc2Nyb2xsRWRpdC5pbnB1dFRvcFxuICAgICAgICAgICAgICAgICAgICArIChzZWxmLnNjcm9sbEVkaXQuc2Nyb2xsVG9wIC0gc2VsZi5zY3JvbGxCb3guc2Nyb2xsVG9wKSArICdweCc7XG4gICAgICAgICAgICAgICAgc2VsZi5pbnB1dC5zdHlsZS5sZWZ0ID0gcG9zLmxlZnQgKyBzZWxmLnNjcm9sbEVkaXQuaW5wdXRMZWZ0XG4gICAgICAgICAgICAgICAgICAgICsgKHNlbGYuc2Nyb2xsRWRpdC5zY3JvbGxMZWZ0IC0gc2VsZi5zY3JvbGxCb3guc2Nyb2xsTGVmdCkgKyAncHgnO1xuICAgICAgICAgICAgICAgIHNlbGYuY2xpcEVsZW1lbnQoc2VsZi5pbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ3Njcm9sbCcsIFt7dG9wOiBzZWxmLnNjcm9sbEJveC5zY3JvbGxUb3AsIGxlZnQ6IHNlbGYuc2Nyb2xsQm94LnNjcm9sbExlZnQgfV0sIHNlbGYuaW50Zik7XG4gICAgICAgIH07XG4gICAgICAgIHNlbGYubW91c2Vtb3ZlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbnRleHRNZW51IHx8IHNlbGYuaW5wdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLm1vdXNlID0gc2VsZi5nZXRMYXllclBvcyhlKTtcbiAgICAgICAgICAgIHZhciBjdHJsID0gKGUuY29udHJvbEtleSB8fCBlLm1ldGFLZXkgfHwgc2VsZi5hdHRyaWJ1dGVzLnBlcnNpc3RhbnRTZWxlY3Rpb25Nb2RlKSxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIHMgPSBzZWxmLmdldFNjaGVtYSgpLFxuICAgICAgICAgICAgICAgIGRyYWdCb3VuZHMsXG4gICAgICAgICAgICAgICAgc0JvdW5kcyxcbiAgICAgICAgICAgICAgICB4ID0gc2VsZi5tb3VzZS54LFxuICAgICAgICAgICAgICAgIHkgPSBzZWxmLm1vdXNlLnksXG4gICAgICAgICAgICAgICAgbyxcbiAgICAgICAgICAgICAgICBkZWx0YTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChzZWxmLnNjcm9sbFRpbWVyKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmRpc3BhdGNoRXZlbnQoJ21vdXNlbW92ZScsIFtlLCBvXSwgc2VsZi5pbnRmKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2VsZi5pc0luR3JpZCh7eDogeCwgeTogeX0pKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5oYXNGb2N1cyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbyA9IHNlbGYuZ2V0Q2VsbEF0KHgsIHkpO1xuICAgICAgICAgICAgaWYgKG8gJiYgc2VsZi5jdXJyZW50Q2VsbCAmJiAoc2VsZi5jdXJyZW50Q2VsbC5yb3dJbmRleCAhPT0gby5yb3dJbmRleFxuICAgICAgICAgICAgICAgICAgICB8fCBzZWxmLmN1cnJlbnRDZWxsLmNvbHVtbkluZGV4ICE9PSBvLmNvbHVtbkluZGV4KSkge1xuICAgICAgICAgICAgICAgIHNlbGYuY2VsbEJvdW5kYXJ5Q3Jvc3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdjZWxsbW91c2VvdmVyJywgW2UsIG9dLCBzZWxmLmludGYpO1xuICAgICAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnY2VsbG1vdXNlb3V0JywgW2UsIHNlbGYuY3VycmVudENlbGxdLCBzZWxmLmludGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5jdXJyZW50Q2VsbCA9IG87XG4gICAgICAgICAgICBpZiAoIXNlbGYuaGFzRm9jdXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmhvdmVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKCFzZWxmLmRyYWdnaW5nSXRlbVxuICAgICAgICAgICAgICAgICAgICAmJiBvXG4gICAgICAgICAgICAgICAgICAgICYmIHNlbGYuc2Nyb2xsTW9kZXMuaW5kZXhPZihvLmNvbnRleHQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHNlbGYuZHJhZ0l0ZW0gPSBvO1xuICAgICAgICAgICAgICAgIHNlbGYuZHJhZ01vZGUgPSBvLmRyYWdDb250ZXh0O1xuICAgICAgICAgICAgICAgIHNlbGYuY2FudmFzLnN0eWxlLmN1cnNvciA9IG8uY29udGV4dDtcbiAgICAgICAgICAgICAgICBpZiAoby5jb250ZXh0ID09PSAnY2VsbCcgJiYgby5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2FudmFzLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5ob3ZlcnNbby5kYXRhW3NlbGYudW5pcXVlSWRdXSA9IFtvLnJvd0luZGV4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChzZWxmLnNlbGVjdGluZyB8fCBzZWxmLnJlb3JkZXJPYmplY3QpXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBvLmNvbnRleHQgPT09ICdjZWxsJ1xuICAgICAgICAgICAgICAgICAgICAgICAgJiYgby5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHNCb3VuZHMgPSBzZWxmLmdldFNlbGVjdGlvbkJvdW5kcygpO1xuICAgICAgICAgICAgICAgICAgICBkZWx0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IE1hdGguYWJzKHNlbGYuZHJhZ1N0YXJ0LnggLSB4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IE1hdGguYWJzKHNlbGYuZHJhZ1N0YXJ0LnkgLSB5KSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuZHJhZ1N0YXJ0T2JqZWN0LmNvbHVtbkluZGV4ICE9PSAtMSAmJiBlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmRyYWdTdGFydE9iamVjdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dJbmRleDogc2VsZi5hY3RpdmVDZWxsLnJvd0luZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbkluZGV4OiBzZWxmLmFjdGl2ZUNlbGwuY29sdW1uSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZHJhZ0JvdW5kcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogTWF0aC5taW4oc2VsZi5kcmFnU3RhcnRPYmplY3Qucm93SW5kZXgsIG8ucm93SW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogTWF0aC5taW4oc2VsZi5kcmFnU3RhcnRPYmplY3QuY29sdW1uSW5kZXgsIG8uY29sdW1uSW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBNYXRoLm1heChzZWxmLmRyYWdTdGFydE9iamVjdC5yb3dJbmRleCwgby5yb3dJbmRleCksXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogTWF0aC5tYXgoc2VsZi5kcmFnU3RhcnRPYmplY3QuY29sdW1uSW5kZXgsIG8uY29sdW1uSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmRyYWdTdGFydE9iamVjdC5jb2x1bW5JbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdCb3VuZHMubGVmdCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ0JvdW5kcy5yaWdodCA9IHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdCb3VuZHMudG9wID0gTWF0aC5taW4oc0JvdW5kcy50b3AsIG8ucm93SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ0JvdW5kcy5ib3R0b20gPSBNYXRoLm1heChzQm91bmRzLmJvdHRvbSwgby5yb3dJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuZHJhZ1N0YXJ0T2JqZWN0LnJvd0luZGV4ICE9PSBvLnJvd0luZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHNlbGYuZHJhZ1N0YXJ0T2JqZWN0LmNvbHVtbkluZGV4ICE9PSBvLmNvbHVtbkluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmlnbm9yZU5leHRDbGljayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuY2VsbEJvdW5kYXJ5Q3Jvc3NlZCB8fCAoZGVsdGEueCA9PT0gMCAmJiBkZWx0YS55ID09PSAwKSB8fCBzZWxmLmF0dHJpYnV0ZXMucm93U2VsZWN0aW9uTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuYXR0cmlidXRlcy5yb3dTZWxlY3Rpb25Nb2RlIHx8IHNlbGYuZHJhZ1N0YXJ0T2JqZWN0LmNvbHVtbkluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0Um93KG8ucm93SW5kZXgsIGN0cmwsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGYuZHJhZ0FkZFRvU2VsZWN0aW9uICYmIG8ucm93SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuc2VsZWN0aW9uc1tvLnJvd0luZGV4XSAmJiBzZWxmLnNlbGVjdGlvbnNbby5yb3dJbmRleF0uaW5kZXhPZihvLmNvbHVtbkluZGV4KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0aW9uc1tvLnJvd0luZGV4XS5zcGxpY2Uoc2VsZi5zZWxlY3Rpb25zW28ucm93SW5kZXhdLmluZGV4T2Yoby5jb2x1bW5JbmRleCksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxlY3Rpb25zW28ucm93SW5kZXhdID0gc2VsZi5zZWxlY3Rpb25zW28ucm93SW5kZXhdIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5zZWxlY3Rpb25zW28ucm93SW5kZXhdLmluZGV4T2Yoby5jb2x1bW5JbmRleCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGlvbnNbby5yb3dJbmRleF0ucHVzaChvLmNvbHVtbkluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKCFzZWxmLnNlbGVjdGlvbkJvdW5kcyB8fCAoZHJhZ0JvdW5kcy50b3AgIT09IHNlbGYuc2VsZWN0aW9uQm91bmRzLnRvcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGRyYWdCb3VuZHMubGVmdCAhPT0gc2VsZi5zZWxlY3Rpb25Cb3VuZHMubGVmdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGRyYWdCb3VuZHMuYm90dG9tICE9PSBzZWxmLnNlbGVjdGlvbkJvdW5kcy5ib3R0b21cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBkcmFnQm91bmRzLnJpZ2h0ICE9PSBzZWxmLnNlbGVjdGlvbkJvdW5kcy5yaWdodCkpICYmICFjdHJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNCb3VuZHMgPSBkcmFnQm91bmRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuYXR0cmlidXRlcy5yb3dTZWxlY3Rpb25Nb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gc0JvdW5kcy50b3A7IGkgPD0gc0JvdW5kcy5ib3R0b207IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdFJvdyhpLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0QXJlYShzQm91bmRzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmF1dG9TY3JvbGxab25lKGUsIHgsIHksIGN0cmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuY2VsbEJvdW5kYXJ5Q3Jvc3NlZCA9IGZhbHNlO1xuICAgICAgICAgICAgc2VsZi5kcmF3KHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRW5kcyBlZGl0aW5nLCBvcHRpb25hbGx5IGFib3J0aW5nIHRoZSBlZGl0LlxuICAgICAgICAgKiBAbWVtYmVyb2YgY2FudmFzRGF0YUdyaWQjXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBhYm9ydCBXaGVuIHRydWUsIGFib3J0IHRoZSBlZGl0LlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5lbmRFZGl0ID0gZnVuY3Rpb24gKGFib3J0KSB7XG4gICAgICAgICAgICB2YXIgY2VsbCA9IHNlbGYuaW5wdXQuZWRpdENlbGwsXG4gICAgICAgICAgICAgICAgeSA9IGNlbGwucm93SW5kZXg7XG4gICAgICAgICAgICBmdW5jdGlvbiBhYm9ydEVkaXQoKSB7XG4gICAgICAgICAgICAgICAgYWJvcnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuZGlzcGF0Y2hFdmVudCgnYmVmb3JlZW5kZWRpdCcsIFt7fSwgY2VsbCwgc2VsZi5pbnB1dC52YWx1ZSwgY2VsbC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRFZGl0LCBzZWxmLmlucHV0XSwgc2VsZi5pbnRmKSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgICAgIGlmIChzZWxmLmlucHV0LnZhbHVlICE9PSBjZWxsLnZhbHVlICYmICFhYm9ydCkge1xuICAgICAgICAgICAgICAgIHNlbGYuY2hhbmdlc1t5XSA9IHNlbGYuY2hhbmdlc1t5XSB8fCB7fTtcbiAgICAgICAgICAgICAgICBzZWxmLmNoYW5nZXNbeV1bY2VsbC5oZWFkZXIubmFtZV0gPSBzZWxmLmlucHV0LnZhbHVlO1xuICAgICAgICAgICAgICAgIGNlbGwuZGF0YVtjZWxsLmhlYWRlci5uYW1lXSA9IHNlbGYuaW5wdXQudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHkgPT09IHNlbGYuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuZGlzcGF0Y2hFdmVudCgnbmV3cm93JywgW3NlbGYuaW5wdXQudmFsdWUsIGNlbGwudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQsIGNlbGwsIHNlbGYuaW5wdXRdLCBzZWxmLmludGYpKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICAgICAgICAgICAgICBzZWxmLnVJZCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmFkZFJvdyhjZWxsLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNyZWF0ZU5ld1Jvd0RhdGEoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5kcmF3KHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChzZWxmLmlucHV0KTtcbiAgICAgICAgICAgIHNlbGYuY29udHJvbElucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2VuZGVkaXQnLCBbe30sIGNlbGwsIHNlbGYuaW5wdXQudmFsdWUsIGFib3J0LCBzZWxmLmlucHV0XSwgc2VsZi5pbnRmKTtcbiAgICAgICAgICAgIHNlbGYuaW5wdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJlZ2lucyBlZGl0aW5nIGF0IGNlbGwgeCwgcm93IHkuXG4gICAgICAgICAqIEBtZW1iZXJvZiBjYW52YXNEYXRhR3JpZCNcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0geCBUaGUgY29sdW1uIGluZGV4IG9mIHRoZSBjZWxsIHRvIGVkaXQuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IFRoZSByb3cgaW5kZXggb2YgdGhlIGNlbGwgdG8gZWRpdC5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuYmVnaW5FZGl0QXQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgaWYgKCFzZWxmLmF0dHJpYnV0ZXMuZWRpdGFibGUpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICB2YXIgdG9wLCBsZWZ0LCBjZWxsLCBzID0gc2VsZi5nZXRWaXNpYmxlU2NoZW1hKCk7XG4gICAgICAgICAgICBjZWxsID0gc2VsZi52aXNpYmxlQ2VsbHMuZmlsdGVyKGZ1bmN0aW9uICh2Q2VsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2Q2VsbC5jb2x1bW5JbmRleCA9PT0geCAmJiB2Q2VsbC5yb3dJbmRleCA9PT0geTtcbiAgICAgICAgICAgIH0pWzBdO1xuICAgICAgICAgICAgaWYgKHNlbGYuZGlzcGF0Y2hFdmVudCgnYmVmb3JlYmVnaW5lZGl0JywgW3t9LCBjZWxsXSwgc2VsZi5pbnRmKSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgICAgIHNlbGYuc2Nyb2xsSW50b1ZpZXcoeCwgeSk7XG4gICAgICAgICAgICBzZWxmLnNldEFjdGl2ZUNlbGwoeCwgeSk7XG4gICAgICAgICAgICBmdW5jdGlvbiBwb3N0RHJhdygpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gc2VsZi5wb3NpdGlvbihzZWxmLnBhcmVudE5vZGUsIHRydWUpO1xuICAgICAgICAgICAgICAgIGNlbGwgPSBzZWxmLnZpc2libGVDZWxscy5maWx0ZXIoZnVuY3Rpb24gKHZDZWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2Q2VsbC5jb2x1bW5JbmRleCA9PT0geCAmJiB2Q2VsbC5yb3dJbmRleCA9PT0geTtcbiAgICAgICAgICAgICAgICB9KVswXTtcbiAgICAgICAgICAgICAgICB0b3AgPSBjZWxsLnkgKyBzZWxmLnN0eWxlLmNlbGxCb3JkZXJXaWR0aDtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gY2VsbC54ICsgc2VsZi5zdHlsZS5jZWxsQm9yZGVyV2lkdGg7XG4gICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxFZGl0ID0ge1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxUb3A6IHNlbGYuc2Nyb2xsQm94LnNjcm9sbFRvcCxcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsTGVmdDogc2VsZi5zY3JvbGxCb3guc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRUb3A6IHRvcCxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRMZWZ0OiBsZWZ0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzZWxmLmlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChzZWxmLmF0dHJpYnV0ZXMubXVsdGlMaW5lID8gJ3RleHRhcmVhJyA6ICdpbnB1dCcpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2VsZi5pbnB1dCk7XG4gICAgICAgICAgICAgICAgc2VsZi5pbnB1dC5jbGFzc05hbWUgPSAnY2FudmFzLWRhdGFncmlkLWVkaXQtaW5wdXQnO1xuICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQuc3R5bGUudG9wID0gcG9zLnRvcCAtIDEgKyB0b3AgKyAncHgnO1xuICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQuc3R5bGUubGVmdCA9IHBvcy5sZWZ0IC0gMSArIGxlZnQgKyAncHgnO1xuICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQuc3R5bGUuaGVpZ2h0ID0gY2VsbC5oZWlnaHQgLSAoc2VsZi5zdHlsZS5jZWxsQm9yZGVyV2lkdGggKiAyKSArICdweCc7XG4gICAgICAgICAgICAgICAgc2VsZi5pbnB1dC5zdHlsZS53aWR0aCA9IGNlbGwud2lkdGggLSAoc2VsZi5zdHlsZS5jZWxsQm9yZGVyV2lkdGggKiAyKVxuICAgICAgICAgICAgICAgICAgICAtIHNlbGYuc3R5bGUuY2VsbFBhZGRpbmdMZWZ0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICBzZWxmLmlucHV0LnN0eWxlLnpJbmRleCA9ICcyJztcbiAgICAgICAgICAgICAgICBzZWxmLmlucHV0LnZhbHVlID0gY2VsbC52YWx1ZTtcbiAgICAgICAgICAgICAgICBzZWxmLmlucHV0LmVkaXRDZWxsID0gY2VsbDtcbiAgICAgICAgICAgICAgICBzZWxmLmNsaXBFbGVtZW50KHNlbGYuaW5wdXQpO1xuICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICBzZWxmLmlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc2VsZi5zdG9wUHJvcGFnYXRpb24pO1xuICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBzZWxmLnN0b3BQcm9wYWdhdGlvbik7XG4gICAgICAgICAgICAgICAgc2VsZi5pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgc2VsZi5zdG9wUHJvcGFnYXRpb24pO1xuICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgc2VsZi5zdG9wUHJvcGFnYXRpb24pO1xuICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBueCA9IGNlbGwuY29sdW1uSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBueSA9IGNlbGwucm93SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzY1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09PSAyNykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbmRFZGl0KHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5kcmF3KHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBlbnRlclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZW5kRWRpdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5kcmF3KHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGUua2V5Q29kZSA9PT0gOSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxmLmVuZEVkaXQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnggLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnggKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChueCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBueCA9IHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBueSAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG54ID4gcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG55ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobnkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnkgPSBzZWxmLmRhdGEubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChueSA+IHNlbGYuZGF0YS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnkgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5iZWdpbkVkaXRBdChueCwgbnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocG9zdERyYXcpO1xuICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdiZWdpbmVkaXQnLCBbY2VsbCwgc2VsZi5pbnB1dF0sIHNlbGYuaW50Zik7XG4gICAgICAgIH07XG4gICAgICAgIHNlbGYuY2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uQ2hhbmdlZCxcbiAgICAgICAgICAgICAgICBjdHJsID0gKGUuY29udHJvbEtleSB8fCBlLm1ldGFLZXkgfHwgc2VsZi5hdHRyaWJ1dGVzLnBlcnNpc3RhbnRTZWxlY3Rpb25Nb2RlKSxcbiAgICAgICAgICAgICAgICBwb3MgPSBzZWxmLmdldExheWVyUG9zKGUpO1xuICAgICAgICAgICAgc2VsZi5jdXJyZW50Q2VsbCA9IHNlbGYuZ2V0Q2VsbEF0KHBvcy54LCBwb3MueSk7XG4gICAgICAgICAgICBpZiAoc2VsZi5jdXJyZW50Q2VsbC5ncmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBjaGVja1NlbGVjdGlvbkNoYW5nZSgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdGlvbkNoYW5nZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdzZWxlY3Rpb25jaGFuZ2VkJyxcbiAgICAgICAgICAgICAgICAgICAgW3NlbGYuZ2V0U2VsZWN0ZWREYXRhKCksIHNlbGYuc2VsZWN0aW9ucywgc2VsZi5zZWxlY3Rpb25Cb3VuZHNdLCBzZWxmLmludGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmVuZEVkaXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmlnbm9yZU5leHRDbGljaykge1xuICAgICAgICAgICAgICAgIHNlbGYuaWdub3JlTmV4dENsaWNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSA9IHNlbGYuY3VycmVudENlbGw7XG4gICAgICAgICAgICBpZiAoc2VsZi5kaXNwYXRjaEV2ZW50KCdjbGljaycsIFtlLCBzZWxmLmN1cnJlbnRDZWxsXSwgc2VsZi5pbnRmKSkgeyByZXR1cm47IH1cbiAgICAgICAgICAgIGlmICghc2VsZi5oYXNGb2N1cykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmN1cnJlbnRDZWxsLmNvbnRleHQgPT09ICdjZWxsJykge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmN1cnJlbnRDZWxsLnN0eWxlID09PSAnY29ybmVyQ2VsbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5vcmRlcihzZWxmLnVuaXF1ZUlkLCAnYXNjJyk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0RmlsdGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrU2VsZWN0aW9uQ2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY3VycmVudENlbGwuc3R5bGUgPT09ICdoZWFkZXJDZWxsJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5vcmRlckJ5ID09PSBpLmhlYWRlci5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm9yZGVyRGlyZWN0aW9uID0gc2VsZi5vcmRlckRpcmVjdGlvbiA9PT0gJ2FzYycgPyAnZGVzYycgOiAnYXNjJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYub3JkZXJEaXJlY3Rpb24gPSAnYXNjJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWxmLm9yZGVyKGkuaGVhZGVyLm5hbWUsIHNlbGYub3JkZXJEaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICBjaGVja1NlbGVjdGlvbkNoYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChbJ3Jvd0hlYWRlckNlbGwnLCAnaGVhZGVyQ2VsbCddLmluZGV4T2Yoc2VsZi5jdXJyZW50Q2VsbC5zdHlsZSkgPT09IC0xICYmICFjdHJsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0QWN0aXZlQ2VsbChpLmNvbHVtbkluZGV4LCBpLnJvd0luZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5zZWxlY3Rpb25zW2kucm93SW5kZXhdID0gc2VsZi5zZWxlY3Rpb25zW2kucm93SW5kZXhdIHx8IFtdO1xuICAgICAgICAgICAgICAgIGlmICgoc2VsZi5hdHRyaWJ1dGVzLnJvd1NlbGVjdGlvbk1vZGUgfHwgc2VsZi5jdXJyZW50Q2VsbC5zdHlsZSA9PT0gJ3Jvd0hlYWRlckNlbGwnKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5jdXJyZW50Q2VsbC5zdHlsZSA9PT0gJ3Jvd0hlYWRlckNlbGwnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgc2VsZi5hdHRyaWJ1dGVzLnRyZWUgJiYgcG9zLnggPiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgcG9zLnggLSBzZWxmLmN1cnJlbnRDZWxsLnggPCBzZWxmLnN0eWxlLnRyZWVBcnJvd1dpZHRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBzZWxmLnN0eWxlLnRyZWVBcnJvd01hcmdpbkxlZnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArIHNlbGYuc3R5bGUudHJlZUFycm93TWFyZ2luUmlnaHQgKyBzZWxmLnN0eWxlLnRyZWVBcnJvd0NsaWNrUmFkaXVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgcG9zLnkgLSBzZWxmLmN1cnJlbnRDZWxsLnkgPCBzZWxmLnN0eWxlLnRyZWVBcnJvd0hlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgc2VsZi5zdHlsZS50cmVlQXJyb3dNYXJnaW5Ub3AgKyBzZWxmLnN0eWxlLnRyZWVBcnJvd0NsaWNrUmFkaXVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgcG9zLnkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnRvZ2dsZVRyZWUoaS5yb3dJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0Um93KGkucm93SW5kZXgsIGN0cmwsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZS5zaGlmdEtleSAmJiAhY3RybCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGlvbkJvdW5kcyA9IHNlbGYuZ2V0U2VsZWN0aW9uQm91bmRzKCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0QXJlYSh1bmRlZmluZWQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGVja1NlbGVjdGlvbkNoYW5nZSgpO1xuICAgICAgICAgICAgc2VsZi5kcmF3KHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICBzZWxmLmRyYWdSZXNpemVDb2x1bW4gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIHBvcywgeCwgeTtcbiAgICAgICAgICAgIHBvcyA9IHNlbGYuZ2V0TGF5ZXJQb3MoZSk7XG4gICAgICAgICAgICB4ID0gc2VsZi5yZXNpemluZ1N0YXJ0aW5nV2lkdGggKyBwb3MueCAtIHNlbGYuZHJhZ1N0YXJ0Lng7XG4gICAgICAgICAgICB5ID0gc2VsZi5yZXNpemluZ1N0YXJ0aW5nSGVpZ2h0ICsgcG9zLnkgLSBzZWxmLmRyYWdTdGFydC55O1xuICAgICAgICAgICAgaWYgKHggPCBzZWxmLnN0eWxlLm1pbkNvbHVtbldpZHRoKSB7XG4gICAgICAgICAgICAgICAgeCA9IHNlbGYuc3R5bGUubWluQ29sdW1uV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeSA8IHNlbGYuc3R5bGUubWluUm93SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgeSA9IHNlbGYuc3R5bGUubWluUm93SGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuZGlzcGF0Y2hFdmVudCgncmVzaXplY29sdW1uJywgW3t9LCB4LCB5LCBzZWxmLmRyYWdnaW5nSXRlbV0sIHNlbGYuaW50ZikpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgICAgICBpZiAoc2VsZi5zY3JvbGxCb3guc2Nyb2xsTGVmdCA+IHNlbGYuc2Nyb2xsQm94LnNjcm9sbFdpZHRoIC0gc2VsZi5hdHRyaWJ1dGVzLnJlc2l6ZVNjcm9sbFpvbmVcbiAgICAgICAgICAgICAgICAgICAgJiYgc2VsZi5kcmFnTW9kZSA9PT0gJ2V3LXJlc2l6ZScpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnJlc2l6ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICBzZWxmLnNjcm9sbEJveC5zY3JvbGxMZWZ0ICs9IHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5kcmFnTW9kZSA9PT0gJ2V3LXJlc2l6ZScpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNpemVzLmNvbHVtbnNbc2VsZi5kcmFnZ2luZ0l0ZW0uaGVhZGVyLnN0eWxlID09PSAncm93SGVhZGVyQ2VsbCdcbiAgICAgICAgICAgICAgICAgICAgICAgPyAnY29ybmVyQ2VsbCcgOiBzZWxmLmRyYWdnaW5nSXRlbS5oZWFkZXJbc2VsZi51bmlxdWVJZF1dID0geDtcbiAgICAgICAgICAgICAgICBpZiAoWydyb3dIZWFkZXJDZWxsJywgJ2Nvcm5lckNlbGwnXS5pbmRleE9mKHNlbGYuZHJhZ2dpbmdJdGVtLmhlYWRlci5zdHlsZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmVzaXplKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLnJlc2l6ZUNoaWxkR3JpZHMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5kcmFnTW9kZSA9PT0gJ25zLXJlc2l6ZScpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5kcmFnZ2luZ0l0ZW0ucm93T3Blbikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNpemVzLnRyZWVzW3NlbGYuZHJhZ2dpbmdJdGVtLmRhdGFbc2VsZi51bmlxdWVJZF1dID0geTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGYuYXR0cmlidXRlcy5nbG9iYWxSb3dSZXNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zdHlsZS5jZWxsSGVpZ2h0ID0geTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNpemVzLnJvd3Nbc2VsZi5kcmFnZ2luZ0l0ZW0uZGF0YVtzZWxmLnVuaXF1ZUlkXV0gPSB5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ3Jlc2l6ZXJvdycsIFt5XSwgc2VsZi5pbnRmKTtcbiAgICAgICAgICAgICAgICBzZWxmLnJlc2l6ZUNoaWxkR3JpZHMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmVsbGlwc2lzQ2FjaGUgPSB7fTtcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5zdG9wRHJhZ1Jlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYucmVzaXplKCk7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHNlbGYuZHJhZ1Jlc2l6ZUNvbHVtbiwgZmFsc2UpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgc2VsZi5zdG9wRHJhZ1Jlc2l6ZSwgZmFsc2UpO1xuICAgICAgICAgICAgc2VsZi5zZXRTdG9yYWdlRGF0YSgpO1xuICAgICAgICAgICAgc2VsZi5kcmF3KHRydWUpO1xuICAgICAgICAgICAgc2VsZi5pZ25vcmVOZXh0Q2xpY2sgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBzZWxmLnNjcm9sbEdyaWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIHBvcyA9IHNlbGYuZ2V0TGF5ZXJQb3MoZSk7XG4gICAgICAgICAgICBzZWxmLnNjcm9sbE1vZGUgPSBzZWxmLmdldENlbGxBdChwb3MueCwgcG9zLnkpLmNvbnRleHQ7XG4gICAgICAgICAgICBpZiAoc2VsZi5zY3JvbGxNb2RlID09PSAnaG9yaXpvbnRhbC1zY3JvbGwtYm94JyAmJiBzZWxmLnNjcm9sbFN0YXJ0TW9kZSAhPT0gJ2hvcml6b250YWwtc2Nyb2xsLWJveCcpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNjcm9sbFN0YXJ0TW9kZSA9ICdob3Jpem9udGFsLXNjcm9sbC1ib3gnO1xuICAgICAgICAgICAgICAgIHNlbGYuZHJhZ1N0YXJ0ID0gcG9zO1xuICAgICAgICAgICAgICAgIHNlbGYuc2Nyb2xsU3RhcnQubGVmdCA9IHNlbGYuc2Nyb2xsQm94LnNjcm9sbExlZnQ7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuc2Nyb2xsVGltZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLnNjcm9sbE1vZGUgPT09ICd2ZXJ0aWNhbC1zY3JvbGwtYm94JyAmJiBzZWxmLnNjcm9sbFN0YXJ0TW9kZSAhPT0gJ3ZlcnRpY2FsLXNjcm9sbC1ib3gnKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxTdGFydE1vZGUgPSAndmVydGljYWwtc2Nyb2xsLWJveCc7XG4gICAgICAgICAgICAgICAgc2VsZi5kcmFnU3RhcnQgPSBwb3M7XG4gICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxTdGFydC50b3AgPSBzZWxmLnNjcm9sbEJveC5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuc2Nyb2xsVGltZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLnNjcm9sbFN0YXJ0TW9kZSA9PT0gJ3ZlcnRpY2FsLXNjcm9sbC1ib3gnXG4gICAgICAgICAgICAgICAgICAgICYmIHNlbGYuc2Nyb2xsTW9kZSAhPT0gJ3ZlcnRpY2FsLXNjcm9sbC1ib3gnKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxNb2RlID0gJ3ZlcnRpY2FsLXNjcm9sbC1ib3gnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuc2Nyb2xsU3RhcnRNb2RlID09PSAnaG9yaXpvbnRhbC1zY3JvbGwtYm94J1xuICAgICAgICAgICAgICAgICAgICAmJiBzZWxmLnNjcm9sbE1vZGUgIT09ICdob3Jpem9udGFsLXNjcm9sbC1ib3gnKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxNb2RlID0gJ2hvcml6b250YWwtc2Nyb2xsLWJveCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoc2VsZi5zY3JvbGxUaW1lcik7XG4gICAgICAgICAgICBpZiAoc2VsZi5zY3JvbGxNb2Rlcy5pbmRleE9mKHNlbGYuc2Nyb2xsTW9kZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuc2Nyb2xsTW9kZSA9PT0gJ3ZlcnRpY2FsLXNjcm9sbC1ib3gnKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxCb3guc2Nyb2xsVG9wID0gc2VsZi5zY3JvbGxTdGFydC50b3AgKyAoKHBvcy55IC0gc2VsZi5kcmFnU3RhcnQueSlcbiAgICAgICAgICAgICAgICAgICAgLyBzZWxmLnNjcm9sbEJveC5oZWlnaHRCb3hSYXRpbyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGYuc2Nyb2xsTW9kZSA9PT0gJ3ZlcnRpY2FsLXNjcm9sbC10b3AnKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxCb3guc2Nyb2xsVG9wIC09IChzZWxmLnBhZ2UgKiBzZWxmLnN0eWxlLmNlbGxIZWlnaHQpO1xuICAgICAgICAgICAgICAgIHNlbGYuc2Nyb2xsVGltZXIgPSBzZXRUaW1lb3V0KHNlbGYuc2Nyb2xsR3JpZCwgc2VsZi5hdHRyaWJ1dGVzLnNjcm9sbFJlcGVhdFJhdGUsIGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxmLnNjcm9sbE1vZGUgPT09ICd2ZXJ0aWNhbC1zY3JvbGwtYm90dG9tJykge1xuICAgICAgICAgICAgICAgIHNlbGYuc2Nyb2xsQm94LnNjcm9sbFRvcCArPSAoc2VsZi5wYWdlICogc2VsZi5zdHlsZS5jZWxsSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBzZWxmLnNjcm9sbFRpbWVyID0gc2V0VGltZW91dChzZWxmLnNjcm9sbEdyaWQsIHNlbGYuYXR0cmlidXRlcy5zY3JvbGxSZXBlYXRSYXRlLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLnNjcm9sbE1vZGUgPT09ICdob3Jpem9udGFsLXNjcm9sbC1ib3gnKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxCb3guc2Nyb2xsTGVmdCA9IHNlbGYuc2Nyb2xsU3RhcnQubGVmdCArICgocG9zLnggLSBzZWxmLmRyYWdTdGFydC54KVxuICAgICAgICAgICAgICAgICAgICAvIHNlbGYuc2Nyb2xsQm94LndpZHRoQm94UmF0aW8pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxmLnNjcm9sbE1vZGUgPT09ICdob3Jpem9udGFsLXNjcm9sbC1yaWdodCcpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNjcm9sbEJveC5zY3JvbGxMZWZ0ICs9IHNlbGYuYXR0cmlidXRlcy5zZWxlY3Rpb25TY3JvbGxJbmNyZW1lbnQ7XG4gICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxUaW1lciA9IHNldFRpbWVvdXQoc2VsZi5zY3JvbGxHcmlkLCBzZWxmLmF0dHJpYnV0ZXMuc2Nyb2xsUmVwZWF0UmF0ZSwgZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGYuc2Nyb2xsTW9kZSA9PT0gJ2hvcml6b250YWwtc2Nyb2xsLWxlZnQnKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxCb3guc2Nyb2xsTGVmdCAtPSBzZWxmLmF0dHJpYnV0ZXMuc2VsZWN0aW9uU2Nyb2xsSW5jcmVtZW50O1xuICAgICAgICAgICAgICAgIHNlbGYuc2Nyb2xsVGltZXIgPSBzZXRUaW1lb3V0KHNlbGYuc2Nyb2xsR3JpZCwgc2VsZi5hdHRyaWJ1dGVzLnNjcm9sbFJlcGVhdFJhdGUsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzZWxmLnN0b3BTY3JvbGxHcmlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuc2Nyb2xsVGltZXIpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBzZWxmLnNjcm9sbEdyaWQsIGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5kcmFnUmVvcmRlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgcG9zLCB4LCB5O1xuICAgICAgICAgICAgcG9zID0gc2VsZi5nZXRMYXllclBvcyhlKTtcbiAgICAgICAgICAgIHggPSBwb3MueCAtIHNlbGYuZHJhZ1N0YXJ0Lng7XG4gICAgICAgICAgICB5ID0gcG9zLnkgLSBzZWxmLmRyYWdTdGFydC55O1xuICAgICAgICAgICAgaWYgKCFzZWxmLmF0dHJpYnV0ZXMuYWxsb3dDb2x1bW5SZW9yZGVyaW5nICYmIHNlbGYuZHJhZ01vZGUgPT09ICdjb2x1bW4tcmVvcmRlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNlbGYuYXR0cmlidXRlcy5hbGxvd1Jvd1Jlb3JkZXJpbmcgJiYgc2VsZi5kcmFnTW9kZSA9PT0gJ3Jvdy1yZW9yZGVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmRpc3BhdGNoRXZlbnQoJ3Jlb3JkZXJpbmcnLCBbZSwgc2VsZi5kcmFnU3RhcnRPYmplY3QsIHNlbGYuY3VycmVudENlbGwsIHNlbGYuZHJhZ01vZGVdLCBzZWxmLmludGYpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHgpID4gc2VsZi5hdHRyaWJ1dGVzLnJlb3JkZXJEZWFkWm9uZSB8fCBNYXRoLmFicyh5KSA+IHNlbGYuYXR0cmlidXRlcy5yZW9yZGVyRGVhZFpvbmUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnJlb3JkZXJPYmplY3QgPSBzZWxmLmRyYWdTdGFydE9iamVjdDtcbiAgICAgICAgICAgICAgICBzZWxmLnJlb3JkZXJUYXJnZXQgPSBzZWxmLmN1cnJlbnRDZWxsO1xuICAgICAgICAgICAgICAgIHNlbGYucmVvcmRlck9iamVjdC5kcmFnT2Zmc2V0ID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgICAgICB5OiB5XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzZWxmLmF1dG9TY3JvbGxab25lKGUsIHBvcy54LCBwb3MueCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzZWxmLnN0b3BEcmFnUmVvcmRlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgY3IgPSB7XG4gICAgICAgICAgICAgICAgICAgICdyb3ctcmVvcmRlcic6IHNlbGYub3JkZXJzLnJvd3MsXG4gICAgICAgICAgICAgICAgICAgICdjb2x1bW4tcmVvcmRlcic6IHNlbGYub3JkZXJzLmNvbHVtbnNcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGkgPSB7XG4gICAgICAgICAgICAgICAgICAgICdyb3ctcmVvcmRlcic6ICdyb3dJbmRleCcsXG4gICAgICAgICAgICAgICAgICAgICdjb2x1bW4tcmVvcmRlcic6ICdjb2x1bW5JbmRleCdcbiAgICAgICAgICAgICAgICB9W3NlbGYuZHJhZ01vZGVdO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBzZWxmLmRyYWdSZW9yZGVyLCBmYWxzZSk7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBzZWxmLnN0b3BEcmFnUmVvcmRlciwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKHNlbGYucmVvcmRlck9iamVjdFxuICAgICAgICAgICAgICAgICAgICAmJiBzZWxmLnJlb3JkZXJUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmlnbm9yZU5leHRDbGljayA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYucmVvcmRlck9iamVjdFtpXSAhPT0gc2VsZi5yZW9yZGVyVGFyZ2V0W2ldXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiAhc2VsZi5kaXNwYXRjaEV2ZW50KCdyZW9yZGVyJywgW2UsIHNlbGYucmVvcmRlck9iamVjdCwgc2VsZi5yZW9yZGVyVGFyZ2V0LCBzZWxmLmRyYWdNb2RlXSwgc2VsZi5pbnRmKSkge1xuICAgICAgICAgICAgICAgICAgICBjcltzZWxmLmRyYWdNb2RlXS5zcGxpY2UoY3Jbc2VsZi5kcmFnTW9kZV0uaW5kZXhPZihzZWxmLnJlb3JkZXJPYmplY3RbaV0pLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgY3Jbc2VsZi5kcmFnTW9kZV0uc3BsaWNlKGNyW3NlbGYuZHJhZ01vZGVdLmluZGV4T2Yoc2VsZi5yZW9yZGVyVGFyZ2V0W2ldKSwgMCwgc2VsZi5yZW9yZGVyT2JqZWN0W2ldKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXRTdG9yYWdlRGF0YSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYucmVvcmRlck9iamVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHNlbGYucmVvcmRlclRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHNlbGYuZHJhdyh0cnVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5tb3VzZWRvd24gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKHNlbGYuZGlzcGF0Y2hFdmVudCgnbW91c2Vkb3duJywgW2UsIHNlbGYuY3VycmVudENlbGxdLCBzZWxmLmludGYpKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgaWYgKCFzZWxmLmhhc0ZvY3VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUuYnV0dG9uID09PSAyIHx8IHNlbGYuaW5wdXQpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICB2YXIgY3RybCA9IChlLmNvbnRyb2xLZXkgfHwgZS5tZXRhS2V5KTtcbiAgICAgICAgICAgIHNlbGYuZHJhZ1N0YXJ0ID0gc2VsZi5nZXRMYXllclBvcyhlKTtcbiAgICAgICAgICAgIHNlbGYuc2Nyb2xsU3RhcnQgPSB7XG4gICAgICAgICAgICAgICAgbGVmdDogc2VsZi5zY3JvbGxCb3guc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgICAgICB0b3A6IHNlbGYuc2Nyb2xsQm94LnNjcm9sbFRvcFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNlbGYuZHJhZ1N0YXJ0T2JqZWN0ID0gc2VsZi5nZXRDZWxsQXQoc2VsZi5kcmFnU3RhcnQueCwgc2VsZi5kcmFnU3RhcnQueSk7XG4gICAgICAgICAgICBzZWxmLmRyYWdBZGRUb1NlbGVjdGlvbiA9ICFzZWxmLmRyYWdTdGFydE9iamVjdC5zZWxlY3RlZDtcbiAgICAgICAgICAgIGlmICghY3RybCAmJiAhZS5zaGlmdEtleSAmJiAhLyh2ZXJ0aWNhbHxob3Jpem9udGFsKS1zY3JvbGwtKGJhcnxib3gpL1xuICAgICAgICAgICAgICAgICAgICAudGVzdChzZWxmLmRyYWdTdGFydE9iamVjdC5jb250ZXh0KSkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuZHJhZ1N0YXJ0T2JqZWN0LmlzR3JpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLnNjcm9sbE1vZGVzLmluZGV4T2Yoc2VsZi5kcmFnU3RhcnRPYmplY3QuY29udGV4dCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxNb2RlID0gc2VsZi5kcmFnU3RhcnRPYmplY3QuY29udGV4dDtcbiAgICAgICAgICAgICAgICBzZWxmLnNjcm9sbFN0YXJ0TW9kZSA9IHNlbGYuZHJhZ1N0YXJ0T2JqZWN0LmNvbnRleHQ7XG4gICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxHcmlkKGUpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgc2VsZi5zY3JvbGxHcmlkLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgc2VsZi5zdG9wU2Nyb2xsR3JpZCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHNlbGYuaWdub3JlTmV4dENsaWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5kcmFnTW9kZSA9PT0gJ2NlbGwnKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmF0dHJpYnV0ZXMucm93U2VsZWN0aW9uTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdFJvdyhzZWxmLmRyYWdTdGFydE9iamVjdC5yb3dJbmRleCwgY3RybCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLm1vdXNlbW92ZShlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChbJ25zLXJlc2l6ZScsICdldy1yZXNpemUnXS5pbmRleE9mKHNlbGYuZHJhZ01vZGUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHNlbGYuZHJhZ2dpbmdJdGVtID0gc2VsZi5kcmFnSXRlbTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5kcmFnZ2luZ0l0ZW0ucm93T3Blbikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnJlc2l6aW5nU3RhcnRpbmdIZWlnaHQgPSBzZWxmLnNpemVzLnRyZWVzW3NlbGYuZHJhZ2dpbmdJdGVtLmRhdGFbc2VsZi51bmlxdWVJZF1dO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmVzaXppbmdTdGFydGluZ0hlaWdodCA9IHNlbGYuc2l6ZXMucm93c1tzZWxmLmRyYWdnaW5nSXRlbS5kYXRhW3NlbGYudW5pcXVlSWRdXSB8fCBzZWxmLnN0eWxlLmNlbGxIZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYucmVzaXppbmdTdGFydGluZ1dpZHRoID0gc2VsZi5zaXplcy5jb2x1bW5zW3NlbGYuZHJhZ2dpbmdJdGVtLmhlYWRlci5zdHlsZSA9PT0gJ3Jvd0hlYWRlckNlbGwnXG4gICAgICAgICAgICAgICAgICAgICAgID8gJ2Nvcm5lckNlbGwnIDogc2VsZi5kcmFnZ2luZ0l0ZW0uaGVhZGVyW3NlbGYudW5pcXVlSWRdXSB8fCBzZWxmLmRyYWdnaW5nSXRlbS5oZWFkZXIud2lkdGg7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBzZWxmLmRyYWdSZXNpemVDb2x1bW4sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBzZWxmLnN0b3BEcmFnUmVzaXplLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoWydyb3ctcmVvcmRlcicsICdjb2x1bW4tcmVvcmRlciddLmluZGV4T2Yoc2VsZi5kcmFnTW9kZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5kcmFnZ2luZ0l0ZW0gPSBzZWxmLmRyYWdJdGVtO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgc2VsZi5kcmFnUmVvcmRlciwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHNlbGYuc3RvcERyYWdSZW9yZGVyLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHNlbGYubW91c2V1cCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoc2VsZi5zY3JvbGxUaW1lcik7XG4gICAgICAgICAgICBzZWxmLmNlbGxCb3VuZGFyeUNyb3NzZWQgPSB0cnVlO1xuICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdtb3VzZXVwJywgW2UsIHNlbGYuY3VycmVudENlbGxdLCBzZWxmLmludGYpO1xuICAgICAgICAgICAgaWYgKCFzZWxmLmhhc0ZvY3VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuY3VycmVudENlbGwgJiYgc2VsZi5jdXJyZW50Q2VsbC5ncmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5vbnRleHRNZW51IHx8IHNlbGYuaW5wdXQpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICBzZWxmLnNlbGVjdGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHNlbGYuZHJhZ2dpbmdJdGVtID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHNlbGYuZHJhZ1N0YXJ0ICYmIHNlbGYuaXNJbkdyaWQoc2VsZi5kcmFnU3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb250cm9sSW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuZHJhZ1N0YXJ0T2JqZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9O1xuICAgICAgICBzZWxmLmtleWRvd24gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgeCA9IHNlbGYuYWN0aXZlQ2VsbC5jb2x1bW5JbmRleCxcbiAgICAgICAgICAgICAgICB5ID0gc2VsZi5hY3RpdmVDZWxsLnJvd0luZGV4LFxuICAgICAgICAgICAgICAgIGN0cmwgPSAoZS5jb250cm9sS2V5IHx8IGUubWV0YUtleSksXG4gICAgICAgICAgICAgICAgbGFzdCA9IHNlbGYuZGF0YS5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICAgIGNvbHMgPSBzZWxmLmdldFZpc2libGVTY2hlbWEoKS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKHNlbGYuZGlzcGF0Y2hFdmVudCgna2V5ZG93bicsIFtlLCBzZWxmLmN1cnJlbnRDZWxsXSwgc2VsZi5pbnRmKSkgeyByZXR1cm47IH1cbiAgICAgICAgICAgIGlmICghc2VsZi5oYXNGb2N1cykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYucGFnZSA9IHNlbGYudmlzaWJsZVJvd3MubGVuZ3RoIC0gMyAtIHNlbGYuYXR0cmlidXRlcy5wYWdlVXBEb3duT3ZlcmxhcDtcbiAgICAgICAgICAgIGlmIChzZWxmLmF0dHJpYnV0ZXMuc2hvd05ld1Jvdykge1xuICAgICAgICAgICAgICAgIGxhc3QgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT09ICdUYWInKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9BcnJvd0Rvd25cbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT09IDQwKSB7XG4gICAgICAgICAgICAgICAgeSArPSAxO1xuICAgICAgICAgICAgLy9BcnJvd1VwXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGUua2V5Q29kZSA9PT0gMzgpIHtcbiAgICAgICAgICAgICAgICB5IC09IDE7XG4gICAgICAgICAgICAvL0Fycm93TGVmdCBUYWJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5rZXlDb2RlID09PSAzNyB8fCAoZS5zaGlmdEtleSAmJiBlLmtleUNvZGUgPT09IDkpKSB7XG4gICAgICAgICAgICAgICAgeCAtPSAxO1xuICAgICAgICAgICAgLy9BcnJvd1JpZ2h0IFRhYlxuICAgICAgICAgICAgfSBlbHNlIGlmIChlLmtleUNvZGUgPT09IDM5IHx8ICghZS5zaGlmdEtleSAmJiBlLmtleUNvZGUgPT09IDkpKSB7XG4gICAgICAgICAgICAgICAgeCArPSAxO1xuICAgICAgICAgICAgLy9QYWdlVXBcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5rZXlDb2RlID09PSAzMykge1xuICAgICAgICAgICAgICAgIHkgLT0gc2VsZi5wYWdlO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIC8vUGFnZURvd25cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5rZXlDb2RlID09PSAzNCkge1xuICAgICAgICAgICAgICAgIHkgKz0gc2VsZi5wYWdlO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIC8vSG9tZSBBcnJvd1VwXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGUua2V5Q29kZSA9PT0gMzYgfHwgKGN0cmwgJiYgZS5rZXlDb2RlID09PSAzOCkpIHtcbiAgICAgICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgICAgIC8vRW5kIEFycm93RG93blxuICAgICAgICAgICAgfSBlbHNlIGlmIChlLmtleUNvZGUgPT09IDM1IHx8IChjdHJsICYmIGUua2V5Q29kZSA9PT0gNDApKSB7XG4gICAgICAgICAgICAgICAgeSA9IHNlbGYuZGF0YS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgLy9BcnJvd1JpZ2h0XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN0cmwgJiYgZS5rZXlDb2RlID09PSAzOSkge1xuICAgICAgICAgICAgICAgIHggPSBjb2xzO1xuICAgICAgICAgICAgLy9BcnJvd0xlZnRcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3RybCAmJiBlLmtleUNvZGUgPT09IDM3KSB7XG4gICAgICAgICAgICAgICAgeCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL0VudGVyXG4gICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09PSAxMykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmJlZ2luRWRpdEF0KHgsIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9TcGFjZVxuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMzIpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGlvbnNbTWF0aC5tYXgoeSwgMCldID0gW107XG4gICAgICAgICAgICAgICAgc2VsZi5zZWxlY3Rpb25zW01hdGgubWF4KHksIDApXS5wdXNoKHgpO1xuICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0aW9uQm91bmRzID0gc2VsZi5nZXRTZWxlY3Rpb25Cb3VuZHMoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5hdHRyaWJ1dGVzLnJvd1NlbGVjdGlvbk1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gc2VsZi5zZWxlY3Rpb25Cb3VuZHMudG9wOyBpIDw9IHNlbGYuc2VsZWN0aW9uQm91bmRzLmJvdHRvbTsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdFJvdyhpLCBjdHJsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0QXJlYSh1bmRlZmluZWQsIGN0cmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgc2VsZi5kcmF3KHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4IDwgMCkge1xuICAgICAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHkgPiBsYXN0KSB7XG4gICAgICAgICAgICAgICAgeSA9IGxhc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeSA8IDApIHtcbiAgICAgICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4ID4gY29scykge1xuICAgICAgICAgICAgICAgIHggPSBjb2xzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXJyb3dzXG4gICAgICAgICAgICBpZiAoZS5zaGlmdEtleSAmJiBbMzcsIDM4LCAzOSwgNDBdLmluZGV4T2YoZS5rZXlDb2RlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGlvbnNbTWF0aC5tYXgoeSwgMCldID0gc2VsZi5zZWxlY3Rpb25zW01hdGgubWF4KHksIDApXSB8fCBbXTtcbiAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGlvbnNbTWF0aC5tYXgoeSwgMCldLnB1c2goeCk7XG4gICAgICAgICAgICAgICAgc2VsZi5zZWxlY3Rpb25Cb3VuZHMgPSBzZWxmLmdldFNlbGVjdGlvbkJvdW5kcygpO1xuICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0QXJlYSh1bmRlZmluZWQsIGN0cmwpO1xuICAgICAgICAgICAgICAgIHNlbGYuZHJhdyh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4ICE9PSBzZWxmLmFjdGl2ZUNlbGwuY29sdW1uSW5kZXggfHwgeSAhPT0gc2VsZi5hY3RpdmVDZWxsLnJvd0luZGV4KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxJbnRvVmlldyh4ICE9PSBzZWxmLmFjdGl2ZUNlbGwuY29sdW1uSW5kZXggPyB4IDogdW5kZWZpbmVkLCB5ICE9PSBzZWxmLmFjdGl2ZUNlbGwucm93SW5kZXggPyB5IDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICBzZWxmLnNldEFjdGl2ZUNlbGwoeCwgeSk7XG4gICAgICAgICAgICAgICAgaWYgKCFlLnNoaWZ0S2V5ICYmIHNlbGYuYXR0cmlidXRlcy5zZWxlY3Rpb25Gb2xsb3dzQWN0aXZlQ2VsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN0cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0aW9uc1t5XSA9IHNlbGYuc2VsZWN0aW9uc1t5XSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxlY3Rpb25zW3ldLnB1c2goeCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnc2VsZWN0aW9uY2hhbmdlZCcsIFtzZWxmLmdldFNlbGVjdGVkRGF0YSgpLCBzZWxmLnNlbGVjdGlvbnMsIHNlbGYuc2VsZWN0aW9uQm91bmRzXSwgc2VsZi5pbnRmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5kcmF3KHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzZWxmLmtleXVwID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmRpc3BhdGNoRXZlbnQoJ2tleXVwJywgW2UsIHNlbGYuY3VycmVudENlbGxdLCBzZWxmLmludGYpKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgaWYgKCFzZWxmLmhhc0ZvY3VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5jb250cm9sSW5wdXQudmFsdWUgPSAnJztcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5rZXlwcmVzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoIXNlbGYuaGFzRm9jdXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5kaXNwYXRjaEV2ZW50KCdrZXlwcmVzcycsIFtlLCBzZWxmLmN1cnJlbnRDZWxsXSwgc2VsZi5pbnRmKSkgeyByZXR1cm47IH1cbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5kYmxjbGljayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5kaXNwYXRjaEV2ZW50KCdkYmxjbGljaycsIFtlLCBzZWxmLmN1cnJlbnRDZWxsXSwgc2VsZi5pbnRmKSkgeyByZXR1cm47IH1cbiAgICAgICAgICAgIGlmICghc2VsZi5oYXNGb2N1cykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmN1cnJlbnRDZWxsLmNvbnRleHQgPT09ICdldy1yZXNpemUnXG4gICAgICAgICAgICAgICAgICAgICYmIHNlbGYuY3VycmVudENlbGwuc3R5bGUgPT09ICdoZWFkZXJDZWxsJykge1xuICAgICAgICAgICAgICAgIHNlbGYuZml0Q29sdW1uVG9WYWx1ZXMoc2VsZi5jdXJyZW50Q2VsbC5oZWFkZXIubmFtZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGYuY3VycmVudENlbGwuY29udGV4dCA9PT0gJ2V3LXJlc2l6ZSdcbiAgICAgICAgICAgICAgICAgICAgJiYgc2VsZi5jdXJyZW50Q2VsbC5zdHlsZSA9PT0gJ2Nvcm5lckNlbGwnKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5hdXRvc2l6ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChbJ2NlbGwnLCAnYWN0aXZlQ2VsbCddLmluZGV4T2Yoc2VsZi5jdXJyZW50Q2VsbC5zdHlsZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5iZWdpbkVkaXRBdChzZWxmLmN1cnJlbnRDZWxsLmNvbHVtbkluZGV4LCBzZWxmLmN1cnJlbnRDZWxsLnJvd0luZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5zY3JvbGxXaGVlbCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5kaXNwYXRjaEV2ZW50KCdtb3VzZXdoZWVsJywgW2UsIHNlbGYuY3R4XSwgc2VsZi5pbnRmKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsID0gc2VsZi5zY3JvbGxCb3guc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgICAgICB0ID0gc2VsZi5zY3JvbGxCb3guc2Nyb2xsVG9wO1xuICAgICAgICAgICAgaWYgKHNlbGYuaGFzRm9jdXMpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNjcm9sbEJveC5zY3JvbGxUb3AgLT0gZS53aGVlbERlbHRhWTtcbiAgICAgICAgICAgICAgICBzZWxmLnNjcm9sbEJveC5zY3JvbGxMZWZ0IC09IGUud2hlZWxEZWx0YVg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodCAhPT0gc2VsZi5zY3JvbGxCb3guc2Nyb2xsVG9wIHx8IGwgIT09IHNlbGYuc2Nyb2xsQm94LnNjcm9sbExlZnQpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHNlbGYuY29weSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgcm93cyA9IFtdLCBzRGF0YSA9IHNlbGYuZ2V0U2VsZWN0ZWREYXRhKCk7XG4gICAgICAgICAgICBzRGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgICAgICBpZiAocm93KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gW107XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHJvdykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByLnB1c2gocm93W2tleV0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgci5qb2luKCcsJyk7XG4gICAgICAgICAgICAgICAgICAgIHJvd3MucHVzaChyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGUuY2xpcGJvYXJkRGF0YS5zZXREYXRhKCd0ZXh0L3BsYWluJywgcm93cy5qb2luKCdcXG4nKSk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9ldmVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/*!*********************!*\
  !*** ./lib/intf.js ***!
  \*********************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jslint browser: true, unparam: true, todo: true*/\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n    'use strict';\n    return function (self) {\n        self.intf.blur = function () {\n            self.hasFocus = false;\n        };\n        self.intf.focus = function () {\n            self.hasFocus = true;\n            self.controlInput.focus();\n        };\n        Object.defineProperty(self.intf, 'height', {\n            get: function () {\n                return self.parentNode.height;\n            },\n            set: function (value) {\n                self.parentNode.height = value;\n                self.resize(true);\n            }\n        });\n        Object.defineProperty(self.intf, 'width', {\n            get: function () {\n                return self.parentNode.width;\n            },\n            set: function (value) {\n                self.parentNode.width = value;\n                self.resize(true);\n            }\n        });\n        Object.defineProperty(self.intf, 'openChildren', {\n            get: function () {\n                return self.openChildren;\n            }\n        });\n        Object.defineProperty(self.intf, 'childGrids', {\n            get: function () {\n                return self.childGrids;\n            }\n        });\n        Object.defineProperty(self.intf, 'isChildGrid', {\n            get: function () {\n                return self.isChildGrid;\n            }\n        });\n        Object.defineProperty(self.intf, 'parentNode', {\n            get: function () {\n                return self.parentNode;\n            },\n            set: function (value) {\n                self.parentNode = value;\n            }\n        });\n        Object.defineProperty(self.intf, 'offsetParent', {\n            get: function () {\n                return self.parentNode;\n            },\n            set: function (value) {\n                self.parentNode = value;\n            }\n        });\n        Object.defineProperty(self.intf, 'offsetLeft', {\n            get: function () {\n                return self.parentNode.offsetLeft;\n            }\n        });\n        Object.defineProperty(self.intf, 'offsetTop', {\n            get: function () {\n                return self.parentNode.offsetTop;\n            }\n        });\n        Object.defineProperty(self.intf, 'scrollHeight', {\n            get: function () {\n                return self.scrollBox.scrollHeight;\n            }\n        });\n        Object.defineProperty(self.intf, 'scrollWidth', {\n            get: function () {\n                return self.scrollBox.scrollWidth;\n            }\n        });\n        Object.defineProperty(self.intf, 'scrollTop', {\n            get: function () {\n                return self.scrollBox.scrollTop;\n            },\n            set: function (value) {\n                self.scrollBox.scrollTop = value;\n            }\n        });\n        Object.defineProperty(self.intf, 'scrollLeft', {\n            get: function () {\n                return self.scrollBox.scrollLeft;\n            },\n            set: function (value) {\n                self.scrollBox.scrollLeft = value;\n            }\n        });\n        Object.defineProperty(self.intf, 'sizes', {\n            get: function () {\n                return self.sizes;\n            }\n        });\n        Object.defineProperty(self.intf, 'input', {\n            get: function () {\n                return self.input;\n            }\n        });\n        Object.defineProperty(self.intf, 'controlInput', {\n            get: function () {\n                return self.controlInput;\n            }\n        });\n        Object.defineProperty(self.intf, 'currentCell', {\n            get: function () {\n                return self.currentCell;\n            }\n        });\n        Object.defineProperty(self.intf, 'visibleCells', {\n            get: function () {\n                return self.visibleCells;\n            }\n        });\n        Object.defineProperty(self.intf, 'visibleRows', {\n            get: function () {\n                return self.visibleRows;\n            }\n        });\n        Object.defineProperty(self.intf, 'selections', {\n            get: function () {\n                return self.selections;\n            }\n        });\n        Object.defineProperty(self.intf, 'dragMode', {\n            get: function () {\n                return self.dragMode;\n            }\n        });\n        Object.defineProperty(self.intf, 'changes', {\n            get: function () {\n                return self.changes;\n            }\n        });\n        self.intf.attributes = {};\n        self.intf.style = {};\n        self.intf.formatters = self.formatters;\n        Object.defineProperty(self.intf, 'selectionBounds', {\n            get: function () {\n                return self.getSelectionBounds();\n            }\n        });\n        Object.defineProperty(self.intf, 'selectedRows', {\n            get: function () {\n                return self.getSelectedData(true);\n            }\n        });\n        Object.defineProperty(self.intf, 'selectedCells', {\n            get: function () {\n                return self.getSelectedData();\n            }\n        });\n        Object.defineProperty(self.intf, 'visibleSchema', {\n            get: function () {\n                return self.getVisibleSchema().map(function eachDataRow(col) {\n                    return col;\n                });\n            }\n        });\n        Object.defineProperty(self.intf, 'schema', {\n            get: function schemaGetter() {\n                return self.getSchema();\n            },\n            set: function schemaSetter(value) {\n                if (!Array.isArray(value) || typeof value[0] !== 'object') {\n                    throw new Error('Schema must be an array of objects.');\n                }\n                if (value[0].name === undefined) {\n                    throw new Error('Expected schema to contain an object with at least a name property.');\n                }\n                self.schema = value.map(function eachSchemaColumn(column, index) {\n                    column.width = column.width || self.style.columnWidth;\n                    column[self.uniqueId] = self.getSchemaNameHash(column.name);\n                    column.filter = column.filter || self.filter(column.type);\n                    column.type = column.type || 'string';\n                    column.index = index;\n                    column.columnIndex = index;\n                    column.rowIndex = -1;\n                    return column;\n                });\n                self.tempSchema = undefined;\n                self.createNewRowData();\n                self.createColumnOrders();\n                self.tryLoadStoredOrders();\n                self.resize(true);\n                self.dispatchEvent('schemachanged', [self.schema], self.intf);\n            }\n        });\n        Object.defineProperty(self.intf, 'data', {\n            get: function dataGetter() {\n                return self.data;\n            },\n            set: function dataSetter(value) {\n                if (!Array.isArray(value)\n                        || (value.length > 0 && typeof value[0] !== 'object')) {\n                    throw new Error('Data must be an array of objects.');\n                }\n                self.originalData = value.map(function eachDataRow(row) {\n                    row[self.uniqueId] = self.uId;\n                    self.uId += 1;\n                    return row;\n                });\n                self.changes = [];\n                //TODO apply filter to incoming dataset\n                self.data = self.originalData;\n                if (!self.schema && self.data.length > 0) {\n                    self.tempSchema = self.getSchemaFromData();\n                }\n                if (!self.schema && self.data.length === 0) {\n                    self.tempSchema = [{name: ''}];\n                    self.tempSchema[0][self.uniqueId] = self.getSchemaNameHash('');\n                }\n                if (self.tempSchema && !self.schema) {\n                    self.createColumnOrders();\n                    self.tryLoadStoredOrders();\n                    self.dispatchEvent('schemachanged', [self.tempSchema], self.intf);\n                }\n                self.createNewRowData();\n                if (self.attributes.autoResizeColumns && self.data.length > 0\n                        && self.storedSettings === undefined) {\n                    self.autosize();\n                }\n                // width cannot be determined correctly until after inserted into the dom?\n                requestAnimationFrame(function () {\n                    self.fitColumnToValues('cornerCell');\n                });\n                if (!self.resize()) { self.draw(true); }\n                self.createRowOrders();\n                self.tryLoadStoredOrders();\n                self.dispatchEvent('datachanged', [self.data], self.intf);\n            }\n        });\n        return;\n    };\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi9pbnRmLmpzPzUyNDkiXSwic291cmNlc0NvbnRlbnQiOlsiLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgdW5wYXJhbTogdHJ1ZSwgdG9kbzogdHJ1ZSovXG4vKmdsb2JhbHMgZGVmaW5lOiB0cnVlLCBNdXRhdGlvbk9ic2VydmVyOiBmYWxzZSwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lOiBmYWxzZSwgcGVyZm9ybWFuY2U6IGZhbHNlLCBidG9hOiBmYWxzZSovXG5kZWZpbmUoW10sIGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzZWxmKSB7XG4gICAgICAgIHNlbGYuaW50Zi5ibHVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi5oYXNGb2N1cyA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBzZWxmLmludGYuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLmhhc0ZvY3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHNlbGYuY29udHJvbElucHV0LmZvY3VzKCk7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLmludGYsICdoZWlnaHQnLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5wYXJlbnROb2RlLmhlaWdodDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHNlbGYucGFyZW50Tm9kZS5oZWlnaHQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBzZWxmLnJlc2l6ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLmludGYsICd3aWR0aCcsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnBhcmVudE5vZGUud2lkdGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnBhcmVudE5vZGUud2lkdGggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBzZWxmLnJlc2l6ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLmludGYsICdvcGVuQ2hpbGRyZW4nLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5vcGVuQ2hpbGRyZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZi5pbnRmLCAnY2hpbGRHcmlkcycsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNoaWxkR3JpZHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZi5pbnRmLCAnaXNDaGlsZEdyaWQnLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5pc0NoaWxkR3JpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLmludGYsICdwYXJlbnROb2RlJywge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHNlbGYucGFyZW50Tm9kZSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuaW50ZiwgJ29mZnNldFBhcmVudCcsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnBhcmVudE5vZGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLmludGYsICdvZmZzZXRMZWZ0Jywge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucGFyZW50Tm9kZS5vZmZzZXRMZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuaW50ZiwgJ29mZnNldFRvcCcsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnBhcmVudE5vZGUub2Zmc2V0VG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuaW50ZiwgJ3Njcm9sbEhlaWdodCcsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnNjcm9sbEJveC5zY3JvbGxIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZi5pbnRmLCAnc2Nyb2xsV2lkdGgnLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5zY3JvbGxCb3guc2Nyb2xsV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZi5pbnRmLCAnc2Nyb2xsVG9wJywge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuc2Nyb2xsQm94LnNjcm9sbFRvcDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2Nyb2xsQm94LnNjcm9sbFRvcCA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuaW50ZiwgJ3Njcm9sbExlZnQnLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5zY3JvbGxCb3guc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2Nyb2xsQm94LnNjcm9sbExlZnQgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLmludGYsICdzaXplcycsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnNpemVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuaW50ZiwgJ2lucHV0Jywge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuaW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZi5pbnRmLCAnY29udHJvbElucHV0Jywge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY29udHJvbElucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuaW50ZiwgJ2N1cnJlbnRDZWxsJywge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY3VycmVudENlbGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZi5pbnRmLCAndmlzaWJsZUNlbGxzJywge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYudmlzaWJsZUNlbGxzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuaW50ZiwgJ3Zpc2libGVSb3dzJywge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYudmlzaWJsZVJvd3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZi5pbnRmLCAnc2VsZWN0aW9ucycsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnNlbGVjdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZi5pbnRmLCAnZHJhZ01vZGUnLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5kcmFnTW9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLmludGYsICdjaGFuZ2VzJywge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2hhbmdlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNlbGYuaW50Zi5hdHRyaWJ1dGVzID0ge307XG4gICAgICAgIHNlbGYuaW50Zi5zdHlsZSA9IHt9O1xuICAgICAgICBzZWxmLmludGYuZm9ybWF0dGVycyA9IHNlbGYuZm9ybWF0dGVycztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuaW50ZiwgJ3NlbGVjdGlvbkJvdW5kcycsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmdldFNlbGVjdGlvbkJvdW5kcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuaW50ZiwgJ3NlbGVjdGVkUm93cycsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmdldFNlbGVjdGVkRGF0YSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLmludGYsICdzZWxlY3RlZENlbGxzJywge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0U2VsZWN0ZWREYXRhKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZi5pbnRmLCAndmlzaWJsZVNjaGVtYScsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmdldFZpc2libGVTY2hlbWEoKS5tYXAoZnVuY3Rpb24gZWFjaERhdGFSb3coY29sKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2w7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZi5pbnRmLCAnc2NoZW1hJywge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBzY2hlbWFHZXR0ZXIoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0U2NoZW1hKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzY2hlbWFTZXR0ZXIodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZVswXSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTY2hlbWEgbXVzdCBiZSBhbiBhcnJheSBvZiBvYmplY3RzLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWVbMF0ubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgc2NoZW1hIHRvIGNvbnRhaW4gYW4gb2JqZWN0IHdpdGggYXQgbGVhc3QgYSBuYW1lIHByb3BlcnR5LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLnNjaGVtYSA9IHZhbHVlLm1hcChmdW5jdGlvbiBlYWNoU2NoZW1hQ29sdW1uKGNvbHVtbiwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uLndpZHRoID0gY29sdW1uLndpZHRoIHx8IHNlbGYuc3R5bGUuY29sdW1uV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbltzZWxmLnVuaXF1ZUlkXSA9IHNlbGYuZ2V0U2NoZW1hTmFtZUhhc2goY29sdW1uLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4uZmlsdGVyID0gY29sdW1uLmZpbHRlciB8fCBzZWxmLmZpbHRlcihjb2x1bW4udHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbi50eXBlID0gY29sdW1uLnR5cGUgfHwgJ3N0cmluZyc7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbi5pbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4uY29sdW1uSW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uLnJvd0luZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2x1bW47XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2VsZi50ZW1wU2NoZW1hID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHNlbGYuY3JlYXRlTmV3Um93RGF0YSgpO1xuICAgICAgICAgICAgICAgIHNlbGYuY3JlYXRlQ29sdW1uT3JkZXJzKCk7XG4gICAgICAgICAgICAgICAgc2VsZi50cnlMb2FkU3RvcmVkT3JkZXJzKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5yZXNpemUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdzY2hlbWFjaGFuZ2VkJywgW3NlbGYuc2NoZW1hXSwgc2VsZi5pbnRmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLmludGYsICdkYXRhJywge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBkYXRhR2V0dGVyKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmRhdGE7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBkYXRhU2V0dGVyKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgKHZhbHVlLmxlbmd0aCA+IDAgJiYgdHlwZW9mIHZhbHVlWzBdICE9PSAnb2JqZWN0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIG11c3QgYmUgYW4gYXJyYXkgb2Ygb2JqZWN0cy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5vcmlnaW5hbERhdGEgPSB2YWx1ZS5tYXAoZnVuY3Rpb24gZWFjaERhdGFSb3cocm93KSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd1tzZWxmLnVuaXF1ZUlkXSA9IHNlbGYudUlkO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnVJZCArPSAxO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm93O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNlbGYuY2hhbmdlcyA9IFtdO1xuICAgICAgICAgICAgICAgIC8vVE9ETyBhcHBseSBmaWx0ZXIgdG8gaW5jb21pbmcgZGF0YXNldFxuICAgICAgICAgICAgICAgIHNlbGYuZGF0YSA9IHNlbGYub3JpZ2luYWxEYXRhO1xuICAgICAgICAgICAgICAgIGlmICghc2VsZi5zY2hlbWEgJiYgc2VsZi5kYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi50ZW1wU2NoZW1hID0gc2VsZi5nZXRTY2hlbWFGcm9tRGF0YSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXNlbGYuc2NoZW1hICYmIHNlbGYuZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi50ZW1wU2NoZW1hID0gW3tuYW1lOiAnJ31dO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnRlbXBTY2hlbWFbMF1bc2VsZi51bmlxdWVJZF0gPSBzZWxmLmdldFNjaGVtYU5hbWVIYXNoKCcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYudGVtcFNjaGVtYSAmJiAhc2VsZi5zY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jcmVhdGVDb2x1bW5PcmRlcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi50cnlMb2FkU3RvcmVkT3JkZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnc2NoZW1hY2hhbmdlZCcsIFtzZWxmLnRlbXBTY2hlbWFdLCBzZWxmLmludGYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLmNyZWF0ZU5ld1Jvd0RhdGEoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5hdHRyaWJ1dGVzLmF1dG9SZXNpemVDb2x1bW5zICYmIHNlbGYuZGF0YS5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBzZWxmLnN0b3JlZFNldHRpbmdzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hdXRvc2l6ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB3aWR0aCBjYW5ub3QgYmUgZGV0ZXJtaW5lZCBjb3JyZWN0bHkgdW50aWwgYWZ0ZXIgaW5zZXJ0ZWQgaW50byB0aGUgZG9tP1xuICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZml0Q29sdW1uVG9WYWx1ZXMoJ2Nvcm5lckNlbGwnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGYucmVzaXplKCkpIHsgc2VsZi5kcmF3KHRydWUpOyB9XG4gICAgICAgICAgICAgICAgc2VsZi5jcmVhdGVSb3dPcmRlcnMoKTtcbiAgICAgICAgICAgICAgICBzZWxmLnRyeUxvYWRTdG9yZWRPcmRlcnMoKTtcbiAgICAgICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2RhdGFjaGFuZ2VkJywgW3NlbGYuZGF0YV0sIHNlbGYuaW50Zik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvaW50Zi5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3\n");

/***/ }),
/* 4 */
/*!****************************!*\
  !*** ./lib/contextMenu.js ***!
  \****************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jslint browser: true, unparam: true, todo: true*/\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n    'use strict';\n    return function (self) {\n        self.contextmenu = function (e) {\n            if (!self.hasFocus) {\n                return;\n            }\n            if (self.contextMenu) {\n                e.preventDefault();\n                return self.disposeContextMenu();\n            }\n            var oPreventDefault = e.preventDefault,\n                pos,\n                loc = {},\n                contextObject,\n                filterContainer,\n                filterLabel,\n                filterInput,\n                columnFilter,\n                menuItems;\n            pos = self.getLayerPos(e);\n            contextObject = self.getCellAt(pos.x, pos.y);\n            if (contextObject.grid !== undefined) {\n                return;\n            }\n            if (!contextObject.header) { e.preventDefault(); return; }\n            columnFilter = self.columnFilters[contextObject.header.name] || '';\n            filterContainer = document.createElement('div');\n            filterLabel = document.createElement('div');\n            filterLabel.className = 'canvas-datagrid-context-menu-label';\n            filterInput = document.createElement('input');\n            filterLabel.innerHTML = self.attributes.filterOptionText + ' ' + contextObject.header.name;\n            filterContainer.appendChild(filterLabel);\n            filterContainer.appendChild(filterInput);\n            self.contextMenu = document.createElement('div');\n            self.contextMenu.className = 'canvas-datagrid-context-menu';\n            self.contextMenu.style.cursor = 'pointer';\n            self.contextMenu.style.position = 'absolute';\n            self.contextMenu.style.zIndex = '3';\n            filterInput.value = columnFilter;\n            menuItems = [];\n            if (self.attributes.showFilter) {\n                menuItems.push({\n                    title: filterContainer\n                });\n                if (Object.keys(self.columnFilters).length) {\n                    Object.keys(self.columnFilters).forEach(function (cf) {\n                        menuItems.push({\n                            title: self.attributes.removeFilterOptionText.replace(/%s/g, cf),\n                            click: function removeFilterClick() {\n                                e.preventDefault();\n                                self.setFilter(cf, '');\n                                self.disposeContextMenu();\n                                self.controlInput.focus();\n                            }\n                        });\n                    });\n                }\n            }\n            if (self.attributes.saveAppearance && self.attributes.showClearSettingsOption\n                    && (Object.keys(self.sizes.rows).length > 0\n                        || Object.keys(self.sizes.columns).length > 0)) {\n                menuItems.push({\n                    title: self.attributes.clearSettingsOptionText,\n                    click: function (e) {\n                        e.preventDefault();\n                        self.sizes.rows = {};\n                        self.sizes.columns = {};\n                        self.createRowOrders();\n                        self.createColumnOrders();\n                        self.storedSettings = undefined;\n                        self.dispatchEvent('resizecolumn', [self.style.columnWidth], self.intf);\n                        self.dispatchEvent('resizerow', [self.style.cellHeight], self.intf);\n                        self.setStorageData();\n                        self.resize(true);\n                        self.disposeContextMenu();\n                        self.controlInput.focus();\n                    }\n                });\n            }\n            if (self.attributes.allowSorting && self.attributes.showOrderByOption) {\n                menuItems.push({\n                    title: self.attributes.showOrderByOptionTextAsc.replace('%s', contextObject.header.name),\n                    click: function (e) {\n                        e.preventDefault();\n                        self.order(contextObject.header.name, 'asc');\n                        self.disposeContextMenu();\n                        self.controlInput.focus();\n                    }\n                });\n                menuItems.push({\n                    title: self.attributes.showOrderByOptionTextDesc.replace('%s', contextObject.header.name),\n                    click: function (e) {\n                        e.preventDefault();\n                        self.order(contextObject.header.name, 'desc');\n                        self.disposeContextMenu();\n                        self.controlInput.focus();\n                    }\n                });\n            }\n            if (self.dispatchEvent('contextmenu', [e, contextObject, menuItems, self.contextMenu], self.intf)) { return; }\n            if (!menuItems.length) {\n                return;\n            }\n            menuItems.forEach(function (item) {\n                var row = document.createElement('div');\n                self.contextMenu.appendChild(row);\n                if (typeof item.title === 'string') {\n                    row.className = 'canvas-datagrid-context-menu-item';\n                    row.innerHTML = item.title;\n                } else {\n                    row.appendChild(item.title);\n                }\n                if (item.click) {\n                    row.addEventListener('click', function contextClickProxy(e) {\n                        item.click.apply(this, [e, contextObject, self.disposeContextMenu]);\n                        e.preventDefault();\n                        e.stopPropagation();\n                        self.controlInput.focus();\n                    });\n                }\n            });\n            filterInput.addEventListener('dblclick', self.stopPropagation);\n            filterInput.addEventListener('click', self.stopPropagation);\n            filterInput.addEventListener('mousedown', self.stopPropagation);\n            filterInput.addEventListener('keyup', function filterKeyUp() {\n                self.setFilter(contextObject.header.name, filterInput.value);\n                requestAnimationFrame(function filterRequestAnimationFrame() {\n                    filterInput.classList.remove(self.invalidSearchExpClass);\n                    if (self.invalidFilterRegEx) {\n                        filterInput.classList.add(self.invalidSearchExpClass);\n                    }\n                });\n            });\n            document.body.addEventListener('click', self.disposeContextMenu);\n            document.body.appendChild(self.contextMenu);\n            loc.x = e.clientX - self.style.contextMenuMarginLeft;\n            loc.y = e.clientY - self.style.contextMenuMarginTop;\n            if (loc.x + self.contextMenu.offsetWidth > document.documentElement.clientWidth) {\n                loc.x = document.documentElement.clientWidth - self.contextMenu.offsetWidth;\n            }\n            if (loc.y + self.contextMenu.offsetHeight > document.documentElement.clientHeight) {\n                loc.y = document.documentElement.clientHeight - self.contextMenu.offsetHeight;\n            }\n            self.contextMenu.style.left = loc.x + 'px';\n            self.contextMenu.style.top = loc.y + 'px';\n            oPreventDefault.apply(e);\n        };\n        /**\n         * Removes the context menu if it is present.\n         * @memberof canvasDataGrid#\n         * @method\n         */\n        self.disposeContextMenu = function (e) {\n            //TODO: there are most likely some bugs around removing the context menu.  Can't use grid on first click sometimes\n            function disp() {\n                self.contextMenu = undefined;\n                self.canvas.cursor = 'pointer';\n                document.body.removeEventListener('click', self.disposeContextMenu);\n                document.body.removeEventListener('mouseup', disp);\n                document.body.removeEventListener('mousedown', disp);\n            }\n            if (!e || (self.contextMenu\n                                && self.contextMenu.parentNode\n                                && !self.contextMenu.contains(e.target))) {\n                self.contextMenu.parentNode.removeChild(self.contextMenu);\n                document.body.addEventListener('mouseup', disp);\n                document.body.addEventListener('mousedown', disp);\n            }\n        };\n        return;\n    };\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi9jb250ZXh0TWVudS5qcz8zMmRiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qanNsaW50IGJyb3dzZXI6IHRydWUsIHVucGFyYW06IHRydWUsIHRvZG86IHRydWUqL1xuLypnbG9iYWxzIGRlZmluZTogdHJ1ZSwgTXV0YXRpb25PYnNlcnZlcjogZmFsc2UsIHJlcXVlc3RBbmltYXRpb25GcmFtZTogZmFsc2UsIHBlcmZvcm1hbmNlOiBmYWxzZSwgYnRvYTogZmFsc2UqL1xuZGVmaW5lKFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHJldHVybiBmdW5jdGlvbiAoc2VsZikge1xuICAgICAgICBzZWxmLmNvbnRleHRtZW51ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmICghc2VsZi5oYXNGb2N1cykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmNvbnRleHRNZW51KSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmRpc3Bvc2VDb250ZXh0TWVudSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG9QcmV2ZW50RGVmYXVsdCA9IGUucHJldmVudERlZmF1bHQsXG4gICAgICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgICAgIGxvYyA9IHt9LFxuICAgICAgICAgICAgICAgIGNvbnRleHRPYmplY3QsXG4gICAgICAgICAgICAgICAgZmlsdGVyQ29udGFpbmVyLFxuICAgICAgICAgICAgICAgIGZpbHRlckxhYmVsLFxuICAgICAgICAgICAgICAgIGZpbHRlcklucHV0LFxuICAgICAgICAgICAgICAgIGNvbHVtbkZpbHRlcixcbiAgICAgICAgICAgICAgICBtZW51SXRlbXM7XG4gICAgICAgICAgICBwb3MgPSBzZWxmLmdldExheWVyUG9zKGUpO1xuICAgICAgICAgICAgY29udGV4dE9iamVjdCA9IHNlbGYuZ2V0Q2VsbEF0KHBvcy54LCBwb3MueSk7XG4gICAgICAgICAgICBpZiAoY29udGV4dE9iamVjdC5ncmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNvbnRleHRPYmplY3QuaGVhZGVyKSB7IGUucHJldmVudERlZmF1bHQoKTsgcmV0dXJuOyB9XG4gICAgICAgICAgICBjb2x1bW5GaWx0ZXIgPSBzZWxmLmNvbHVtbkZpbHRlcnNbY29udGV4dE9iamVjdC5oZWFkZXIubmFtZV0gfHwgJyc7XG4gICAgICAgICAgICBmaWx0ZXJDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGZpbHRlckxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBmaWx0ZXJMYWJlbC5jbGFzc05hbWUgPSAnY2FudmFzLWRhdGFncmlkLWNvbnRleHQtbWVudS1sYWJlbCc7XG4gICAgICAgICAgICBmaWx0ZXJJbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgICAgICBmaWx0ZXJMYWJlbC5pbm5lckhUTUwgPSBzZWxmLmF0dHJpYnV0ZXMuZmlsdGVyT3B0aW9uVGV4dCArICcgJyArIGNvbnRleHRPYmplY3QuaGVhZGVyLm5hbWU7XG4gICAgICAgICAgICBmaWx0ZXJDb250YWluZXIuYXBwZW5kQ2hpbGQoZmlsdGVyTGFiZWwpO1xuICAgICAgICAgICAgZmlsdGVyQ29udGFpbmVyLmFwcGVuZENoaWxkKGZpbHRlcklucHV0KTtcbiAgICAgICAgICAgIHNlbGYuY29udGV4dE1lbnUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHNlbGYuY29udGV4dE1lbnUuY2xhc3NOYW1lID0gJ2NhbnZhcy1kYXRhZ3JpZC1jb250ZXh0LW1lbnUnO1xuICAgICAgICAgICAgc2VsZi5jb250ZXh0TWVudS5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgICAgICAgICBzZWxmLmNvbnRleHRNZW51LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICAgIHNlbGYuY29udGV4dE1lbnUuc3R5bGUuekluZGV4ID0gJzMnO1xuICAgICAgICAgICAgZmlsdGVySW5wdXQudmFsdWUgPSBjb2x1bW5GaWx0ZXI7XG4gICAgICAgICAgICBtZW51SXRlbXMgPSBbXTtcbiAgICAgICAgICAgIGlmIChzZWxmLmF0dHJpYnV0ZXMuc2hvd0ZpbHRlcikge1xuICAgICAgICAgICAgICAgIG1lbnVJdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGZpbHRlckNvbnRhaW5lclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhzZWxmLmNvbHVtbkZpbHRlcnMpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhzZWxmLmNvbHVtbkZpbHRlcnMpLmZvckVhY2goZnVuY3Rpb24gKGNmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZW51SXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHNlbGYuYXR0cmlidXRlcy5yZW1vdmVGaWx0ZXJPcHRpb25UZXh0LnJlcGxhY2UoLyVzL2csIGNmKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24gcmVtb3ZlRmlsdGVyQ2xpY2soKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXRGaWx0ZXIoY2YsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5kaXNwb3NlQ29udGV4dE1lbnUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb250cm9sSW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuYXR0cmlidXRlcy5zYXZlQXBwZWFyYW5jZSAmJiBzZWxmLmF0dHJpYnV0ZXMuc2hvd0NsZWFyU2V0dGluZ3NPcHRpb25cbiAgICAgICAgICAgICAgICAgICAgJiYgKE9iamVjdC5rZXlzKHNlbGYuc2l6ZXMucm93cykubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgT2JqZWN0LmtleXMoc2VsZi5zaXplcy5jb2x1bW5zKS5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgICAgIG1lbnVJdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHNlbGYuYXR0cmlidXRlcy5jbGVhclNldHRpbmdzT3B0aW9uVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNpemVzLnJvd3MgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2l6ZXMuY29sdW1ucyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jcmVhdGVSb3dPcmRlcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY3JlYXRlQ29sdW1uT3JkZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnN0b3JlZFNldHRpbmdzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdyZXNpemVjb2x1bW4nLCBbc2VsZi5zdHlsZS5jb2x1bW5XaWR0aF0sIHNlbGYuaW50Zik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ3Jlc2l6ZXJvdycsIFtzZWxmLnN0eWxlLmNlbGxIZWlnaHRdLCBzZWxmLmludGYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXRTdG9yYWdlRGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZXNpemUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmRpc3Bvc2VDb250ZXh0TWVudSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb250cm9sSW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuYXR0cmlidXRlcy5hbGxvd1NvcnRpbmcgJiYgc2VsZi5hdHRyaWJ1dGVzLnNob3dPcmRlckJ5T3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgbWVudUl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTogc2VsZi5hdHRyaWJ1dGVzLnNob3dPcmRlckJ5T3B0aW9uVGV4dEFzYy5yZXBsYWNlKCclcycsIGNvbnRleHRPYmplY3QuaGVhZGVyLm5hbWUpLFxuICAgICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYub3JkZXIoY29udGV4dE9iamVjdC5oZWFkZXIubmFtZSwgJ2FzYycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5kaXNwb3NlQ29udGV4dE1lbnUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29udHJvbElucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBtZW51SXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBzZWxmLmF0dHJpYnV0ZXMuc2hvd09yZGVyQnlPcHRpb25UZXh0RGVzYy5yZXBsYWNlKCclcycsIGNvbnRleHRPYmplY3QuaGVhZGVyLm5hbWUpLFxuICAgICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYub3JkZXIoY29udGV4dE9iamVjdC5oZWFkZXIubmFtZSwgJ2Rlc2MnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZGlzcG9zZUNvbnRleHRNZW51KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbnRyb2xJbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5kaXNwYXRjaEV2ZW50KCdjb250ZXh0bWVudScsIFtlLCBjb250ZXh0T2JqZWN0LCBtZW51SXRlbXMsIHNlbGYuY29udGV4dE1lbnVdLCBzZWxmLmludGYpKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgaWYgKCFtZW51SXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVudUl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgc2VsZi5jb250ZXh0TWVudS5hcHBlbmRDaGlsZChyb3cpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbS50aXRsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93LmNsYXNzTmFtZSA9ICdjYW52YXMtZGF0YWdyaWQtY29udGV4dC1tZW51LWl0ZW0nO1xuICAgICAgICAgICAgICAgICAgICByb3cuaW5uZXJIVE1MID0gaXRlbS50aXRsZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByb3cuYXBwZW5kQ2hpbGQoaXRlbS50aXRsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpdGVtLmNsaWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIGNvbnRleHRDbGlja1Byb3h5KGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uY2xpY2suYXBwbHkodGhpcywgW2UsIGNvbnRleHRPYmplY3QsIHNlbGYuZGlzcG9zZUNvbnRleHRNZW51XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb250cm9sSW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmaWx0ZXJJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIHNlbGYuc3RvcFByb3BhZ2F0aW9uKTtcbiAgICAgICAgICAgIGZpbHRlcklucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc2VsZi5zdG9wUHJvcGFnYXRpb24pO1xuICAgICAgICAgICAgZmlsdGVySW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgc2VsZi5zdG9wUHJvcGFnYXRpb24pO1xuICAgICAgICAgICAgZmlsdGVySW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBmdW5jdGlvbiBmaWx0ZXJLZXlVcCgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNldEZpbHRlcihjb250ZXh0T2JqZWN0LmhlYWRlci5uYW1lLCBmaWx0ZXJJbnB1dC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIGZpbHRlclJlcXVlc3RBbmltYXRpb25GcmFtZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVySW5wdXQuY2xhc3NMaXN0LnJlbW92ZShzZWxmLmludmFsaWRTZWFyY2hFeHBDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmludmFsaWRGaWx0ZXJSZWdFeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVySW5wdXQuY2xhc3NMaXN0LmFkZChzZWxmLmludmFsaWRTZWFyY2hFeHBDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHNlbGYuZGlzcG9zZUNvbnRleHRNZW51KTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2VsZi5jb250ZXh0TWVudSk7XG4gICAgICAgICAgICBsb2MueCA9IGUuY2xpZW50WCAtIHNlbGYuc3R5bGUuY29udGV4dE1lbnVNYXJnaW5MZWZ0O1xuICAgICAgICAgICAgbG9jLnkgPSBlLmNsaWVudFkgLSBzZWxmLnN0eWxlLmNvbnRleHRNZW51TWFyZ2luVG9wO1xuICAgICAgICAgICAgaWYgKGxvYy54ICsgc2VsZi5jb250ZXh0TWVudS5vZmZzZXRXaWR0aCA+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCkge1xuICAgICAgICAgICAgICAgIGxvYy54ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIC0gc2VsZi5jb250ZXh0TWVudS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsb2MueSArIHNlbGYuY29udGV4dE1lbnUub2Zmc2V0SGVpZ2h0ID4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCkge1xuICAgICAgICAgICAgICAgIGxvYy55ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCAtIHNlbGYuY29udGV4dE1lbnUub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5jb250ZXh0TWVudS5zdHlsZS5sZWZ0ID0gbG9jLnggKyAncHgnO1xuICAgICAgICAgICAgc2VsZi5jb250ZXh0TWVudS5zdHlsZS50b3AgPSBsb2MueSArICdweCc7XG4gICAgICAgICAgICBvUHJldmVudERlZmF1bHQuYXBwbHkoZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIHRoZSBjb250ZXh0IG1lbnUgaWYgaXQgaXMgcHJlc2VudC5cbiAgICAgICAgICogQG1lbWJlcm9mIGNhbnZhc0RhdGFHcmlkI1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmRpc3Bvc2VDb250ZXh0TWVudSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAvL1RPRE86IHRoZXJlIGFyZSBtb3N0IGxpa2VseSBzb21lIGJ1Z3MgYXJvdW5kIHJlbW92aW5nIHRoZSBjb250ZXh0IG1lbnUuICBDYW4ndCB1c2UgZ3JpZCBvbiBmaXJzdCBjbGljayBzb21ldGltZXNcbiAgICAgICAgICAgIGZ1bmN0aW9uIGRpc3AoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb250ZXh0TWVudSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBzZWxmLmNhbnZhcy5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHNlbGYuZGlzcG9zZUNvbnRleHRNZW51KTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBkaXNwKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGRpc3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFlIHx8IChzZWxmLmNvbnRleHRNZW51XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIHNlbGYuY29udGV4dE1lbnUucGFyZW50Tm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAhc2VsZi5jb250ZXh0TWVudS5jb250YWlucyhlLnRhcmdldCkpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb250ZXh0TWVudS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNlbGYuY29udGV4dE1lbnUpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGRpc3ApO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZGlzcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jb250ZXh0TWVudS5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n");

/***/ }),
/* 5 */
/*!*************************!*\
  !*** ./lib/defaults.js ***!
  \*************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jslint browser: true, unparam: true, todo: true*/\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n    'use strict';\n    return function (self) {\n        self.defaults = {\n            attributes: [\n                ['name', ''],\n                ['tree', false],\n                ['showNewRow', false],\n                ['treeHorizontalScroll', false],\n                ['saveAppearance', true],\n                ['selectionFollowsActiveCell', false],\n                ['multiLine', false],\n                ['editable', true],\n                ['allowColumnReordering', true],\n                ['allowRowReordering', false],\n                ['allowSorting', true],\n                ['showFilter', true],\n                ['globalRowResize', false],\n                ['pageUpDownOverlap', 1],\n                ['persistantSelectionMode', false],\n                ['rowSelectionMode', false],\n                ['autoResizeColumns', false],\n                ['allowRowHeaderResize', true],\n                ['allowColumnResize', true],\n                ['allowRowResize', true],\n                ['allowRowResizeFromCell', false],\n                ['allowColumnResizeFromCell', false],\n                ['showPerformance', false],\n                ['debug', false],\n                ['borderResizeZone', 10],\n                ['showHeaders', true],\n                ['showRowNumbers', true],\n                ['showRowHeaders', true],\n                ['scrollRepeatRate', 75],\n                ['selectionScrollZone', 20],\n                ['resizeScrollZone', 20],\n                ['selectionScrollIncrement', 20],\n                ['reorderDeadZone', 3],\n                ['showClearSettingsOption', true],\n                ['showOrderByOption', true],\n                ['clearSettingsOptionText', 'Clear saved settings'],\n                ['showOrderByOptionTextAsc', 'Order by %s ascending'],\n                ['showOrderByOptionTextDesc', 'Order by %s descending'],\n                ['removeFilterOptionText', 'Remove filter on %s'],\n                ['filterOptionText', 'Filter']\n            ],\n            styles: [\n                ['scrollBarBackgroundColor', 'rgba(240, 240, 240, 1)'],\n                ['scrollBarBoxColor', 'rgba(192, 192, 192, 1)'],\n                ['scrollBarActiveColor', 'rgba(125, 125, 125, 1)'],\n                ['scrollBarBoxWidth', 8],\n                ['scrollBarBoxMargin', 2],\n                ['scrollBarBoxBorderRadius', 3],\n                ['scrollBarBorderColor', 'rgba(202, 202, 202, 1)'],\n                ['scrollBarBorderWidth', 0.5],\n                ['scrollBarWidth', 11],\n                ['scrollBarBoxMinSize', 15],\n                ['scrollBarCornerBorderColor', 'rgba(202, 202, 202, 1)'],\n                ['scrollBarCornerBackground', 'rgba(240, 240, 240, 1)'],\n                ['treeArrowClickRadius', 5],\n                ['treeGridHeight', 250],\n                ['treeArrowHeight', 8],\n                ['treeArrowWidth', 13],\n                ['treeArrowColor', 'rgba(155, 155, 155, 1)'],\n                ['treeArrowBorderColor', 'rgba(195, 199, 202, 1)'],\n                ['treeArrowBorderWidth', 1],\n                ['treeArrowMarginRight', 5],\n                ['treeArrowMarginLeft', 0],\n                ['treeArrowMarginTop', 6],\n                ['filterTextPrefix', '(filtered) '],\n                ['editCellFontSize', '16px'],\n                ['editCellFontFamily', 'sans-serif'],\n                ['editCellPaddingLeft', 4],\n                ['editCellBoxShadow', '0 2px 5px rgba(0,0,0,0.4)'],\n                ['editCellBorder', 'solid 1px rgba(110, 168, 255, 1)'],\n                ['styleSheet', ''],\n                ['contextMenuItemMargin', '2px'],\n                ['contextMenuItemBorderRadius', '3px'],\n                ['contextMenuLabelMargin', '0 3px 0 0'],\n                ['contextMenuLabelDisplay', 'inline-block'],\n                ['contextMenuLabelMinWidth', '75px'],\n                ['contextMenuLabelMaxWidth', '700px'],\n                ['contextMenuHoverBackground', 'rgba(182, 205, 250, 1)'],\n                ['contextMenuColor', 'rgba(43, 48, 43, 1)'],\n                ['contextMenuHoverColor', 'rgba(43, 48, 153, 1)'],\n                ['contextMenuFontSize', '16px'],\n                ['contextMenuFontFamily', 'sans-serif'],\n                ['contextMenuBackground', 'rgba(240, 240, 240, 1)'],\n                ['contextMenuBorder', 'solid 1px rgba(158, 163, 169, 1)'],\n                ['contextMenuPadding', '2px'],\n                ['contextMenuBorderRadius', '3px'],\n                ['contextMenuOpacity', '0.98'],\n                ['contextMenuFilterInvalidExpresion', 'rgba(237, 155, 156, 1)'],\n                ['contextMenuMarginTop', 0],\n                ['contextMenuMarginLeft', 5],\n                ['autosizePadding', 5],\n                ['autosizeHeaderCellPadding', 8],\n                ['minHeight', 24],\n                ['minRowHeight', 24],\n                ['minColumnWidth', 45],\n                ['columnWidth', 250],\n                ['backgroundColor', 'rgba(240, 240, 240, 1)'],\n                ['headerOrderByArrowHeight', 8],\n                ['headerOrderByArrowWidth', 13],\n                ['headerOrderByArrowColor', 'rgba(155, 155, 155, 1)'],\n                ['headerOrderByArrowBorderColor', 'rgba(195, 199, 202, 1)'],\n                ['headerOrderByArrowBorderWidth', 1],\n                ['headerOrderByArrowMarginRight', 5],\n                ['headerOrderByArrowMarginLeft', 0],\n                ['headerOrderByArrowMarginTop', 6],\n                ['cellHeightWithChildGrid', 150],\n                ['cellWidthWithChildGrid', 250],\n                ['cellHeight', 24],\n                ['cellFont', '16px sans-serif'],\n                ['cellPaddingTop', 5],\n                ['cellAutoResizePadding', 13],\n                ['cellPaddingLeft', 5],\n                ['cellPaddingRight', 7],\n                ['cellAlignment', 'left'],\n                ['cellColor', 'rgba(0, 0, 0, 1)'],\n                ['cellBackgroundColor', 'rgba(255, 255, 255, 1)'],\n                ['cellHoverColor', 'rgba(0, 0, 0, 1)'],\n                ['cellHoverBackgroundColor', 'rgba(255, 255, 255, 1)'],\n                ['cellSelectedColor', 'rgba(0, 0, 0, 1)'],\n                ['cellSelectedBackgroundColor', 'rgba(236, 243, 255, 1)'],\n                ['cellBorderWidth', 0.25],\n                ['cellBorderColor', 'rgba(195, 199, 202, 1)'],\n                ['activeCellFont', '16px sans-serif'],\n                ['activeCellPaddingTop', 5],\n                ['activeCellPaddingLeft', 5],\n                ['activeCellPaddingRight', 7],\n                ['activeCellAlignment', 'left'],\n                ['activeCellColor', 'rgba(0, 0, 0, 1)'],\n                ['activeCellBackgroundColor', 'rgba(255, 255, 255, 1)'],\n                ['activeCellHoverColor', 'rgba(0, 0, 0, 1)'],\n                ['activeCellHoverBackgroundColor', 'rgba(255, 255, 255, 1)'],\n                ['activeCellSelectedColor', 'rgba(0, 0, 0, 1)'],\n                ['activeCellSelectedBackgroundColor', 'rgba(236, 243, 255, 1)'],\n                ['activeCellBorderWidth', 0.25],\n                ['activeCellBorderColor', 'rgba(110, 168, 255, 1)'],\n                ['headerCellPaddingTop', 5],\n                ['headerCellPaddingLeft', 5],\n                ['headerCellPaddingRight', 7],\n                ['headerCellHeight', 25],\n                ['headerCellBorderWidth', 0.25],\n                ['headerCellBorderColor', 'rgba(152, 152, 152, 1)'],\n                ['headerCellFont', '16px sans-serif'],\n                ['headerCellColor', 'rgba(50, 50, 50, 1)'],\n                ['headerCellBackgroundColor', 'rgba(240, 240, 240, 1)'],\n                ['headerCellHoverColor', 'rgba(0, 0, 0, 1)'],\n                ['headerCellHoverBackgroundColor', 'rgba(235, 235, 235, 1)'],\n                ['headerCellActiveColor', 'rgba(0, 0, 0, 1)'],\n                ['headerCellActiveBackgroundColor', 'rgba(225, 225, 225, 1)'],\n                ['headerRowWidth', 57],\n                ['rowHeaderCellPaddingTop', 5],\n                ['rowHeaderCellPaddingLeft', 5],\n                ['rowHeaderCellPaddingRight', 5],\n                ['rowHeaderCellHeight', 25],\n                ['rowHeaderCellBorderWidth', 0.25],\n                ['rowHeaderCellBorderColor', 'rgba(152, 152, 152, 1)'],\n                ['rowHeaderCellFont', '16px sans-serif'],\n                ['rowHeaderCellColor', 'rgba(50, 50, 50, 1)'],\n                ['rowHeaderCellBackgroundColor', 'rgba(240, 240, 240, 1)'],\n                ['rowHeaderCellHoverColor', 'rgba(0, 0, 0, 1)'],\n                ['rowHeaderCellHoverBackgroundColor', 'rgba(235, 235, 235, 1)'],\n                ['rowHeaderCellSelectedColor', 'rgba(50, 50, 50, 1)'],\n                ['rowHeaderCellSelectedBackgroundColor', 'rgba(217, 217, 217, 1)'],\n                ['rowHeaderCellActiveColor', 'rgba(0, 0, 0, 1)'],\n                ['rowHeaderCellActiveBackgroundColor', 'rgba(225, 225, 225, 1)'],\n                ['activeCellOverlayBorderColor', 'rgba(66, 133, 244, 1)'],\n                ['activeCellOverlayBorderWidth', 2],\n                ['selectionOverlayBorderColor', 'rgba(66, 133, 244, 1)'],\n                ['selectionOverlayBorderWidth', 1.25],\n                ['reorderMarkerIndexBorderColor', 'rgba(66, 133, 244, 1)'],\n                ['reorderMarkerIndexBorderWidth', 2.75],\n                ['reorderMarkerBackgroundColor', 'rgba(0, 0, 0, 0.1)'],\n                ['reorderMarkerBorderColor', 'rgba(0, 0, 0, 0.2)'],\n                ['reorderMarkerBorderWidth', 1.25],\n                ['gridBorderColor', 'rgba(202, 202, 202, 1)'],\n                ['gridBorderWidth', 1]\n            ]\n        };\n    };\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi9kZWZhdWx0cy5qcz8yNjk1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qanNsaW50IGJyb3dzZXI6IHRydWUsIHVucGFyYW06IHRydWUsIHRvZG86IHRydWUqL1xuLypnbG9iYWxzIGRlZmluZTogdHJ1ZSwgTXV0YXRpb25PYnNlcnZlcjogZmFsc2UsIHJlcXVlc3RBbmltYXRpb25GcmFtZTogZmFsc2UsIHBlcmZvcm1hbmNlOiBmYWxzZSwgYnRvYTogZmFsc2UqL1xuZGVmaW5lKFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHJldHVybiBmdW5jdGlvbiAoc2VsZikge1xuICAgICAgICBzZWxmLmRlZmF1bHRzID0ge1xuICAgICAgICAgICAgYXR0cmlidXRlczogW1xuICAgICAgICAgICAgICAgIFsnbmFtZScsICcnXSxcbiAgICAgICAgICAgICAgICBbJ3RyZWUnLCBmYWxzZV0sXG4gICAgICAgICAgICAgICAgWydzaG93TmV3Um93JywgZmFsc2VdLFxuICAgICAgICAgICAgICAgIFsndHJlZUhvcml6b250YWxTY3JvbGwnLCBmYWxzZV0sXG4gICAgICAgICAgICAgICAgWydzYXZlQXBwZWFyYW5jZScsIHRydWVdLFxuICAgICAgICAgICAgICAgIFsnc2VsZWN0aW9uRm9sbG93c0FjdGl2ZUNlbGwnLCBmYWxzZV0sXG4gICAgICAgICAgICAgICAgWydtdWx0aUxpbmUnLCBmYWxzZV0sXG4gICAgICAgICAgICAgICAgWydlZGl0YWJsZScsIHRydWVdLFxuICAgICAgICAgICAgICAgIFsnYWxsb3dDb2x1bW5SZW9yZGVyaW5nJywgdHJ1ZV0sXG4gICAgICAgICAgICAgICAgWydhbGxvd1Jvd1Jlb3JkZXJpbmcnLCBmYWxzZV0sXG4gICAgICAgICAgICAgICAgWydhbGxvd1NvcnRpbmcnLCB0cnVlXSxcbiAgICAgICAgICAgICAgICBbJ3Nob3dGaWx0ZXInLCB0cnVlXSxcbiAgICAgICAgICAgICAgICBbJ2dsb2JhbFJvd1Jlc2l6ZScsIGZhbHNlXSxcbiAgICAgICAgICAgICAgICBbJ3BhZ2VVcERvd25PdmVybGFwJywgMV0sXG4gICAgICAgICAgICAgICAgWydwZXJzaXN0YW50U2VsZWN0aW9uTW9kZScsIGZhbHNlXSxcbiAgICAgICAgICAgICAgICBbJ3Jvd1NlbGVjdGlvbk1vZGUnLCBmYWxzZV0sXG4gICAgICAgICAgICAgICAgWydhdXRvUmVzaXplQ29sdW1ucycsIGZhbHNlXSxcbiAgICAgICAgICAgICAgICBbJ2FsbG93Um93SGVhZGVyUmVzaXplJywgdHJ1ZV0sXG4gICAgICAgICAgICAgICAgWydhbGxvd0NvbHVtblJlc2l6ZScsIHRydWVdLFxuICAgICAgICAgICAgICAgIFsnYWxsb3dSb3dSZXNpemUnLCB0cnVlXSxcbiAgICAgICAgICAgICAgICBbJ2FsbG93Um93UmVzaXplRnJvbUNlbGwnLCBmYWxzZV0sXG4gICAgICAgICAgICAgICAgWydhbGxvd0NvbHVtblJlc2l6ZUZyb21DZWxsJywgZmFsc2VdLFxuICAgICAgICAgICAgICAgIFsnc2hvd1BlcmZvcm1hbmNlJywgZmFsc2VdLFxuICAgICAgICAgICAgICAgIFsnZGVidWcnLCBmYWxzZV0sXG4gICAgICAgICAgICAgICAgWydib3JkZXJSZXNpemVab25lJywgMTBdLFxuICAgICAgICAgICAgICAgIFsnc2hvd0hlYWRlcnMnLCB0cnVlXSxcbiAgICAgICAgICAgICAgICBbJ3Nob3dSb3dOdW1iZXJzJywgdHJ1ZV0sXG4gICAgICAgICAgICAgICAgWydzaG93Um93SGVhZGVycycsIHRydWVdLFxuICAgICAgICAgICAgICAgIFsnc2Nyb2xsUmVwZWF0UmF0ZScsIDc1XSxcbiAgICAgICAgICAgICAgICBbJ3NlbGVjdGlvblNjcm9sbFpvbmUnLCAyMF0sXG4gICAgICAgICAgICAgICAgWydyZXNpemVTY3JvbGxab25lJywgMjBdLFxuICAgICAgICAgICAgICAgIFsnc2VsZWN0aW9uU2Nyb2xsSW5jcmVtZW50JywgMjBdLFxuICAgICAgICAgICAgICAgIFsncmVvcmRlckRlYWRab25lJywgM10sXG4gICAgICAgICAgICAgICAgWydzaG93Q2xlYXJTZXR0aW5nc09wdGlvbicsIHRydWVdLFxuICAgICAgICAgICAgICAgIFsnc2hvd09yZGVyQnlPcHRpb24nLCB0cnVlXSxcbiAgICAgICAgICAgICAgICBbJ2NsZWFyU2V0dGluZ3NPcHRpb25UZXh0JywgJ0NsZWFyIHNhdmVkIHNldHRpbmdzJ10sXG4gICAgICAgICAgICAgICAgWydzaG93T3JkZXJCeU9wdGlvblRleHRBc2MnLCAnT3JkZXIgYnkgJXMgYXNjZW5kaW5nJ10sXG4gICAgICAgICAgICAgICAgWydzaG93T3JkZXJCeU9wdGlvblRleHREZXNjJywgJ09yZGVyIGJ5ICVzIGRlc2NlbmRpbmcnXSxcbiAgICAgICAgICAgICAgICBbJ3JlbW92ZUZpbHRlck9wdGlvblRleHQnLCAnUmVtb3ZlIGZpbHRlciBvbiAlcyddLFxuICAgICAgICAgICAgICAgIFsnZmlsdGVyT3B0aW9uVGV4dCcsICdGaWx0ZXInXVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHN0eWxlczogW1xuICAgICAgICAgICAgICAgIFsnc2Nyb2xsQmFyQmFja2dyb3VuZENvbG9yJywgJ3JnYmEoMjQwLCAyNDAsIDI0MCwgMSknXSxcbiAgICAgICAgICAgICAgICBbJ3Njcm9sbEJhckJveENvbG9yJywgJ3JnYmEoMTkyLCAxOTIsIDE5MiwgMSknXSxcbiAgICAgICAgICAgICAgICBbJ3Njcm9sbEJhckFjdGl2ZUNvbG9yJywgJ3JnYmEoMTI1LCAxMjUsIDEyNSwgMSknXSxcbiAgICAgICAgICAgICAgICBbJ3Njcm9sbEJhckJveFdpZHRoJywgOF0sXG4gICAgICAgICAgICAgICAgWydzY3JvbGxCYXJCb3hNYXJnaW4nLCAyXSxcbiAgICAgICAgICAgICAgICBbJ3Njcm9sbEJhckJveEJvcmRlclJhZGl1cycsIDNdLFxuICAgICAgICAgICAgICAgIFsnc2Nyb2xsQmFyQm9yZGVyQ29sb3InLCAncmdiYSgyMDIsIDIwMiwgMjAyLCAxKSddLFxuICAgICAgICAgICAgICAgIFsnc2Nyb2xsQmFyQm9yZGVyV2lkdGgnLCAwLjVdLFxuICAgICAgICAgICAgICAgIFsnc2Nyb2xsQmFyV2lkdGgnLCAxMV0sXG4gICAgICAgICAgICAgICAgWydzY3JvbGxCYXJCb3hNaW5TaXplJywgMTVdLFxuICAgICAgICAgICAgICAgIFsnc2Nyb2xsQmFyQ29ybmVyQm9yZGVyQ29sb3InLCAncmdiYSgyMDIsIDIwMiwgMjAyLCAxKSddLFxuICAgICAgICAgICAgICAgIFsnc2Nyb2xsQmFyQ29ybmVyQmFja2dyb3VuZCcsICdyZ2JhKDI0MCwgMjQwLCAyNDAsIDEpJ10sXG4gICAgICAgICAgICAgICAgWyd0cmVlQXJyb3dDbGlja1JhZGl1cycsIDVdLFxuICAgICAgICAgICAgICAgIFsndHJlZUdyaWRIZWlnaHQnLCAyNTBdLFxuICAgICAgICAgICAgICAgIFsndHJlZUFycm93SGVpZ2h0JywgOF0sXG4gICAgICAgICAgICAgICAgWyd0cmVlQXJyb3dXaWR0aCcsIDEzXSxcbiAgICAgICAgICAgICAgICBbJ3RyZWVBcnJvd0NvbG9yJywgJ3JnYmEoMTU1LCAxNTUsIDE1NSwgMSknXSxcbiAgICAgICAgICAgICAgICBbJ3RyZWVBcnJvd0JvcmRlckNvbG9yJywgJ3JnYmEoMTk1LCAxOTksIDIwMiwgMSknXSxcbiAgICAgICAgICAgICAgICBbJ3RyZWVBcnJvd0JvcmRlcldpZHRoJywgMV0sXG4gICAgICAgICAgICAgICAgWyd0cmVlQXJyb3dNYXJnaW5SaWdodCcsIDVdLFxuICAgICAgICAgICAgICAgIFsndHJlZUFycm93TWFyZ2luTGVmdCcsIDBdLFxuICAgICAgICAgICAgICAgIFsndHJlZUFycm93TWFyZ2luVG9wJywgNl0sXG4gICAgICAgICAgICAgICAgWydmaWx0ZXJUZXh0UHJlZml4JywgJyhmaWx0ZXJlZCkgJ10sXG4gICAgICAgICAgICAgICAgWydlZGl0Q2VsbEZvbnRTaXplJywgJzE2cHgnXSxcbiAgICAgICAgICAgICAgICBbJ2VkaXRDZWxsRm9udEZhbWlseScsICdzYW5zLXNlcmlmJ10sXG4gICAgICAgICAgICAgICAgWydlZGl0Q2VsbFBhZGRpbmdMZWZ0JywgNF0sXG4gICAgICAgICAgICAgICAgWydlZGl0Q2VsbEJveFNoYWRvdycsICcwIDJweCA1cHggcmdiYSgwLDAsMCwwLjQpJ10sXG4gICAgICAgICAgICAgICAgWydlZGl0Q2VsbEJvcmRlcicsICdzb2xpZCAxcHggcmdiYSgxMTAsIDE2OCwgMjU1LCAxKSddLFxuICAgICAgICAgICAgICAgIFsnc3R5bGVTaGVldCcsICcnXSxcbiAgICAgICAgICAgICAgICBbJ2NvbnRleHRNZW51SXRlbU1hcmdpbicsICcycHgnXSxcbiAgICAgICAgICAgICAgICBbJ2NvbnRleHRNZW51SXRlbUJvcmRlclJhZGl1cycsICczcHgnXSxcbiAgICAgICAgICAgICAgICBbJ2NvbnRleHRNZW51TGFiZWxNYXJnaW4nLCAnMCAzcHggMCAwJ10sXG4gICAgICAgICAgICAgICAgWydjb250ZXh0TWVudUxhYmVsRGlzcGxheScsICdpbmxpbmUtYmxvY2snXSxcbiAgICAgICAgICAgICAgICBbJ2NvbnRleHRNZW51TGFiZWxNaW5XaWR0aCcsICc3NXB4J10sXG4gICAgICAgICAgICAgICAgWydjb250ZXh0TWVudUxhYmVsTWF4V2lkdGgnLCAnNzAwcHgnXSxcbiAgICAgICAgICAgICAgICBbJ2NvbnRleHRNZW51SG92ZXJCYWNrZ3JvdW5kJywgJ3JnYmEoMTgyLCAyMDUsIDI1MCwgMSknXSxcbiAgICAgICAgICAgICAgICBbJ2NvbnRleHRNZW51Q29sb3InLCAncmdiYSg0MywgNDgsIDQzLCAxKSddLFxuICAgICAgICAgICAgICAgIFsnY29udGV4dE1lbnVIb3ZlckNvbG9yJywgJ3JnYmEoNDMsIDQ4LCAxNTMsIDEpJ10sXG4gICAgICAgICAgICAgICAgWydjb250ZXh0TWVudUZvbnRTaXplJywgJzE2cHgnXSxcbiAgICAgICAgICAgICAgICBbJ2NvbnRleHRNZW51Rm9udEZhbWlseScsICdzYW5zLXNlcmlmJ10sXG4gICAgICAgICAgICAgICAgWydjb250ZXh0TWVudUJhY2tncm91bmQnLCAncmdiYSgyNDAsIDI0MCwgMjQwLCAxKSddLFxuICAgICAgICAgICAgICAgIFsnY29udGV4dE1lbnVCb3JkZXInLCAnc29saWQgMXB4IHJnYmEoMTU4LCAxNjMsIDE2OSwgMSknXSxcbiAgICAgICAgICAgICAgICBbJ2NvbnRleHRNZW51UGFkZGluZycsICcycHgnXSxcbiAgICAgICAgICAgICAgICBbJ2NvbnRleHRNZW51Qm9yZGVyUmFkaXVzJywgJzNweCddLFxuICAgICAgICAgICAgICAgIFsnY29udGV4dE1lbnVPcGFjaXR5JywgJzAuOTgnXSxcbiAgICAgICAgICAgICAgICBbJ2NvbnRleHRNZW51RmlsdGVySW52YWxpZEV4cHJlc2lvbicsICdyZ2JhKDIzNywgMTU1LCAxNTYsIDEpJ10sXG4gICAgICAgICAgICAgICAgWydjb250ZXh0TWVudU1hcmdpblRvcCcsIDBdLFxuICAgICAgICAgICAgICAgIFsnY29udGV4dE1lbnVNYXJnaW5MZWZ0JywgNV0sXG4gICAgICAgICAgICAgICAgWydhdXRvc2l6ZVBhZGRpbmcnLCA1XSxcbiAgICAgICAgICAgICAgICBbJ2F1dG9zaXplSGVhZGVyQ2VsbFBhZGRpbmcnLCA4XSxcbiAgICAgICAgICAgICAgICBbJ21pbkhlaWdodCcsIDI0XSxcbiAgICAgICAgICAgICAgICBbJ21pblJvd0hlaWdodCcsIDI0XSxcbiAgICAgICAgICAgICAgICBbJ21pbkNvbHVtbldpZHRoJywgNDVdLFxuICAgICAgICAgICAgICAgIFsnY29sdW1uV2lkdGgnLCAyNTBdLFxuICAgICAgICAgICAgICAgIFsnYmFja2dyb3VuZENvbG9yJywgJ3JnYmEoMjQwLCAyNDAsIDI0MCwgMSknXSxcbiAgICAgICAgICAgICAgICBbJ2hlYWRlck9yZGVyQnlBcnJvd0hlaWdodCcsIDhdLFxuICAgICAgICAgICAgICAgIFsnaGVhZGVyT3JkZXJCeUFycm93V2lkdGgnLCAxM10sXG4gICAgICAgICAgICAgICAgWydoZWFkZXJPcmRlckJ5QXJyb3dDb2xvcicsICdyZ2JhKDE1NSwgMTU1LCAxNTUsIDEpJ10sXG4gICAgICAgICAgICAgICAgWydoZWFkZXJPcmRlckJ5QXJyb3dCb3JkZXJDb2xvcicsICdyZ2JhKDE5NSwgMTk5LCAyMDIsIDEpJ10sXG4gICAgICAgICAgICAgICAgWydoZWFkZXJPcmRlckJ5QXJyb3dCb3JkZXJXaWR0aCcsIDFdLFxuICAgICAgICAgICAgICAgIFsnaGVhZGVyT3JkZXJCeUFycm93TWFyZ2luUmlnaHQnLCA1XSxcbiAgICAgICAgICAgICAgICBbJ2hlYWRlck9yZGVyQnlBcnJvd01hcmdpbkxlZnQnLCAwXSxcbiAgICAgICAgICAgICAgICBbJ2hlYWRlck9yZGVyQnlBcnJvd01hcmdpblRvcCcsIDZdLFxuICAgICAgICAgICAgICAgIFsnY2VsbEhlaWdodFdpdGhDaGlsZEdyaWQnLCAxNTBdLFxuICAgICAgICAgICAgICAgIFsnY2VsbFdpZHRoV2l0aENoaWxkR3JpZCcsIDI1MF0sXG4gICAgICAgICAgICAgICAgWydjZWxsSGVpZ2h0JywgMjRdLFxuICAgICAgICAgICAgICAgIFsnY2VsbEZvbnQnLCAnMTZweCBzYW5zLXNlcmlmJ10sXG4gICAgICAgICAgICAgICAgWydjZWxsUGFkZGluZ1RvcCcsIDVdLFxuICAgICAgICAgICAgICAgIFsnY2VsbEF1dG9SZXNpemVQYWRkaW5nJywgMTNdLFxuICAgICAgICAgICAgICAgIFsnY2VsbFBhZGRpbmdMZWZ0JywgNV0sXG4gICAgICAgICAgICAgICAgWydjZWxsUGFkZGluZ1JpZ2h0JywgN10sXG4gICAgICAgICAgICAgICAgWydjZWxsQWxpZ25tZW50JywgJ2xlZnQnXSxcbiAgICAgICAgICAgICAgICBbJ2NlbGxDb2xvcicsICdyZ2JhKDAsIDAsIDAsIDEpJ10sXG4gICAgICAgICAgICAgICAgWydjZWxsQmFja2dyb3VuZENvbG9yJywgJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMSknXSxcbiAgICAgICAgICAgICAgICBbJ2NlbGxIb3ZlckNvbG9yJywgJ3JnYmEoMCwgMCwgMCwgMSknXSxcbiAgICAgICAgICAgICAgICBbJ2NlbGxIb3ZlckJhY2tncm91bmRDb2xvcicsICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDEpJ10sXG4gICAgICAgICAgICAgICAgWydjZWxsU2VsZWN0ZWRDb2xvcicsICdyZ2JhKDAsIDAsIDAsIDEpJ10sXG4gICAgICAgICAgICAgICAgWydjZWxsU2VsZWN0ZWRCYWNrZ3JvdW5kQ29sb3InLCAncmdiYSgyMzYsIDI0MywgMjU1LCAxKSddLFxuICAgICAgICAgICAgICAgIFsnY2VsbEJvcmRlcldpZHRoJywgMC4yNV0sXG4gICAgICAgICAgICAgICAgWydjZWxsQm9yZGVyQ29sb3InLCAncmdiYSgxOTUsIDE5OSwgMjAyLCAxKSddLFxuICAgICAgICAgICAgICAgIFsnYWN0aXZlQ2VsbEZvbnQnLCAnMTZweCBzYW5zLXNlcmlmJ10sXG4gICAgICAgICAgICAgICAgWydhY3RpdmVDZWxsUGFkZGluZ1RvcCcsIDVdLFxuICAgICAgICAgICAgICAgIFsnYWN0aXZlQ2VsbFBhZGRpbmdMZWZ0JywgNV0sXG4gICAgICAgICAgICAgICAgWydhY3RpdmVDZWxsUGFkZGluZ1JpZ2h0JywgN10sXG4gICAgICAgICAgICAgICAgWydhY3RpdmVDZWxsQWxpZ25tZW50JywgJ2xlZnQnXSxcbiAgICAgICAgICAgICAgICBbJ2FjdGl2ZUNlbGxDb2xvcicsICdyZ2JhKDAsIDAsIDAsIDEpJ10sXG4gICAgICAgICAgICAgICAgWydhY3RpdmVDZWxsQmFja2dyb3VuZENvbG9yJywgJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMSknXSxcbiAgICAgICAgICAgICAgICBbJ2FjdGl2ZUNlbGxIb3ZlckNvbG9yJywgJ3JnYmEoMCwgMCwgMCwgMSknXSxcbiAgICAgICAgICAgICAgICBbJ2FjdGl2ZUNlbGxIb3ZlckJhY2tncm91bmRDb2xvcicsICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDEpJ10sXG4gICAgICAgICAgICAgICAgWydhY3RpdmVDZWxsU2VsZWN0ZWRDb2xvcicsICdyZ2JhKDAsIDAsIDAsIDEpJ10sXG4gICAgICAgICAgICAgICAgWydhY3RpdmVDZWxsU2VsZWN0ZWRCYWNrZ3JvdW5kQ29sb3InLCAncmdiYSgyMzYsIDI0MywgMjU1LCAxKSddLFxuICAgICAgICAgICAgICAgIFsnYWN0aXZlQ2VsbEJvcmRlcldpZHRoJywgMC4yNV0sXG4gICAgICAgICAgICAgICAgWydhY3RpdmVDZWxsQm9yZGVyQ29sb3InLCAncmdiYSgxMTAsIDE2OCwgMjU1LCAxKSddLFxuICAgICAgICAgICAgICAgIFsnaGVhZGVyQ2VsbFBhZGRpbmdUb3AnLCA1XSxcbiAgICAgICAgICAgICAgICBbJ2hlYWRlckNlbGxQYWRkaW5nTGVmdCcsIDVdLFxuICAgICAgICAgICAgICAgIFsnaGVhZGVyQ2VsbFBhZGRpbmdSaWdodCcsIDddLFxuICAgICAgICAgICAgICAgIFsnaGVhZGVyQ2VsbEhlaWdodCcsIDI1XSxcbiAgICAgICAgICAgICAgICBbJ2hlYWRlckNlbGxCb3JkZXJXaWR0aCcsIDAuMjVdLFxuICAgICAgICAgICAgICAgIFsnaGVhZGVyQ2VsbEJvcmRlckNvbG9yJywgJ3JnYmEoMTUyLCAxNTIsIDE1MiwgMSknXSxcbiAgICAgICAgICAgICAgICBbJ2hlYWRlckNlbGxGb250JywgJzE2cHggc2Fucy1zZXJpZiddLFxuICAgICAgICAgICAgICAgIFsnaGVhZGVyQ2VsbENvbG9yJywgJ3JnYmEoNTAsIDUwLCA1MCwgMSknXSxcbiAgICAgICAgICAgICAgICBbJ2hlYWRlckNlbGxCYWNrZ3JvdW5kQ29sb3InLCAncmdiYSgyNDAsIDI0MCwgMjQwLCAxKSddLFxuICAgICAgICAgICAgICAgIFsnaGVhZGVyQ2VsbEhvdmVyQ29sb3InLCAncmdiYSgwLCAwLCAwLCAxKSddLFxuICAgICAgICAgICAgICAgIFsnaGVhZGVyQ2VsbEhvdmVyQmFja2dyb3VuZENvbG9yJywgJ3JnYmEoMjM1LCAyMzUsIDIzNSwgMSknXSxcbiAgICAgICAgICAgICAgICBbJ2hlYWRlckNlbGxBY3RpdmVDb2xvcicsICdyZ2JhKDAsIDAsIDAsIDEpJ10sXG4gICAgICAgICAgICAgICAgWydoZWFkZXJDZWxsQWN0aXZlQmFja2dyb3VuZENvbG9yJywgJ3JnYmEoMjI1LCAyMjUsIDIyNSwgMSknXSxcbiAgICAgICAgICAgICAgICBbJ2hlYWRlclJvd1dpZHRoJywgNTddLFxuICAgICAgICAgICAgICAgIFsncm93SGVhZGVyQ2VsbFBhZGRpbmdUb3AnLCA1XSxcbiAgICAgICAgICAgICAgICBbJ3Jvd0hlYWRlckNlbGxQYWRkaW5nTGVmdCcsIDVdLFxuICAgICAgICAgICAgICAgIFsncm93SGVhZGVyQ2VsbFBhZGRpbmdSaWdodCcsIDVdLFxuICAgICAgICAgICAgICAgIFsncm93SGVhZGVyQ2VsbEhlaWdodCcsIDI1XSxcbiAgICAgICAgICAgICAgICBbJ3Jvd0hlYWRlckNlbGxCb3JkZXJXaWR0aCcsIDAuMjVdLFxuICAgICAgICAgICAgICAgIFsncm93SGVhZGVyQ2VsbEJvcmRlckNvbG9yJywgJ3JnYmEoMTUyLCAxNTIsIDE1MiwgMSknXSxcbiAgICAgICAgICAgICAgICBbJ3Jvd0hlYWRlckNlbGxGb250JywgJzE2cHggc2Fucy1zZXJpZiddLFxuICAgICAgICAgICAgICAgIFsncm93SGVhZGVyQ2VsbENvbG9yJywgJ3JnYmEoNTAsIDUwLCA1MCwgMSknXSxcbiAgICAgICAgICAgICAgICBbJ3Jvd0hlYWRlckNlbGxCYWNrZ3JvdW5kQ29sb3InLCAncmdiYSgyNDAsIDI0MCwgMjQwLCAxKSddLFxuICAgICAgICAgICAgICAgIFsncm93SGVhZGVyQ2VsbEhvdmVyQ29sb3InLCAncmdiYSgwLCAwLCAwLCAxKSddLFxuICAgICAgICAgICAgICAgIFsncm93SGVhZGVyQ2VsbEhvdmVyQmFja2dyb3VuZENvbG9yJywgJ3JnYmEoMjM1LCAyMzUsIDIzNSwgMSknXSxcbiAgICAgICAgICAgICAgICBbJ3Jvd0hlYWRlckNlbGxTZWxlY3RlZENvbG9yJywgJ3JnYmEoNTAsIDUwLCA1MCwgMSknXSxcbiAgICAgICAgICAgICAgICBbJ3Jvd0hlYWRlckNlbGxTZWxlY3RlZEJhY2tncm91bmRDb2xvcicsICdyZ2JhKDIxNywgMjE3LCAyMTcsIDEpJ10sXG4gICAgICAgICAgICAgICAgWydyb3dIZWFkZXJDZWxsQWN0aXZlQ29sb3InLCAncmdiYSgwLCAwLCAwLCAxKSddLFxuICAgICAgICAgICAgICAgIFsncm93SGVhZGVyQ2VsbEFjdGl2ZUJhY2tncm91bmRDb2xvcicsICdyZ2JhKDIyNSwgMjI1LCAyMjUsIDEpJ10sXG4gICAgICAgICAgICAgICAgWydhY3RpdmVDZWxsT3ZlcmxheUJvcmRlckNvbG9yJywgJ3JnYmEoNjYsIDEzMywgMjQ0LCAxKSddLFxuICAgICAgICAgICAgICAgIFsnYWN0aXZlQ2VsbE92ZXJsYXlCb3JkZXJXaWR0aCcsIDJdLFxuICAgICAgICAgICAgICAgIFsnc2VsZWN0aW9uT3ZlcmxheUJvcmRlckNvbG9yJywgJ3JnYmEoNjYsIDEzMywgMjQ0LCAxKSddLFxuICAgICAgICAgICAgICAgIFsnc2VsZWN0aW9uT3ZlcmxheUJvcmRlcldpZHRoJywgMS4yNV0sXG4gICAgICAgICAgICAgICAgWydyZW9yZGVyTWFya2VySW5kZXhCb3JkZXJDb2xvcicsICdyZ2JhKDY2LCAxMzMsIDI0NCwgMSknXSxcbiAgICAgICAgICAgICAgICBbJ3Jlb3JkZXJNYXJrZXJJbmRleEJvcmRlcldpZHRoJywgMi43NV0sXG4gICAgICAgICAgICAgICAgWydyZW9yZGVyTWFya2VyQmFja2dyb3VuZENvbG9yJywgJ3JnYmEoMCwgMCwgMCwgMC4xKSddLFxuICAgICAgICAgICAgICAgIFsncmVvcmRlck1hcmtlckJvcmRlckNvbG9yJywgJ3JnYmEoMCwgMCwgMCwgMC4yKSddLFxuICAgICAgICAgICAgICAgIFsncmVvcmRlck1hcmtlckJvcmRlcldpZHRoJywgMS4yNV0sXG4gICAgICAgICAgICAgICAgWydncmlkQm9yZGVyQ29sb3InLCAncmdiYSgyMDIsIDIwMiwgMjAyLCAxKSddLFxuICAgICAgICAgICAgICAgIFsnZ3JpZEJvcmRlcldpZHRoJywgMV1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICB9O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9kZWZhdWx0cy5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */
/*!********************!*\
  !*** ./lib/dom.js ***!
  \********************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jslint browser: true, unparam: true, todo: true*/\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n    'use strict';\n    return function (self) {\n        self.attachCss = function () {\n            var styleSheet,\n                styleSheetBody = [],\n                css = {\n                    'canvas-datagrid-canvas': {\n                        position: 'absolute!important',\n                        'z-index': '-1'\n                    },\n                    'canvas-datagrid-scrollBox': {\n                        position: 'absolute!important',\n                        overflow: 'auto!important',\n                        'z-index': '1!important'\n                    },\n                    'canvas-datagrid': {\n                        position: 'absolute!important',\n                        background: self.style.backgroundColor,\n                        'z-index': '1',\n                        'box-sizing': 'content-box!important',\n                        padding: '0!important'\n                    },\n                    'canvas-datagrid-control-input': {\n                        position: 'fixed!important',\n                        top: '-5px',\n                        left: '-5px',\n                        border: 'none!important',\n                        opacity: '0!important',\n                        cursor: 'pointer!important',\n                        width: '1px',\n                        height: '1px'\n                    },\n                    'canvas-datagrid-edit-input': {\n                        'box-sizing': 'content-box!important',\n                        outline: 'none!important',\n                        margin: '0!important',\n                        padding: '0 0 0 ' + self.style.editCellPaddingLeft + 'px!important',\n                        'font-size': self.style.editCellFontSize + '!important',\n                        'font-family': self.style.editCellFontFamily + '!important',\n                        'box-shadow': self.style.editCellBoxShadow,\n                        border: self.style.editCellBorder\n                    },\n                    'canvas-datagrid-context-menu-item': {\n                        margin: self.style.contextMenuItemMargin,\n                        'border-radius': self.style.contextMenuItemBorderRadius\n                    },\n                    'canvas-datagrid-context-menu-item:hover': {\n                        background: self.style.contextMenuHoverBackground,\n                        color: self.style.contextMenuHoverColor,\n                        margin: self.style.contextMenuItemMargin\n                    },\n                    'canvas-datagrid-context-menu-label': {\n                        'margin': self.style.contextMenuLabelMargin,\n                        display: self.style.contextMenuLabelDisplay,\n                        'min-width': self.style.contextMenuLabelMinWidth,\n                        'max-width': self.style.contextMenuLabelMaxWidth,\n                    },\n                    'canvas-datagrid-context-menu': {\n                        'font-family': self.style.contextMenuFontFamily,\n                        'font-size': self.style.contextMenuFontSize,\n                        background: self.style.contextMenuBackground,\n                        color: self.style.contextMenuColor,\n                        border: self.style.contextMenuBorder,\n                        padding: self.style.contextMenuPadding,\n                        'border-radius': self.style.contextMenuBorderRadius,\n                        opacity: self.style.contextMenuOpacity\n                    },\n                    'canvas-datagrid-invalid-search-regExp': {\n                        background: self.style.contextMenuFilterInvalidExpresion\n                    }\n                };\n            Object.keys(css).forEach(function (className) {\n                styleSheetBody.push('.' + className + '{');\n                Object.keys(css[className]).forEach(function (propertyName) {\n                    styleSheetBody.push(propertyName + ':' + css[className][propertyName] + ';');\n                });\n                styleSheetBody.push('}');\n            });\n            if (document.getElementById(self.uniqueId)) {\n                return;\n            }\n            styleSheet = document.createElement('link');\n            styleSheet.id = self.uniqueId;\n            styleSheet.rel = 'stylesheet';\n            if (document.head.firstChild) {\n                document.head.insertBefore(styleSheet, document.head.firstChild);\n            } else {\n                document.head.appendChild(styleSheet);\n            }\n            styleSheet.href = 'data:text/css;base64,'\n                + btoa(self.style.styleSheet || styleSheetBody.join(''));\n        };\n        self.appendTo = function (n) {\n            self.parentNode = n;\n            self.height = self.parentNode.offsetHeight;\n            self.width = self.parentNode.offsetWidth;\n            if (self.parentNode && /canvas-datagrid-(cell|tree)/.test(self.parentNode.nodeType)) {\n                self.isChildGrid = true;\n                self.parentGrid = self.parentNode.parentGrid;\n                self.ctx = self.parentGrid.context;\n                self.canvas = self.parentGrid.canvas;\n                self.controlInput = self.parentGrid.controlInput;\n                self.eventParent = self.canvas;\n                self.intf.offsetParent = self.parentNode;\n            } else {\n                self.controlInput = document.createElement('input');\n                self.controlInput.className = 'canvas-datagrid-control-input';\n                self.isChildGrid = false;\n                self.parentDOMNode = self.parentNode;\n                self.parentNode = self.parentDOMNode;\n                self.canvas = document.createElement('canvas');\n                self.ctx = self.canvas.getContext('2d');\n                self.ctx.textBaseline = 'alphabetic';\n                self.parentDOMNode.appendChild(self.canvas);\n                self.parentDOMNode.appendChild(self.controlInput);\n                self.eventParent = self.canvas;\n            }\n            window.addEventListener('resize', self.resize);\n            if (MutationObserver) {\n                self.observer = new MutationObserver(function (mutations) {\n                    mutations.forEach(function (mutation) {\n                        self.resize(true);\n                    });\n                });\n                [self.canvas.parentNode].forEach(function (el) {\n                    self.observer.observe(el, { attributes: true });\n                });\n            }\n            self.eventParent.addEventListener('mouseup', self.mouseup, false);\n            self.eventParent.addEventListener('mousedown', self.mousedown, false);\n            self.eventParent.addEventListener('dblclick', self.dblclick, false);\n            self.eventParent.addEventListener('click', self.click, false);\n            self.eventParent.addEventListener('mousemove', self.mousemove);\n            self.eventParent.addEventListener('mousewheel', self.scrollWheel, false);\n            self.canvas.addEventListener('contextmenu', self.contextmenu, false);\n            self.canvas.addEventListener('copy', self.copy);\n            self.controlInput.addEventListener('keypress', self.keypress, false);\n            self.controlInput.addEventListener('keyup', self.keyup, false);\n            self.controlInput.addEventListener('keydown', self.keydown, false);\n        };\n        self.setDom = function () {\n            self.appendTo(self.args.parentNode);\n            self.attachCss();\n        };\n        self.initScrollBox = function () {\n            var sHeight = 0,\n                sWidth = 0,\n                scrollTop = 0,\n                scrollLeft = 0,\n                scrollHeight = 0,\n                scrollWidth = 0,\n                scrollBoxHeight = 20,\n                scrollBoxWidth = 20;\n            Object.defineProperty(self.scrollBox, 'scrollBoxHeight', {\n                get: function () {\n                    return scrollBoxHeight;\n                },\n                set: function (value) {\n                    scrollBoxHeight = value;\n                }\n            });\n            Object.defineProperty(self.scrollBox, 'scrollBoxWidth', {\n                get: function () {\n                    return scrollBoxWidth;\n                },\n                set: function (value) {\n                    scrollBoxWidth = value;\n                }\n            });\n            Object.defineProperty(self.scrollBox, 'height', {\n                get: function () {\n                    return sHeight;\n                },\n                set: function (value) {\n                    if (scrollHeight < value) {\n                        scrollTop = 0;\n                    }\n                    sHeight = value;\n                }\n            });\n            Object.defineProperty(self.scrollBox, 'width', {\n                get: function () {\n                    return sWidth;\n                },\n                set: function (value) {\n                    sWidth = value;\n                }\n            });\n            Object.defineProperty(self.scrollBox, 'scrollTop', {\n                get: function () {\n                    return scrollTop;\n                },\n                set: function (value) {\n                    if (value < 0) {\n                        value = 0;\n                    }\n                    if (value > scrollHeight) {\n                        value = scrollHeight;\n                    }\n                    if (scrollHeight < 0) {\n                        value = 0;\n                    }\n                    scrollTop = value;\n                    self.scroll();\n                }\n            });\n            Object.defineProperty(self.scrollBox, 'scrollLeft', {\n                get: function () {\n                    return scrollLeft;\n                },\n                set: function (value) {\n                    if (value < 0) {\n                        value = 0;\n                    }\n                    if (value > scrollWidth) {\n                        value = scrollWidth;\n                    }\n                    if (scrollWidth < 0) {\n                        value = 0;\n                    }\n                    scrollLeft = value;\n                    self.scroll();\n                }\n            });\n            Object.defineProperty(self.scrollBox, 'scrollHeight', {\n                get: function () {\n                    return scrollHeight;\n                },\n                set: function (value) {\n                    if (scrollTop > value) {\n                        scrollTop = Math.max(value, 0);\n                    }\n                    if (scrollHeight < sHeight) {\n                        scrollTop = 0;\n                    }\n                    scrollHeight = value;\n                }\n            });\n            Object.defineProperty(self.scrollBox, 'scrollWidth', {\n                get: function () {\n                    return scrollWidth;\n                },\n                set: function (value) {\n                    if (scrollLeft > value) {\n                        scrollLeft = Math.max(value, 0);\n                    }\n                    scrollWidth = value;\n                }\n            });\n        };\n    };\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi9kb20uanM/YjAxNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmpzbGludCBicm93c2VyOiB0cnVlLCB1bnBhcmFtOiB0cnVlLCB0b2RvOiB0cnVlKi9cbi8qZ2xvYmFscyBkZWZpbmU6IHRydWUsIE11dGF0aW9uT2JzZXJ2ZXI6IGZhbHNlLCByZXF1ZXN0QW5pbWF0aW9uRnJhbWU6IGZhbHNlLCBwZXJmb3JtYW5jZTogZmFsc2UsIGJ0b2E6IGZhbHNlKi9cbmRlZmluZShbXSwgZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNlbGYpIHtcbiAgICAgICAgc2VsZi5hdHRhY2hDc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGVTaGVldCxcbiAgICAgICAgICAgICAgICBzdHlsZVNoZWV0Qm9keSA9IFtdLFxuICAgICAgICAgICAgICAgIGNzcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NhbnZhcy1kYXRhZ3JpZC1jYW52YXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlIWltcG9ydGFudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnei1pbmRleCc6ICctMSdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2NhbnZhcy1kYXRhZ3JpZC1zY3JvbGxCb3gnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlIWltcG9ydGFudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogJ2F1dG8haW1wb3J0YW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd6LWluZGV4JzogJzEhaW1wb3J0YW50J1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnY2FudmFzLWRhdGFncmlkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSFpbXBvcnRhbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZDogc2VsZi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAnei1pbmRleCc6ICcxJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdib3gtc2l6aW5nJzogJ2NvbnRlbnQtYm94IWltcG9ydGFudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAnMCFpbXBvcnRhbnQnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdjYW52YXMtZGF0YWdyaWQtY29udHJvbC1pbnB1dCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnZml4ZWQhaW1wb3J0YW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogJy01cHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogJy01cHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiAnbm9uZSFpbXBvcnRhbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogJzAhaW1wb3J0YW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjogJ3BvaW50ZXIhaW1wb3J0YW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnMXB4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogJzFweCdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2NhbnZhcy1kYXRhZ3JpZC1lZGl0LWlucHV0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2JveC1zaXppbmcnOiAnY29udGVudC1ib3ghaW1wb3J0YW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGxpbmU6ICdub25lIWltcG9ydGFudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW46ICcwIWltcG9ydGFudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAnMCAwIDAgJyArIHNlbGYuc3R5bGUuZWRpdENlbGxQYWRkaW5nTGVmdCArICdweCFpbXBvcnRhbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZvbnQtc2l6ZSc6IHNlbGYuc3R5bGUuZWRpdENlbGxGb250U2l6ZSArICchaW1wb3J0YW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmb250LWZhbWlseSc6IHNlbGYuc3R5bGUuZWRpdENlbGxGb250RmFtaWx5ICsgJyFpbXBvcnRhbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2JveC1zaGFkb3cnOiBzZWxmLnN0eWxlLmVkaXRDZWxsQm94U2hhZG93LFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiBzZWxmLnN0eWxlLmVkaXRDZWxsQm9yZGVyXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdjYW52YXMtZGF0YWdyaWQtY29udGV4dC1tZW51LWl0ZW0nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW46IHNlbGYuc3R5bGUuY29udGV4dE1lbnVJdGVtTWFyZ2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2JvcmRlci1yYWRpdXMnOiBzZWxmLnN0eWxlLmNvbnRleHRNZW51SXRlbUJvcmRlclJhZGl1c1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnY2FudmFzLWRhdGFncmlkLWNvbnRleHQtbWVudS1pdGVtOmhvdmVyJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZDogc2VsZi5zdHlsZS5jb250ZXh0TWVudUhvdmVyQmFja2dyb3VuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBzZWxmLnN0eWxlLmNvbnRleHRNZW51SG92ZXJDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbjogc2VsZi5zdHlsZS5jb250ZXh0TWVudUl0ZW1NYXJnaW5cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2NhbnZhcy1kYXRhZ3JpZC1jb250ZXh0LW1lbnUtbGFiZWwnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFyZ2luJzogc2VsZi5zdHlsZS5jb250ZXh0TWVudUxhYmVsTWFyZ2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogc2VsZi5zdHlsZS5jb250ZXh0TWVudUxhYmVsRGlzcGxheSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4td2lkdGgnOiBzZWxmLnN0eWxlLmNvbnRleHRNZW51TGFiZWxNaW5XaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgtd2lkdGgnOiBzZWxmLnN0eWxlLmNvbnRleHRNZW51TGFiZWxNYXhXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2NhbnZhcy1kYXRhZ3JpZC1jb250ZXh0LW1lbnUnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnZm9udC1mYW1pbHknOiBzZWxmLnN0eWxlLmNvbnRleHRNZW51Rm9udEZhbWlseSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmb250LXNpemUnOiBzZWxmLnN0eWxlLmNvbnRleHRNZW51Rm9udFNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiBzZWxmLnN0eWxlLmNvbnRleHRNZW51QmFja2dyb3VuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBzZWxmLnN0eWxlLmNvbnRleHRNZW51Q29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXI6IHNlbGYuc3R5bGUuY29udGV4dE1lbnVCb3JkZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiBzZWxmLnN0eWxlLmNvbnRleHRNZW51UGFkZGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdib3JkZXItcmFkaXVzJzogc2VsZi5zdHlsZS5jb250ZXh0TWVudUJvcmRlclJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IHNlbGYuc3R5bGUuY29udGV4dE1lbnVPcGFjaXR5XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdjYW52YXMtZGF0YWdyaWQtaW52YWxpZC1zZWFyY2gtcmVnRXhwJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZDogc2VsZi5zdHlsZS5jb250ZXh0TWVudUZpbHRlckludmFsaWRFeHByZXNpb25cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhjc3MpLmZvckVhY2goZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRCb2R5LnB1c2goJy4nICsgY2xhc3NOYW1lICsgJ3snKTtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhjc3NbY2xhc3NOYW1lXSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRCb2R5LnB1c2gocHJvcGVydHlOYW1lICsgJzonICsgY3NzW2NsYXNzTmFtZV1bcHJvcGVydHlOYW1lXSArICc7Jyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3R5bGVTaGVldEJvZHkucHVzaCgnfScpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc2VsZi51bmlxdWVJZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsZVNoZWV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuICAgICAgICAgICAgc3R5bGVTaGVldC5pZCA9IHNlbGYudW5pcXVlSWQ7XG4gICAgICAgICAgICBzdHlsZVNoZWV0LnJlbCA9ICdzdHlsZXNoZWV0JztcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5oZWFkLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5oZWFkLmluc2VydEJlZm9yZShzdHlsZVNoZWV0LCBkb2N1bWVudC5oZWFkLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlU2hlZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3R5bGVTaGVldC5ocmVmID0gJ2RhdGE6dGV4dC9jc3M7YmFzZTY0LCdcbiAgICAgICAgICAgICAgICArIGJ0b2Eoc2VsZi5zdHlsZS5zdHlsZVNoZWV0IHx8IHN0eWxlU2hlZXRCb2R5LmpvaW4oJycpKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5hcHBlbmRUbyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICBzZWxmLnBhcmVudE5vZGUgPSBuO1xuICAgICAgICAgICAgc2VsZi5oZWlnaHQgPSBzZWxmLnBhcmVudE5vZGUub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgc2VsZi53aWR0aCA9IHNlbGYucGFyZW50Tm9kZS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIGlmIChzZWxmLnBhcmVudE5vZGUgJiYgL2NhbnZhcy1kYXRhZ3JpZC0oY2VsbHx0cmVlKS8udGVzdChzZWxmLnBhcmVudE5vZGUubm9kZVR5cGUpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5pc0NoaWxkR3JpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2VsZi5wYXJlbnRHcmlkID0gc2VsZi5wYXJlbnROb2RlLnBhcmVudEdyaWQ7XG4gICAgICAgICAgICAgICAgc2VsZi5jdHggPSBzZWxmLnBhcmVudEdyaWQuY29udGV4dDtcbiAgICAgICAgICAgICAgICBzZWxmLmNhbnZhcyA9IHNlbGYucGFyZW50R3JpZC5jYW52YXM7XG4gICAgICAgICAgICAgICAgc2VsZi5jb250cm9sSW5wdXQgPSBzZWxmLnBhcmVudEdyaWQuY29udHJvbElucHV0O1xuICAgICAgICAgICAgICAgIHNlbGYuZXZlbnRQYXJlbnQgPSBzZWxmLmNhbnZhcztcbiAgICAgICAgICAgICAgICBzZWxmLmludGYub2Zmc2V0UGFyZW50ID0gc2VsZi5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbnRyb2xJbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgICAgICAgICAgc2VsZi5jb250cm9sSW5wdXQuY2xhc3NOYW1lID0gJ2NhbnZhcy1kYXRhZ3JpZC1jb250cm9sLWlucHV0JztcbiAgICAgICAgICAgICAgICBzZWxmLmlzQ2hpbGRHcmlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2VsZi5wYXJlbnRET01Ob2RlID0gc2VsZi5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIHNlbGYucGFyZW50Tm9kZSA9IHNlbGYucGFyZW50RE9NTm9kZTtcbiAgICAgICAgICAgICAgICBzZWxmLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgICAgIHNlbGYuY3R4ID0gc2VsZi5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgICAgICBzZWxmLmN0eC50ZXh0QmFzZWxpbmUgPSAnYWxwaGFiZXRpYyc7XG4gICAgICAgICAgICAgICAgc2VsZi5wYXJlbnRET01Ob2RlLmFwcGVuZENoaWxkKHNlbGYuY2FudmFzKTtcbiAgICAgICAgICAgICAgICBzZWxmLnBhcmVudERPTU5vZGUuYXBwZW5kQ2hpbGQoc2VsZi5jb250cm9sSW5wdXQpO1xuICAgICAgICAgICAgICAgIHNlbGYuZXZlbnRQYXJlbnQgPSBzZWxmLmNhbnZhcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBzZWxmLnJlc2l6ZSk7XG4gICAgICAgICAgICBpZiAoTXV0YXRpb25PYnNlcnZlcikge1xuICAgICAgICAgICAgICAgIHNlbGYub2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAobXV0YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIG11dGF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChtdXRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZXNpemUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIFtzZWxmLmNhbnZhcy5wYXJlbnROb2RlXS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm9ic2VydmVyLm9ic2VydmUoZWwsIHsgYXR0cmlidXRlczogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuZXZlbnRQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHNlbGYubW91c2V1cCwgZmFsc2UpO1xuICAgICAgICAgICAgc2VsZi5ldmVudFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBzZWxmLm1vdXNlZG93biwgZmFsc2UpO1xuICAgICAgICAgICAgc2VsZi5ldmVudFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIHNlbGYuZGJsY2xpY2ssIGZhbHNlKTtcbiAgICAgICAgICAgIHNlbGYuZXZlbnRQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzZWxmLmNsaWNrLCBmYWxzZSk7XG4gICAgICAgICAgICBzZWxmLmV2ZW50UGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHNlbGYubW91c2Vtb3ZlKTtcbiAgICAgICAgICAgIHNlbGYuZXZlbnRQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIHNlbGYuc2Nyb2xsV2hlZWwsIGZhbHNlKTtcbiAgICAgICAgICAgIHNlbGYuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51Jywgc2VsZi5jb250ZXh0bWVudSwgZmFsc2UpO1xuICAgICAgICAgICAgc2VsZi5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignY29weScsIHNlbGYuY29weSk7XG4gICAgICAgICAgICBzZWxmLmNvbnRyb2xJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIHNlbGYua2V5cHJlc3MsIGZhbHNlKTtcbiAgICAgICAgICAgIHNlbGYuY29udHJvbElucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgc2VsZi5rZXl1cCwgZmFsc2UpO1xuICAgICAgICAgICAgc2VsZi5jb250cm9sSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHNlbGYua2V5ZG93biwgZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICBzZWxmLnNldERvbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYuYXBwZW5kVG8oc2VsZi5hcmdzLnBhcmVudE5vZGUpO1xuICAgICAgICAgICAgc2VsZi5hdHRhY2hDc3MoKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5pbml0U2Nyb2xsQm94ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNIZWlnaHQgPSAwLFxuICAgICAgICAgICAgICAgIHNXaWR0aCA9IDAsXG4gICAgICAgICAgICAgICAgc2Nyb2xsVG9wID0gMCxcbiAgICAgICAgICAgICAgICBzY3JvbGxMZWZ0ID0gMCxcbiAgICAgICAgICAgICAgICBzY3JvbGxIZWlnaHQgPSAwLFxuICAgICAgICAgICAgICAgIHNjcm9sbFdpZHRoID0gMCxcbiAgICAgICAgICAgICAgICBzY3JvbGxCb3hIZWlnaHQgPSAyMCxcbiAgICAgICAgICAgICAgICBzY3JvbGxCb3hXaWR0aCA9IDIwO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuc2Nyb2xsQm94LCAnc2Nyb2xsQm94SGVpZ2h0Jywge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2Nyb2xsQm94SGVpZ2h0O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsQm94SGVpZ2h0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZi5zY3JvbGxCb3gsICdzY3JvbGxCb3hXaWR0aCcsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjcm9sbEJveFdpZHRoO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsQm94V2lkdGggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLnNjcm9sbEJveCwgJ2hlaWdodCcsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNIZWlnaHQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsSGVpZ2h0IDwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFRvcCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc0hlaWdodCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuc2Nyb2xsQm94LCAnd2lkdGgnLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzV2lkdGg7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzV2lkdGggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLnNjcm9sbEJveCwgJ3Njcm9sbFRvcCcsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiBzY3JvbGxIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY3JvbGxIZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVG9wID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2Nyb2xsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZi5zY3JvbGxCb3gsICdzY3JvbGxMZWZ0Jywge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiBzY3JvbGxXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzY3JvbGxXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsV2lkdGggPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsTGVmdCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNjcm9sbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuc2Nyb2xsQm94LCAnc2Nyb2xsSGVpZ2h0Jywge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjcm9sbFRvcCA+IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxUb3AgPSBNYXRoLm1heCh2YWx1ZSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjcm9sbEhlaWdodCA8IHNIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFRvcCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsSGVpZ2h0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZi5zY3JvbGxCb3gsICdzY3JvbGxXaWR0aCcsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjcm9sbFdpZHRoO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjcm9sbExlZnQgPiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsTGVmdCA9IE1hdGgubWF4KHZhbHVlLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxXaWR0aCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH07XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2RvbS5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6\n");

/***/ }),
/* 7 */
/*!******************************!*\
  !*** ./lib/publicMethods.js ***!
  \******************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jslint browser: true, unparam: true, todo: true*/\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n    'use strict';\n    return function (self) {\n        // all methods here are exposed by intf\n        // to users\n        /**\n         * Inserts a new column before the specified index into the schema.\n         * @see canvasDataGrid#schema\n         * @tutorial schema\n         * @memberof canvasDataGrid#\n         * @method\n         * @param {column} rowIndex The column to insert into the schema.\n         * @param {number} index The index of the row to insert before.\n         */\n        self.insertColumn = function (c, index) {\n            var s = self.getSchema();\n            if (s.length < index) {\n                throw new Error('Index is beyond the length of the schema.');\n            }\n            self.validateColumn(c, s);\n            self.intf.schema = s.splice(index, 0, c);\n        };\n        /**\n         * Deletes a column from the schema at the specified index.\n         * @memberof canvasDataGrid#\n         * @tutorial schema\n         * @method\n         * @param {number} index The index of the column to delete.\n         */\n        self.deleteColumn = function (index) {\n            var s = self.getSchema();\n            self.intf.schema = s.splice(index, 1);\n        };\n        /**\n         * Adds a new column into the schema.\n         * @see canvasDataGrid#schema\n         * @tutorial schema\n         * @memberof canvasDataGrid#\n         * @method\n         * @param {column} c The column to add to the schema.\n         */\n        self.addColumn = function (c) {\n            var s = self.getSchema();\n            self.validateColumn(c, s);\n            s.push(c);\n            self.intf.schema = s;\n        };\n        /**\n         * Deletes a row from the dataset at the specified index.\n         * @memberof canvasDataGrid#\n         * @method\n         * @param {number} index The index of the row to delete.\n         */\n        self.deleteRow = function (index) {\n            self.originalData.splice(index, 1);\n            self.setFilter();\n            self.resize(true);\n        };\n        /**\n         * Inserts a new row into the dataset before the specified index.\n         * @memberof canvasDataGrid#\n         * @method\n         * @param {object} d data.\n         * @param {number} index The index of the row to insert before.\n         */\n        self.insertRow = function (d, index) {\n            if (self.originalData.length < index) {\n                throw new Error('Index is beyond the length of the dataset.');\n            }\n            self.originalData.splice(index, 0, d);\n            self.setFilter();\n            self.resize(true);\n        };\n        /**\n         * Adds a new row into the dataset.\n         * @memberof canvasDataGrid#\n         * @method\n         * @param {object} d data.\n         */\n        self.addRow = function (d) {\n            self.originalData.push(d);\n            self.setFilter();\n            self.resize(true);\n        };\n        /**\n         * Sets the height of a given row by index number.\n         * @memberof canvasDataGrid#\n         * @method\n         * @param {number} rowIndex The index of the row to set.\n         * @param {number} height Height to set the row to.\n         */\n        self.setRowHeight = function (rowIndex, height) {\n            self.sizes.rows[self.data[rowIndex][self.uniqueId]] = height;\n            self.draw(true);\n        };\n        /**\n         * Sets the width of a given column by index number.\n         * @memberof canvasDataGrid#\n         * @method\n         * @param {number} colIndex The index of the column to set.\n         * @param {number} width Width to set the column to.\n         */\n        self.setColumnWidth = function (colIndex, width) {\n            var s = self.getSchema();\n            self.sizes.columns[s[colIndex][self.uniqueId]] = width;\n            self.draw(true);\n        };\n        /**\n         * Removes any changes to the width of the columns due to user or api interaction, setting them back to the schema or style default.\n         * @memberof canvasDataGrid#\n         * @tutorial schema\n         * @method\n         */\n        self.resetColumnWidths = function () {\n            self.sizes.columns = {};\n            self.draw(true);\n        };\n        /**\n         * Removes any changes to the height of the rows due to user or api interaction, setting them back to the schema or style default.\n         * @memberof canvasDataGrid#\n         * @tutorial schema\n         * @method\n         */\n        self.resetRowHeights = function () {\n            self.sizes.rows = {};\n            self.draw(true);\n        };\n        /**\n         * Sets the value of the filter.\n         * @memberof canvasDataGrid#\n         * @method\n         * @param {string} column Name of the column to filter.\n         * @param {string} value The value to filter for.\n         */\n        self.setFilter = function (column, value) {\n            function applyFilter() {\n                self.refreshFromOrigialData();\n                Object.keys(self.columnFilters).forEach(function (filter) {\n                    var header = self.getHeaderByName(column);\n                    if (!header) {\n                        return;\n                    }\n                    self.currentFilter = header.filter;\n                    self.data = self.data.filter(function (row) {\n                        return self.currentFilter(row[filter], self.columnFilters[filter]);\n                    });\n                });\n                self.resize();\n                self.draw(true);\n            }\n            if (self.coulumn === undefined && value === undefined) {\n                return applyFilter();\n            }\n            if (column && (value === '' || value === undefined)) {\n                delete self.columnFilters[column];\n            } else {\n                self.columnFilters[column] = value;\n            }\n            applyFilter();\n        };\n        /**\n         * Returns the number of pixels to scroll down to line up with row rowIndex.\n         * @memberof canvasDataGrid#\n         * @method\n         * @param {number} rowIndex The row index of the row to scroll find.\n         */\n        self.findRowScrollTop = function (rowIndex) {\n            var top = 0, x = 0, l = self.data.length,\n                cellBorder = self.style.cellBorderWidth * 2;\n            if (!self.attributes.showNewRow) {\n                l -= 1;\n            }\n            if (rowIndex > l) {\n                throw new Error('Impossible row index');\n            }\n            while (x < rowIndex) {\n                top += (self.sizes.rows[self.data[x][self.uniqueId]] || self.style.cellHeight) + cellBorder;\n                x += 1;\n            }\n            //TODO: This is not super accurate, causes pageUp/Dn to not move around right\n            return top - (self.sizes.rows[self.data[rowIndex][self.uniqueId]] || self.style.cellHeight);\n        };\n        /**\n         * Returns the number of pixels to scroll to the left to line up with column columnIndex.\n         * @memberof canvasDataGrid#\n         * @method\n         * @param {number} columnIndex The column index of the column to find.\n         */\n        self.findColumnScrollLeft = function (columnIndex) {\n            var left = 0, y = 0, s = self.getSchema(), l = s.length - 1;\n            if (columnIndex > l) {\n                throw new Error('Impossible column index');\n            }\n            while (y < columnIndex) {\n                left += self.sizes.columns[s[y][self.uniqueId]] || s[y].width;\n                y += 1;\n            }\n            return left;\n        };\n        /**\n         * Scrolls the cell at cell x, row y.\n         * @memberof canvasDataGrid#\n         * @method\n         * @param {number} x The column index of the cell to scroll to.\n         * @param {number} y The row index of the cell to scroll to.\n         */\n        self.gotoCell = function (x, y) {\n            if (x !== undefined) {\n                self.scrollBox.scrollLeft = self.findColumnScrollLeft(x);\n            }\n            if (y !== undefined) {\n                self.scrollBox.scrollTop = self.findRowScrollTop(y);\n            }\n        };\n        /**\n         * Scrolls the row y.\n         * @memberof canvasDataGrid#\n         * @method\n         * @param {number} y The row index of the cell to scroll to.\n         */\n        self.gotoRow = function (y) {\n            self.gotoCell(0, y);\n        };\n        /**\n         * Scrolls the cell at cell x, row y into view if it is not already.\n         * @memberof canvasDataGrid#\n         * @method\n         * @param {number} x The column index of the cell to scroll into view.\n         * @param {number} y The row index of the cell to scroll into view.\n         */\n        self.scrollIntoView = function (x, y) {\n            if (self.visibleCells.filter(function (cell) {\n                    return (cell.rowIndex === y || y === undefined)\n                        && (cell.columnIndex === x || x === undefined)\n                        && cell.x > 0\n                        && cell.y > 0\n                        && cell.x + cell.width < self.width\n                        && cell.y + cell.height < self.height;\n                }).length === 0) {\n                self.gotoCell(x, y);\n            }\n        };\n        /**\n         * Sets the active cell. Requires redrawing.\n         * @memberof canvasDataGrid#\n         * @method\n         * @param {number} x The column index of the cell to set active.\n         * @param {number} y The row index of the cell to set active.\n         */\n        self.setActiveCell = function (x, y) {\n            self.activeCell = {\n                rowIndex: y,\n                columnIndex: x\n            };\n        };\n        /**\n         * Selects a row.\n         * @memberof canvasDataGrid#\n         * @method\n         * @param {boolean} toggleSelectMode When true, behaves as if you were holding control/command when you clicked the row.\n         * @param {boolean} supressSelectionchangedEvent When true, prevents the selectionchanged event from firing.\n         */\n        self.selectRow = function (rowIndex, ctrl, supressEvent) {\n            var s = self.getSchema();\n            if (self.dragAddToSelection === false) {\n                if (self.selections[rowIndex] && self.selections[rowIndex].length - 1 === s.length) {\n                    if (ctrl) {\n                        self.selections[rowIndex] = [];\n                        return;\n                    }\n                }\n            }\n            if (self.dragAddToSelection === true) {\n                self.selections[rowIndex] = [];\n                self.selections[rowIndex].push(-1);\n                s.forEach(function (col) {\n                    self.selections[rowIndex].push(col.index);\n                });\n            }\n            if (supressEvent) { return; }\n            self.dispatchEvent('selectionchanged', [self.getSelectedData(), self.selections, self.selectionBounds], self.intf);\n        };\n        /**\n         * Collapse a tree grid by row index.\n         * @memberof canvasDataGrid#\n         * @method\n         * @param {number} index The index of the row to collapse.\n         */\n        self.collapseTree = function (rowIndex) {\n            var rowId = self.data[rowIndex][self.uniqueId];\n            self.dispatchEvent('collapsetree', [self.childGrids[rowId], self.data[rowIndex], rowIndex], self.intf);\n            self.openChildren[rowId].blur();\n            self.openChildren[rowId].dispose();\n            delete self.openChildren[rowId];\n            delete self.sizes.trees[rowId];\n            delete self.childGrids[rowId];\n            self.dispatchEvent('resizerow', [self.style.cellHeight], self.intf);\n            self.resize(true);\n            self.draw(true);\n        };\n        /**\n         * Expands a tree grid by row index.\n         * @memberof canvasDataGrid#\n         * @method\n         * @param {number} index The index of the row to expand.\n         */\n        self.expandTree = function (rowIndex) {\n            var headerCellHeight = self.getHeaderCellHeight(),\n                headerCellWidth = self.sizes.columns.cornerCell || self.style.headerRowWidth,\n                rowId = self.data[rowIndex][self.uniqueId],\n                h = self.sizes.trees[rowId] || self.style.treeGridHeight,\n                treeGrid;\n            if (!self.childGrids[rowId]) {\n                treeGrid = grid({\n                    debug: self.attributes.debug,\n                    showPerformance: self.attributes.showPerformance,\n                    name: self.attributes.saveAppearance\n                        ? self.attributes.name + 'tree' + rowId : undefined,\n                    parentNode: {\n                        parentGrid: self.intf,\n                        nodeType: 'canvas-datagrid-tree',\n                        offsetHeight: h,\n                        offsetWidth: self.width - headerCellWidth,\n                        header: { width: self.width - headerCellWidth },\n                        offsetLeft: headerCellWidth,\n                        offsetTop: headerCellHeight,\n                        offsetParent: self.intf.parentNode,\n                        parentNode: self.intf.parentNode,\n                        style: 'tree',\n                        data: self.data[rowIndex]\n                    }\n                });\n                self.childGrids[rowId] = treeGrid;\n            }\n            treeGrid = self.childGrids[rowId];\n            treeGrid.visible = true;\n            self.dispatchEvent('expandtree', [treeGrid, self.data[rowIndex], rowIndex], self.intf);\n            self.openChildren[self.data[rowIndex][self.uniqueId]] = treeGrid;\n            self.sizes.trees[self.data[rowIndex][self.uniqueId]] = h;\n            self.dispatchEvent('resizerow', [self.style.cellHeight], self.intf);\n            self.resize(true);\n            self.draw();\n        };\n        /**\n         * Toggles tree grid open and close by row index.\n         * @memberof canvasDataGrid#\n         * @method\n         * @param {number} index The index of the row to toggle.\n         */\n        self.toggleTree = function (rowIndex) {\n            var i = self.openChildren[self.data[rowIndex][self.uniqueId]];\n            if (i) {\n                return self.collapseTree(rowIndex);\n            }\n            self.expandTree(rowIndex);\n        };\n        /**\n         * Returns a header from the schema by name.\n         * @memberof canvasDataGrid#\n         * @tutorial schema\n         * @method\n         * @returns {header} header with the selected name, or undefined.\n         * @param {string} name The name of the column to resize.\n         */\n        self.getHeaderByName = function (name) {\n            var x, i = self.getSchema();\n            for (x = 0; x < i.length; x += 1) {\n                if (i[x].name === name) {\n                    return i[x];\n                }\n            }\n        };\n        /**\n         * Resizes a column to fit the longest value in the column. Call without a value to resize all columns.\n         * Warning, can be slow on very large record sets (1m records ~3-5 seconds on an i7).\n         * @memberof canvasDataGrid#\n         * @method\n         * @param {string} name The name of the column to resize.\n         */\n        self.fitColumnToValues = function (name) {\n            self.sizes.columns[name === 'cornerCell' ? name : self.getHeaderByName(name)[self.uniqueId]]\n                = self.findColumnMaxTextLength(name);\n            self.resize();\n            self.draw(true);\n        };\n        /**\n         * Checks if a cell is currently visible.\n         * @memberof canvasDataGrid#\n         * @method\n         * @returns {boolean} when true, the cell is visible, when false the cell is not currently drawn.\n         * @param {cell} cell The cell to check for.  Alternatively you can pass an object { x: <x-index>, y: <y-index> }.\n         */\n        self.isCellVisible = function (cell) {\n            var x, l = self.visibleCells.length;\n            for (x = 0; x < l; x += 1) {\n                if (cell.x === self.visibleCells[x].x && cell.y === self.visibleCells[x].y) {\n                    return true;\n                }\n            }\n            return false;\n        };\n        /**\n         * Sets the order of the data.\n         * @memberof canvasDataGrid#\n         * @method\n         * @returns {cell} cell at the selected location.\n         * @param {number} columnName Number of pixels from the left.\n         * @param {string} direction `asc` for ascending or `desc` for descending.\n         * @param {bool} dontSetStorageData Don't store this setting for future use.\n         */\n        self.order = function (columnName, direction, dontSetStorageData) {\n            var f,\n                c = self.getSchema().filter(function (col) {\n                    return col.name === columnName;\n                });\n            self.orderBy = columnName;\n            if (c.length === 0) {\n                throw new Error('Cannot sort.  No such column name');\n            }\n            f = self.sorters[c[0].type];\n            if (!f && c[0].type !== undefined) {\n                console.warn('Cannot sort type \"%s\" falling back to string sort.', c[0].type);\n            }\n            self.data = self.data.sort(typeof f === 'function' ? f(columnName, direction) : self.sorters.string);\n            self.dispatchEvent('ordercolumn', [columnName, direction], self.intf);\n            self.draw(true);\n            if (dontSetStorageData) { return; }\n            self.setStorageData();\n        };\n        self.isInGrid = function (e) {\n            if (e.x < 0\n                    || e.x > self.width\n                    || e.y < 0\n                    || e.y > self.height) {\n                return false;\n            }\n            return true;\n        };\n        /**\n         * Gets the cell at grid pixel coordinate x and y.\n         * @memberof canvasDataGrid#\n         * @method\n         * @returns {cell} cell at the selected location.\n         * @param {number} x Number of pixels from the left.\n         * @param {number} y Number of pixels from the top.\n         */\n        self.getCellAt = function (x, y) {\n            var i, l = self.visibleCells.length, cell;\n            if (!self.visibleCells || !self.visibleCells.length) { return; }\n            self.hasFocus = true;\n            if (!(y < self.height\n                && y > 0\n                && x < self.width\n                && x > 0)) {\n                self.hasFocus = false;\n                return {\n                    dragContext: 'inherit',\n                    context: 'inherit'\n                };\n            }\n            for (i = 0; i < l; i += 1) {\n                cell = self.visibleCells[i];\n                if (cell.x - self.style.cellBorderWidth < x\n                        && cell.x + cell.width + self.style.cellBorderWidth > x\n                        && cell.y - self.style.cellBorderWidth < y\n                        && cell.y + cell.height + self.style.cellBorderWidth > y) {\n                    if (/vertical-scroll-(bar|box)/.test(cell.style)) {\n                        cell.dragContext = 'vertical-scroll-box';\n                        cell.context = 'vertical-scroll-box';\n                        if (y > self.scrollBox.box.v.y + self.scrollBox.scrollBoxHeight) {\n                            cell.dragContext = 'vertical-scroll-bottom';\n                            cell.context = 'vertical-scroll-bottom';\n                        } else if (y < self.scrollBox.box.v.y) {\n                            cell.dragContext = 'vertical-scroll-top';\n                            cell.context = 'vertical-scroll-top';\n                        }\n                        self.canvas.style.cursor = 'default';\n                        return cell;\n                    }\n                    if (/horizontal-scroll-(bar|box)/.test(cell.style)) {\n                        cell.dragContext = 'horizontal-scroll-box';\n                        cell.context = 'horizontal-scroll-box';\n                        if (x > self.scrollBox.box.h.x + self.scrollBox.scrollBoxWidth) {\n                            cell.dragContext = 'horizontal-scroll-right';\n                            cell.context = 'horizontal-scroll-right';\n                        } else if (x < self.scrollBox.box.h.x) {\n                            cell.dragContext = 'horizontal-scroll-left';\n                            cell.context = 'horizontal-scroll-left';\n                        }\n                        self.canvas.style.cursor = 'default';\n                        return cell;\n                    }\n                    if (cell.x + cell.width - (self.attributes.borderResizeZone * 0.4) < x\n                            && cell.x + cell.width + (self.attributes.borderResizeZone * 0.6) > x\n                            && self.attributes.allowColumnResize\n                            && ((self.attributes.allowColumnResizeFromCell && cell.style === 'cell')\n                                || cell.style !== 'cell')\n                            && ((self.attributes.allowRowHeaderResize\n                                && ['rowHeaderCell', 'cornerCell'].indexOf(cell.style) !== -1)\n                                || ['rowHeaderCell', 'cornerCell'].indexOf(cell.style) === -1)) {\n                        cell.context = 'ew-resize';\n                        cell.dragContext = 'ew-resize';\n                        return cell;\n                    }\n                    if (cell.y + cell.height - (self.attributes.borderResizeZone * 0.4) < y\n                            && cell.y + cell.height + (self.attributes.borderResizeZone * 0.6) > y\n                            && self.attributes.allowRowResize\n                            && ((self.attributes.allowRowResizeFromCell && cell.style === 'cell')\n                                || cell.style !== 'cell')\n                            && cell.style !== 'headerCell') {\n                        cell.context = 'ns-resize';\n                        cell.dragContext = 'ns-resize';\n                        return cell;\n                    }\n                    if (cell.style === 'headerCell') {\n                        cell.context = 'cell';\n                        cell.dragContext = 'column-reorder';\n                        return cell;\n                    }\n                    if (cell.style === 'rowHeaderCell') {\n                        cell.context = 'cell';\n                        cell.dragContext = 'row-reorder';\n                        return cell;\n                    }\n                    if (cell.isGrid) {\n                        self.hasFocus = false;\n                        cell.dragContext = 'cell-grid';\n                        cell.context = 'cell-grid';\n                        return cell;\n                    }\n                    if (cell.style === 'tree-grid') {\n                        self.hasFocus = false;\n                        cell.dragContext = 'tree';\n                        cell.context = 'tree';\n                        return cell;\n                    }\n                    cell.dragContext = 'cell';\n                    cell.context = 'cell';\n                    return cell;\n                }\n            }\n            self.hasFocus = false;\n            return {\n                context: 'inherit'\n            };\n        };\n        /**\n         * Gets the bounds of current selection. \n         * @returns {rect} selection.\n         * @memberof canvasDataGrid#\n         * @method\n         */\n        self.getSelectionBounds = function () {\n            var low = {x: Infinity, y: Infinity},\n                high = {x: -Infinity, y: -Infinity};\n            self.data.forEach(function (row, rowIndex) {\n                var maxCol, minCol;\n                if (self.selections[rowIndex] && self.selections[rowIndex].length) {\n                    low.y = rowIndex < low.y ? rowIndex : low.y;\n                    high.y = rowIndex > high.y ? rowIndex : high.y;\n                    maxCol = Math.max.apply(null, self.selections[rowIndex]);\n                    minCol = Math.min.apply(null, self.selections[rowIndex]);\n                    low.x = minCol < low.x ? minCol : low.x;\n                    high.x = maxCol > high.x ? maxCol : high.x;\n                }\n            });\n            return {\n                top: low.y,\n                left: low.x,\n                bottom: high.y,\n                right: high.x\n            };\n        };\n        /**\n         * Returns an auto generated schema based on data structure.\n         * @memberof canvasDataGrid#\n         * @method\n         * @tutorial schema\n         * @returns {schema} schema A schema based on the first item in the data array.\n         */\n        self.getSchemaFromData = function () {\n            return Object.keys(self.data[0] || {' ': ''}).map(function mapEachSchemaColumn(key, index) {\n                var type = self.getBestGuessDataType(key),\n                    i = {\n                        name: key,\n                        title: key,\n                        width: self.style.columnWidth,\n                        index: index,\n                        type: type,\n                        filter: self.filter(type)\n                    };\n                if (key === self.uniqueId) {\n                    i.hidden = true;\n                }\n                i[self.uniqueId] = self.getSchemaNameHash(key);\n                return i;\n            });\n        };\n        /**\n         * Clears the change log grid.changes that keeps track of changes to the data set.\n         * This does not undo changes or alter data it is simply a convince array to keep\n         * track of changes made to the data since last this method was called.\n         * @memberof canvasDataGrid#\n         * @method\n         */\n        self.clearChangeLog = function () {\n            self.changes = [];\n        };\n        /**\n         * Selects an area of the grid.\n         * @memberof canvasDataGrid#\n         * @method\n         * @param {rect} bounds A rect object representing the selected values.\n         */\n        self.selectArea = function (bounds, ctrl) {\n            self.selectionBounds = bounds || self.selectionBounds;\n            var x, y, s = self.getSchema();\n            if (!ctrl) {\n                self.selections = [];\n            }\n            if (self.selectionBounds.top < -1\n                    || self.selectionBounds.bottom > self.data.length\n                    || self.selectionBounds.left < -1\n                    || self.selectionBounds.right > s.length) {\n                throw new Error('Impossible selection area');\n            }\n            for (x = self.selectionBounds.top; x <= self.selectionBounds.bottom; x += 1) {\n                self.selections[x] = [];\n                for (y = self.selectionBounds.left; y <= self.selectionBounds.right; y += 1) {\n                    if (self.selections[x].indexOf(y) === -1) {\n                        self.selections[x].push(y);\n                    }\n                }\n            }\n            self.dispatchEvent('selectionchanged', [self.getSelectedData(), self.selections, self.selectionBounds], self.intf);\n        };\n        /**\n         * Returns the maximum text width for a given column by column name.\n         * @memberof canvasDataGrid#\n         * @method\n         * @returns {number} The number of pixels wide the maximum width value in the selected column.\n         * @param {string} name The name of the column to calculate the value's width of.\n         */\n        self.findColumnMaxTextLength = function (name) {\n            var m = -Infinity;\n            if (name === 'cornerCell') {\n                self.ctx.font = self.style.rowHeaderCellFont;\n                return self.ctx.measureText((self.data.length + (self.attributes.showNewRow ? 1 : 0)).toString()).width\n                    + self.style.autosizePadding + self.style.autosizeHeaderCellPadding\n                    + self.style.rowHeaderCellPaddingRight\n                    + self.style.rowHeaderCellPaddingLeft\n                    + (self.attributes.tree ? self.style.treeArrowWidth\n                        + self.style.treeArrowMarginLeft + self.style.treeArrowMarginRight : 0);\n            }\n            self.getSchema().forEach(function (col) {\n                if (col.name !== name) { return; }\n                self.ctx.font = self.style.headerCellFont;\n                var t = self.ctx.measureText(col.title || col.name).width\n                    + self.style.headerCellPaddingRight\n                    + self.style.headerCellPaddingLeft;\n                m = t > m ? t : m;\n            });\n            self.data.forEach(function (row) {\n                self.ctx.font = self.style.cellFont;\n                var t = self.ctx.measureText(row[name]).width\n                    + self.style.cellPaddingRight\n                    + self.style.cellPaddingLeft + self.style.cellAutoResizePadding;\n                m = t > m ? t : m;\n            });\n            return m;\n        };\n        /**\n         * Gets the total width of all header columns.\n         * @memberof canvasDataGrid#\n         * @method\n         */\n        self.getHeaderWidth = function () {\n            return self.getVisibleSchema().reduce(function (total, header) {\n                return total + header.width;\n            }, 0);\n        };\n        self.formatters.string = function cellFormatterString(ctx, cell) {\n            return cell.value !== undefined ? cell.value : '';\n        };\n        self.formatters.rowHeaderCell = self.formatters.string;\n        self.formatters.headerCell = self.formatters.string;\n        self.formatters.number = self.formatters.string;\n        self.formatters.int = self.formatters.string;\n        self.sorters.string = function (columnName, direction) {\n            var asc = direction === 'asc';\n            return function (a, b) {\n                if (a[columnName] === undefined || a[columnName] === null) {\n                    return 1;\n                }\n                if (b[columnName] === undefined || b[columnName] === null) {\n                    return 0;\n                }\n                if (asc) {\n                    if (!a[columnName].localeCompare) { return 1; }\n                    return a[columnName].localeCompare(b[columnName]);\n                }\n                if (!b[columnName].localeCompare) { return 1; }\n                return b[columnName].localeCompare(a[columnName]);\n            };\n        };\n        self.sorters.number = function (columnName, direction) {\n            var asc = direction === 'asc';\n            return function (a, b) {\n                if (asc) {\n                    return a[columnName] - b[columnName];\n                }\n                return b[columnName] - a[columnName];\n            };\n        };\n        self.sorters.date = function (columnName, direction) {\n            var asc = direction === 'asc';\n            return function (a, b) {\n                if (asc) {\n                    return new Date(a[columnName]).getTime()\n                        - new Date(b[columnName]).getTime();\n                }\n                return new Date(b[columnName]).getTime()\n                        - new Date(a[columnName]).getTime();\n            };\n        };\n    };\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi9wdWJsaWNNZXRob2RzLmpzPzg3OTMiXSwic291cmNlc0NvbnRlbnQiOlsiLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgdW5wYXJhbTogdHJ1ZSwgdG9kbzogdHJ1ZSovXG4vKmdsb2JhbHMgZGVmaW5lOiB0cnVlLCBNdXRhdGlvbk9ic2VydmVyOiBmYWxzZSwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lOiBmYWxzZSwgcGVyZm9ybWFuY2U6IGZhbHNlLCBidG9hOiBmYWxzZSovXG5kZWZpbmUoW10sIGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzZWxmKSB7XG4gICAgICAgIC8vIGFsbCBtZXRob2RzIGhlcmUgYXJlIGV4cG9zZWQgYnkgaW50ZlxuICAgICAgICAvLyB0byB1c2Vyc1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5zZXJ0cyBhIG5ldyBjb2x1bW4gYmVmb3JlIHRoZSBzcGVjaWZpZWQgaW5kZXggaW50byB0aGUgc2NoZW1hLlxuICAgICAgICAgKiBAc2VlIGNhbnZhc0RhdGFHcmlkI3NjaGVtYVxuICAgICAgICAgKiBAdHV0b3JpYWwgc2NoZW1hXG4gICAgICAgICAqIEBtZW1iZXJvZiBjYW52YXNEYXRhR3JpZCNcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAcGFyYW0ge2NvbHVtbn0gcm93SW5kZXggVGhlIGNvbHVtbiB0byBpbnNlcnQgaW50byB0aGUgc2NoZW1hLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSByb3cgdG8gaW5zZXJ0IGJlZm9yZS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuaW5zZXJ0Q29sdW1uID0gZnVuY3Rpb24gKGMsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgcyA9IHNlbGYuZ2V0U2NoZW1hKCk7XG4gICAgICAgICAgICBpZiAocy5sZW5ndGggPCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5kZXggaXMgYmV5b25kIHRoZSBsZW5ndGggb2YgdGhlIHNjaGVtYS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYudmFsaWRhdGVDb2x1bW4oYywgcyk7XG4gICAgICAgICAgICBzZWxmLmludGYuc2NoZW1hID0gcy5zcGxpY2UoaW5kZXgsIDAsIGMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVsZXRlcyBhIGNvbHVtbiBmcm9tIHRoZSBzY2hlbWEgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICAgICAgICogQG1lbWJlcm9mIGNhbnZhc0RhdGFHcmlkI1xuICAgICAgICAgKiBAdHV0b3JpYWwgc2NoZW1hXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgY29sdW1uIHRvIGRlbGV0ZS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZGVsZXRlQ29sdW1uID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgcyA9IHNlbGYuZ2V0U2NoZW1hKCk7XG4gICAgICAgICAgICBzZWxmLmludGYuc2NoZW1hID0gcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhIG5ldyBjb2x1bW4gaW50byB0aGUgc2NoZW1hLlxuICAgICAgICAgKiBAc2VlIGNhbnZhc0RhdGFHcmlkI3NjaGVtYVxuICAgICAgICAgKiBAdHV0b3JpYWwgc2NoZW1hXG4gICAgICAgICAqIEBtZW1iZXJvZiBjYW52YXNEYXRhR3JpZCNcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAcGFyYW0ge2NvbHVtbn0gYyBUaGUgY29sdW1uIHRvIGFkZCB0byB0aGUgc2NoZW1hLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5hZGRDb2x1bW4gPSBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgdmFyIHMgPSBzZWxmLmdldFNjaGVtYSgpO1xuICAgICAgICAgICAgc2VsZi52YWxpZGF0ZUNvbHVtbihjLCBzKTtcbiAgICAgICAgICAgIHMucHVzaChjKTtcbiAgICAgICAgICAgIHNlbGYuaW50Zi5zY2hlbWEgPSBzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVsZXRlcyBhIHJvdyBmcm9tIHRoZSBkYXRhc2V0IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAgICAgICAqIEBtZW1iZXJvZiBjYW52YXNEYXRhR3JpZCNcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSByb3cgdG8gZGVsZXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5kZWxldGVSb3cgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIHNlbGYub3JpZ2luYWxEYXRhLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICBzZWxmLnNldEZpbHRlcigpO1xuICAgICAgICAgICAgc2VsZi5yZXNpemUodHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnNlcnRzIGEgbmV3IHJvdyBpbnRvIHRoZSBkYXRhc2V0IGJlZm9yZSB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgICAgICAgKiBAbWVtYmVyb2YgY2FudmFzRGF0YUdyaWQjXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGQgZGF0YS5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgcm93IHRvIGluc2VydCBiZWZvcmUuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmluc2VydFJvdyA9IGZ1bmN0aW9uIChkLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKHNlbGYub3JpZ2luYWxEYXRhLmxlbmd0aCA8IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmRleCBpcyBiZXlvbmQgdGhlIGxlbmd0aCBvZiB0aGUgZGF0YXNldC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYub3JpZ2luYWxEYXRhLnNwbGljZShpbmRleCwgMCwgZCk7XG4gICAgICAgICAgICBzZWxmLnNldEZpbHRlcigpO1xuICAgICAgICAgICAgc2VsZi5yZXNpemUodHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGEgbmV3IHJvdyBpbnRvIHRoZSBkYXRhc2V0LlxuICAgICAgICAgKiBAbWVtYmVyb2YgY2FudmFzRGF0YUdyaWQjXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGQgZGF0YS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuYWRkUm93ID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHNlbGYub3JpZ2luYWxEYXRhLnB1c2goZCk7XG4gICAgICAgICAgICBzZWxmLnNldEZpbHRlcigpO1xuICAgICAgICAgICAgc2VsZi5yZXNpemUodHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBoZWlnaHQgb2YgYSBnaXZlbiByb3cgYnkgaW5kZXggbnVtYmVyLlxuICAgICAgICAgKiBAbWVtYmVyb2YgY2FudmFzRGF0YUdyaWQjXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0luZGV4IFRoZSBpbmRleCBvZiB0aGUgcm93IHRvIHNldC5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBIZWlnaHQgdG8gc2V0IHRoZSByb3cgdG8uXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLnNldFJvd0hlaWdodCA9IGZ1bmN0aW9uIChyb3dJbmRleCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICBzZWxmLnNpemVzLnJvd3Nbc2VsZi5kYXRhW3Jvd0luZGV4XVtzZWxmLnVuaXF1ZUlkXV0gPSBoZWlnaHQ7XG4gICAgICAgICAgICBzZWxmLmRyYXcodHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSB3aWR0aCBvZiBhIGdpdmVuIGNvbHVtbiBieSBpbmRleCBudW1iZXIuXG4gICAgICAgICAqIEBtZW1iZXJvZiBjYW52YXNEYXRhR3JpZCNcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sSW5kZXggVGhlIGluZGV4IG9mIHRoZSBjb2x1bW4gdG8gc2V0LlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggV2lkdGggdG8gc2V0IHRoZSBjb2x1bW4gdG8uXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLnNldENvbHVtbldpZHRoID0gZnVuY3Rpb24gKGNvbEluZGV4LCB3aWR0aCkge1xuICAgICAgICAgICAgdmFyIHMgPSBzZWxmLmdldFNjaGVtYSgpO1xuICAgICAgICAgICAgc2VsZi5zaXplcy5jb2x1bW5zW3NbY29sSW5kZXhdW3NlbGYudW5pcXVlSWRdXSA9IHdpZHRoO1xuICAgICAgICAgICAgc2VsZi5kcmF3KHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhbnkgY2hhbmdlcyB0byB0aGUgd2lkdGggb2YgdGhlIGNvbHVtbnMgZHVlIHRvIHVzZXIgb3IgYXBpIGludGVyYWN0aW9uLCBzZXR0aW5nIHRoZW0gYmFjayB0byB0aGUgc2NoZW1hIG9yIHN0eWxlIGRlZmF1bHQuXG4gICAgICAgICAqIEBtZW1iZXJvZiBjYW52YXNEYXRhR3JpZCNcbiAgICAgICAgICogQHR1dG9yaWFsIHNjaGVtYVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLnJlc2V0Q29sdW1uV2lkdGhzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi5zaXplcy5jb2x1bW5zID0ge307XG4gICAgICAgICAgICBzZWxmLmRyYXcodHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGFueSBjaGFuZ2VzIHRvIHRoZSBoZWlnaHQgb2YgdGhlIHJvd3MgZHVlIHRvIHVzZXIgb3IgYXBpIGludGVyYWN0aW9uLCBzZXR0aW5nIHRoZW0gYmFjayB0byB0aGUgc2NoZW1hIG9yIHN0eWxlIGRlZmF1bHQuXG4gICAgICAgICAqIEBtZW1iZXJvZiBjYW52YXNEYXRhR3JpZCNcbiAgICAgICAgICogQHR1dG9yaWFsIHNjaGVtYVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLnJlc2V0Um93SGVpZ2h0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYuc2l6ZXMucm93cyA9IHt9O1xuICAgICAgICAgICAgc2VsZi5kcmF3KHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIGZpbHRlci5cbiAgICAgICAgICogQG1lbWJlcm9mIGNhbnZhc0RhdGFHcmlkI1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2x1bW4gTmFtZSBvZiB0aGUgY29sdW1uIHRvIGZpbHRlci5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSB0byBmaWx0ZXIgZm9yLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5zZXRGaWx0ZXIgPSBmdW5jdGlvbiAoY29sdW1uLCB2YWx1ZSkge1xuICAgICAgICAgICAgZnVuY3Rpb24gYXBwbHlGaWx0ZXIoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5yZWZyZXNoRnJvbU9yaWdpYWxEYXRhKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc2VsZi5jb2x1bW5GaWx0ZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhlYWRlciA9IHNlbGYuZ2V0SGVhZGVyQnlOYW1lKGNvbHVtbik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50RmlsdGVyID0gaGVhZGVyLmZpbHRlcjtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kYXRhID0gc2VsZi5kYXRhLmZpbHRlcihmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jdXJyZW50RmlsdGVyKHJvd1tmaWx0ZXJdLCBzZWxmLmNvbHVtbkZpbHRlcnNbZmlsdGVyXSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNlbGYucmVzaXplKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5kcmF3KHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuY291bHVtbiA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwbHlGaWx0ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2x1bW4gJiYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzZWxmLmNvbHVtbkZpbHRlcnNbY29sdW1uXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb2x1bW5GaWx0ZXJzW2NvbHVtbl0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFwcGx5RmlsdGVyKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgcGl4ZWxzIHRvIHNjcm9sbCBkb3duIHRvIGxpbmUgdXAgd2l0aCByb3cgcm93SW5kZXguXG4gICAgICAgICAqIEBtZW1iZXJvZiBjYW52YXNEYXRhR3JpZCNcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggVGhlIHJvdyBpbmRleCBvZiB0aGUgcm93IHRvIHNjcm9sbCBmaW5kLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5maW5kUm93U2Nyb2xsVG9wID0gZnVuY3Rpb24gKHJvd0luZGV4KSB7XG4gICAgICAgICAgICB2YXIgdG9wID0gMCwgeCA9IDAsIGwgPSBzZWxmLmRhdGEubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGNlbGxCb3JkZXIgPSBzZWxmLnN0eWxlLmNlbGxCb3JkZXJXaWR0aCAqIDI7XG4gICAgICAgICAgICBpZiAoIXNlbGYuYXR0cmlidXRlcy5zaG93TmV3Um93KSB7XG4gICAgICAgICAgICAgICAgbCAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvd0luZGV4ID4gbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1wb3NzaWJsZSByb3cgaW5kZXgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlICh4IDwgcm93SW5kZXgpIHtcbiAgICAgICAgICAgICAgICB0b3AgKz0gKHNlbGYuc2l6ZXMucm93c1tzZWxmLmRhdGFbeF1bc2VsZi51bmlxdWVJZF1dIHx8IHNlbGYuc3R5bGUuY2VsbEhlaWdodCkgKyBjZWxsQm9yZGVyO1xuICAgICAgICAgICAgICAgIHggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vVE9ETzogVGhpcyBpcyBub3Qgc3VwZXIgYWNjdXJhdGUsIGNhdXNlcyBwYWdlVXAvRG4gdG8gbm90IG1vdmUgYXJvdW5kIHJpZ2h0XG4gICAgICAgICAgICByZXR1cm4gdG9wIC0gKHNlbGYuc2l6ZXMucm93c1tzZWxmLmRhdGFbcm93SW5kZXhdW3NlbGYudW5pcXVlSWRdXSB8fCBzZWxmLnN0eWxlLmNlbGxIZWlnaHQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHBpeGVscyB0byBzY3JvbGwgdG8gdGhlIGxlZnQgdG8gbGluZSB1cCB3aXRoIGNvbHVtbiBjb2x1bW5JbmRleC5cbiAgICAgICAgICogQG1lbWJlcm9mIGNhbnZhc0RhdGFHcmlkI1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleCBUaGUgY29sdW1uIGluZGV4IG9mIHRoZSBjb2x1bW4gdG8gZmluZC5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZmluZENvbHVtblNjcm9sbExlZnQgPSBmdW5jdGlvbiAoY29sdW1uSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gMCwgeSA9IDAsIHMgPSBzZWxmLmdldFNjaGVtYSgpLCBsID0gcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKGNvbHVtbkluZGV4ID4gbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1wb3NzaWJsZSBjb2x1bW4gaW5kZXgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlICh5IDwgY29sdW1uSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBsZWZ0ICs9IHNlbGYuc2l6ZXMuY29sdW1uc1tzW3ldW3NlbGYudW5pcXVlSWRdXSB8fCBzW3ldLndpZHRoO1xuICAgICAgICAgICAgICAgIHkgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsZWZ0O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2Nyb2xscyB0aGUgY2VsbCBhdCBjZWxsIHgsIHJvdyB5LlxuICAgICAgICAgKiBAbWVtYmVyb2YgY2FudmFzRGF0YUdyaWQjXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIGNvbHVtbiBpbmRleCBvZiB0aGUgY2VsbCB0byBzY3JvbGwgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IFRoZSByb3cgaW5kZXggb2YgdGhlIGNlbGwgdG8gc2Nyb2xsIHRvLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nb3RvQ2VsbCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICBpZiAoeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxCb3guc2Nyb2xsTGVmdCA9IHNlbGYuZmluZENvbHVtblNjcm9sbExlZnQoeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxCb3guc2Nyb2xsVG9wID0gc2VsZi5maW5kUm93U2Nyb2xsVG9wKHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2Nyb2xscyB0aGUgcm93IHkuXG4gICAgICAgICAqIEBtZW1iZXJvZiBjYW52YXNEYXRhR3JpZCNcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0geSBUaGUgcm93IGluZGV4IG9mIHRoZSBjZWxsIHRvIHNjcm9sbCB0by5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ290b1JvdyA9IGZ1bmN0aW9uICh5KSB7XG4gICAgICAgICAgICBzZWxmLmdvdG9DZWxsKDAsIHkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2Nyb2xscyB0aGUgY2VsbCBhdCBjZWxsIHgsIHJvdyB5IGludG8gdmlldyBpZiBpdCBpcyBub3QgYWxyZWFkeS5cbiAgICAgICAgICogQG1lbWJlcm9mIGNhbnZhc0RhdGFHcmlkI1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IFRoZSBjb2x1bW4gaW5kZXggb2YgdGhlIGNlbGwgdG8gc2Nyb2xsIGludG8gdmlldy5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGhlIHJvdyBpbmRleCBvZiB0aGUgY2VsbCB0byBzY3JvbGwgaW50byB2aWV3LlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5zY3JvbGxJbnRvVmlldyA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICBpZiAoc2VsZi52aXNpYmxlQ2VsbHMuZmlsdGVyKGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoY2VsbC5yb3dJbmRleCA9PT0geSB8fCB5ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiAoY2VsbC5jb2x1bW5JbmRleCA9PT0geCB8fCB4ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBjZWxsLnggPiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBjZWxsLnkgPiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBjZWxsLnggKyBjZWxsLndpZHRoIDwgc2VsZi53aWR0aFxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgY2VsbC55ICsgY2VsbC5oZWlnaHQgPCBzZWxmLmhlaWdodDtcbiAgICAgICAgICAgICAgICB9KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBzZWxmLmdvdG9DZWxsKHgsIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgYWN0aXZlIGNlbGwuIFJlcXVpcmVzIHJlZHJhd2luZy5cbiAgICAgICAgICogQG1lbWJlcm9mIGNhbnZhc0RhdGFHcmlkI1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IFRoZSBjb2x1bW4gaW5kZXggb2YgdGhlIGNlbGwgdG8gc2V0IGFjdGl2ZS5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGhlIHJvdyBpbmRleCBvZiB0aGUgY2VsbCB0byBzZXQgYWN0aXZlLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5zZXRBY3RpdmVDZWxsID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHNlbGYuYWN0aXZlQ2VsbCA9IHtcbiAgICAgICAgICAgICAgICByb3dJbmRleDogeSxcbiAgICAgICAgICAgICAgICBjb2x1bW5JbmRleDogeFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlbGVjdHMgYSByb3cuXG4gICAgICAgICAqIEBtZW1iZXJvZiBjYW52YXNEYXRhR3JpZCNcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHRvZ2dsZVNlbGVjdE1vZGUgV2hlbiB0cnVlLCBiZWhhdmVzIGFzIGlmIHlvdSB3ZXJlIGhvbGRpbmcgY29udHJvbC9jb21tYW5kIHdoZW4geW91IGNsaWNrZWQgdGhlIHJvdy5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBzdXByZXNzU2VsZWN0aW9uY2hhbmdlZEV2ZW50IFdoZW4gdHJ1ZSwgcHJldmVudHMgdGhlIHNlbGVjdGlvbmNoYW5nZWQgZXZlbnQgZnJvbSBmaXJpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLnNlbGVjdFJvdyA9IGZ1bmN0aW9uIChyb3dJbmRleCwgY3RybCwgc3VwcmVzc0V2ZW50KSB7XG4gICAgICAgICAgICB2YXIgcyA9IHNlbGYuZ2V0U2NoZW1hKCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5kcmFnQWRkVG9TZWxlY3Rpb24gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuc2VsZWN0aW9uc1tyb3dJbmRleF0gJiYgc2VsZi5zZWxlY3Rpb25zW3Jvd0luZGV4XS5sZW5ndGggLSAxID09PSBzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3RybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxlY3Rpb25zW3Jvd0luZGV4XSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuZHJhZ0FkZFRvU2VsZWN0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zZWxlY3Rpb25zW3Jvd0luZGV4XSA9IFtdO1xuICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0aW9uc1tyb3dJbmRleF0ucHVzaCgtMSk7XG4gICAgICAgICAgICAgICAgcy5mb3JFYWNoKGZ1bmN0aW9uIChjb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxlY3Rpb25zW3Jvd0luZGV4XS5wdXNoKGNvbC5pbmRleCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3VwcmVzc0V2ZW50KSB7IHJldHVybjsgfVxuICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdzZWxlY3Rpb25jaGFuZ2VkJywgW3NlbGYuZ2V0U2VsZWN0ZWREYXRhKCksIHNlbGYuc2VsZWN0aW9ucywgc2VsZi5zZWxlY3Rpb25Cb3VuZHNdLCBzZWxmLmludGYpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sbGFwc2UgYSB0cmVlIGdyaWQgYnkgcm93IGluZGV4LlxuICAgICAgICAgKiBAbWVtYmVyb2YgY2FudmFzRGF0YUdyaWQjXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgcm93IHRvIGNvbGxhcHNlLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5jb2xsYXBzZVRyZWUgPSBmdW5jdGlvbiAocm93SW5kZXgpIHtcbiAgICAgICAgICAgIHZhciByb3dJZCA9IHNlbGYuZGF0YVtyb3dJbmRleF1bc2VsZi51bmlxdWVJZF07XG4gICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2NvbGxhcHNldHJlZScsIFtzZWxmLmNoaWxkR3JpZHNbcm93SWRdLCBzZWxmLmRhdGFbcm93SW5kZXhdLCByb3dJbmRleF0sIHNlbGYuaW50Zik7XG4gICAgICAgICAgICBzZWxmLm9wZW5DaGlsZHJlbltyb3dJZF0uYmx1cigpO1xuICAgICAgICAgICAgc2VsZi5vcGVuQ2hpbGRyZW5bcm93SWRdLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIGRlbGV0ZSBzZWxmLm9wZW5DaGlsZHJlbltyb3dJZF07XG4gICAgICAgICAgICBkZWxldGUgc2VsZi5zaXplcy50cmVlc1tyb3dJZF07XG4gICAgICAgICAgICBkZWxldGUgc2VsZi5jaGlsZEdyaWRzW3Jvd0lkXTtcbiAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgncmVzaXplcm93JywgW3NlbGYuc3R5bGUuY2VsbEhlaWdodF0sIHNlbGYuaW50Zik7XG4gICAgICAgICAgICBzZWxmLnJlc2l6ZSh0cnVlKTtcbiAgICAgICAgICAgIHNlbGYuZHJhdyh0cnVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4cGFuZHMgYSB0cmVlIGdyaWQgYnkgcm93IGluZGV4LlxuICAgICAgICAgKiBAbWVtYmVyb2YgY2FudmFzRGF0YUdyaWQjXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgcm93IHRvIGV4cGFuZC5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZXhwYW5kVHJlZSA9IGZ1bmN0aW9uIChyb3dJbmRleCkge1xuICAgICAgICAgICAgdmFyIGhlYWRlckNlbGxIZWlnaHQgPSBzZWxmLmdldEhlYWRlckNlbGxIZWlnaHQoKSxcbiAgICAgICAgICAgICAgICBoZWFkZXJDZWxsV2lkdGggPSBzZWxmLnNpemVzLmNvbHVtbnMuY29ybmVyQ2VsbCB8fCBzZWxmLnN0eWxlLmhlYWRlclJvd1dpZHRoLFxuICAgICAgICAgICAgICAgIHJvd0lkID0gc2VsZi5kYXRhW3Jvd0luZGV4XVtzZWxmLnVuaXF1ZUlkXSxcbiAgICAgICAgICAgICAgICBoID0gc2VsZi5zaXplcy50cmVlc1tyb3dJZF0gfHwgc2VsZi5zdHlsZS50cmVlR3JpZEhlaWdodCxcbiAgICAgICAgICAgICAgICB0cmVlR3JpZDtcbiAgICAgICAgICAgIGlmICghc2VsZi5jaGlsZEdyaWRzW3Jvd0lkXSkge1xuICAgICAgICAgICAgICAgIHRyZWVHcmlkID0gZ3JpZCh7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnOiBzZWxmLmF0dHJpYnV0ZXMuZGVidWcsXG4gICAgICAgICAgICAgICAgICAgIHNob3dQZXJmb3JtYW5jZTogc2VsZi5hdHRyaWJ1dGVzLnNob3dQZXJmb3JtYW5jZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogc2VsZi5hdHRyaWJ1dGVzLnNhdmVBcHBlYXJhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGYuYXR0cmlidXRlcy5uYW1lICsgJ3RyZWUnICsgcm93SWQgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEdyaWQ6IHNlbGYuaW50ZixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVUeXBlOiAnY2FudmFzLWRhdGFncmlkLXRyZWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0SGVpZ2h0OiBoLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0V2lkdGg6IHNlbGYud2lkdGggLSBoZWFkZXJDZWxsV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXI6IHsgd2lkdGg6IHNlbGYud2lkdGggLSBoZWFkZXJDZWxsV2lkdGggfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldExlZnQ6IGhlYWRlckNlbGxXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldFRvcDogaGVhZGVyQ2VsbEhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldFBhcmVudDogc2VsZi5pbnRmLnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlOiBzZWxmLmludGYucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAndHJlZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBzZWxmLmRhdGFbcm93SW5kZXhdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzZWxmLmNoaWxkR3JpZHNbcm93SWRdID0gdHJlZUdyaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmVlR3JpZCA9IHNlbGYuY2hpbGRHcmlkc1tyb3dJZF07XG4gICAgICAgICAgICB0cmVlR3JpZC52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZXhwYW5kdHJlZScsIFt0cmVlR3JpZCwgc2VsZi5kYXRhW3Jvd0luZGV4XSwgcm93SW5kZXhdLCBzZWxmLmludGYpO1xuICAgICAgICAgICAgc2VsZi5vcGVuQ2hpbGRyZW5bc2VsZi5kYXRhW3Jvd0luZGV4XVtzZWxmLnVuaXF1ZUlkXV0gPSB0cmVlR3JpZDtcbiAgICAgICAgICAgIHNlbGYuc2l6ZXMudHJlZXNbc2VsZi5kYXRhW3Jvd0luZGV4XVtzZWxmLnVuaXF1ZUlkXV0gPSBoO1xuICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdyZXNpemVyb3cnLCBbc2VsZi5zdHlsZS5jZWxsSGVpZ2h0XSwgc2VsZi5pbnRmKTtcbiAgICAgICAgICAgIHNlbGYucmVzaXplKHRydWUpO1xuICAgICAgICAgICAgc2VsZi5kcmF3KCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb2dnbGVzIHRyZWUgZ3JpZCBvcGVuIGFuZCBjbG9zZSBieSByb3cgaW5kZXguXG4gICAgICAgICAqIEBtZW1iZXJvZiBjYW52YXNEYXRhR3JpZCNcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSByb3cgdG8gdG9nZ2xlLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi50b2dnbGVUcmVlID0gZnVuY3Rpb24gKHJvd0luZGV4KSB7XG4gICAgICAgICAgICB2YXIgaSA9IHNlbGYub3BlbkNoaWxkcmVuW3NlbGYuZGF0YVtyb3dJbmRleF1bc2VsZi51bmlxdWVJZF1dO1xuICAgICAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jb2xsYXBzZVRyZWUocm93SW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5leHBhbmRUcmVlKHJvd0luZGV4KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBoZWFkZXIgZnJvbSB0aGUgc2NoZW1hIGJ5IG5hbWUuXG4gICAgICAgICAqIEBtZW1iZXJvZiBjYW52YXNEYXRhR3JpZCNcbiAgICAgICAgICogQHR1dG9yaWFsIHNjaGVtYVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEByZXR1cm5zIHtoZWFkZXJ9IGhlYWRlciB3aXRoIHRoZSBzZWxlY3RlZCBuYW1lLCBvciB1bmRlZmluZWQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBjb2x1bW4gdG8gcmVzaXplLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRIZWFkZXJCeU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIHgsIGkgPSBzZWxmLmdldFNjaGVtYSgpO1xuICAgICAgICAgICAgZm9yICh4ID0gMDsgeCA8IGkubGVuZ3RoOyB4ICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaVt4XS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpW3hdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2l6ZXMgYSBjb2x1bW4gdG8gZml0IHRoZSBsb25nZXN0IHZhbHVlIGluIHRoZSBjb2x1bW4uIENhbGwgd2l0aG91dCBhIHZhbHVlIHRvIHJlc2l6ZSBhbGwgY29sdW1ucy5cbiAgICAgICAgICogV2FybmluZywgY2FuIGJlIHNsb3cgb24gdmVyeSBsYXJnZSByZWNvcmQgc2V0cyAoMW0gcmVjb3JkcyB+My01IHNlY29uZHMgb24gYW4gaTcpLlxuICAgICAgICAgKiBAbWVtYmVyb2YgY2FudmFzRGF0YUdyaWQjXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGNvbHVtbiB0byByZXNpemUuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmZpdENvbHVtblRvVmFsdWVzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHNlbGYuc2l6ZXMuY29sdW1uc1tuYW1lID09PSAnY29ybmVyQ2VsbCcgPyBuYW1lIDogc2VsZi5nZXRIZWFkZXJCeU5hbWUobmFtZSlbc2VsZi51bmlxdWVJZF1dXG4gICAgICAgICAgICAgICAgPSBzZWxmLmZpbmRDb2x1bW5NYXhUZXh0TGVuZ3RoKG5hbWUpO1xuICAgICAgICAgICAgc2VsZi5yZXNpemUoKTtcbiAgICAgICAgICAgIHNlbGYuZHJhdyh0cnVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyBpZiBhIGNlbGwgaXMgY3VycmVudGx5IHZpc2libGUuXG4gICAgICAgICAqIEBtZW1iZXJvZiBjYW52YXNEYXRhR3JpZCNcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hlbiB0cnVlLCB0aGUgY2VsbCBpcyB2aXNpYmxlLCB3aGVuIGZhbHNlIHRoZSBjZWxsIGlzIG5vdCBjdXJyZW50bHkgZHJhd24uXG4gICAgICAgICAqIEBwYXJhbSB7Y2VsbH0gY2VsbCBUaGUgY2VsbCB0byBjaGVjayBmb3IuICBBbHRlcm5hdGl2ZWx5IHlvdSBjYW4gcGFzcyBhbiBvYmplY3QgeyB4OiA8eC1pbmRleD4sIHk6IDx5LWluZGV4PiB9LlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5pc0NlbGxWaXNpYmxlID0gZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgICAgICAgIHZhciB4LCBsID0gc2VsZi52aXNpYmxlQ2VsbHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh4ID0gMDsgeCA8IGw7IHggKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChjZWxsLnggPT09IHNlbGYudmlzaWJsZUNlbGxzW3hdLnggJiYgY2VsbC55ID09PSBzZWxmLnZpc2libGVDZWxsc1t4XS55KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIG9yZGVyIG9mIHRoZSBkYXRhLlxuICAgICAgICAgKiBAbWVtYmVyb2YgY2FudmFzRGF0YUdyaWQjXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQHJldHVybnMge2NlbGx9IGNlbGwgYXQgdGhlIHNlbGVjdGVkIGxvY2F0aW9uLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uTmFtZSBOdW1iZXIgb2YgcGl4ZWxzIGZyb20gdGhlIGxlZnQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkaXJlY3Rpb24gYGFzY2AgZm9yIGFzY2VuZGluZyBvciBgZGVzY2AgZm9yIGRlc2NlbmRpbmcuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbH0gZG9udFNldFN0b3JhZ2VEYXRhIERvbid0IHN0b3JlIHRoaXMgc2V0dGluZyBmb3IgZnV0dXJlIHVzZS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYub3JkZXIgPSBmdW5jdGlvbiAoY29sdW1uTmFtZSwgZGlyZWN0aW9uLCBkb250U2V0U3RvcmFnZURhdGEpIHtcbiAgICAgICAgICAgIHZhciBmLFxuICAgICAgICAgICAgICAgIGMgPSBzZWxmLmdldFNjaGVtYSgpLmZpbHRlcihmdW5jdGlvbiAoY29sKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2wubmFtZSA9PT0gY29sdW1uTmFtZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGYub3JkZXJCeSA9IGNvbHVtbk5hbWU7XG4gICAgICAgICAgICBpZiAoYy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzb3J0LiAgTm8gc3VjaCBjb2x1bW4gbmFtZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZiA9IHNlbGYuc29ydGVyc1tjWzBdLnR5cGVdO1xuICAgICAgICAgICAgaWYgKCFmICYmIGNbMF0udHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdDYW5ub3Qgc29ydCB0eXBlIFwiJXNcIiBmYWxsaW5nIGJhY2sgdG8gc3RyaW5nIHNvcnQuJywgY1swXS50eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuZGF0YSA9IHNlbGYuZGF0YS5zb3J0KHR5cGVvZiBmID09PSAnZnVuY3Rpb24nID8gZihjb2x1bW5OYW1lLCBkaXJlY3Rpb24pIDogc2VsZi5zb3J0ZXJzLnN0cmluZyk7XG4gICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ29yZGVyY29sdW1uJywgW2NvbHVtbk5hbWUsIGRpcmVjdGlvbl0sIHNlbGYuaW50Zik7XG4gICAgICAgICAgICBzZWxmLmRyYXcodHJ1ZSk7XG4gICAgICAgICAgICBpZiAoZG9udFNldFN0b3JhZ2VEYXRhKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgc2VsZi5zZXRTdG9yYWdlRGF0YSgpO1xuICAgICAgICB9O1xuICAgICAgICBzZWxmLmlzSW5HcmlkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChlLnggPCAwXG4gICAgICAgICAgICAgICAgICAgIHx8IGUueCA+IHNlbGYud2lkdGhcbiAgICAgICAgICAgICAgICAgICAgfHwgZS55IDwgMFxuICAgICAgICAgICAgICAgICAgICB8fCBlLnkgPiBzZWxmLmhlaWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgY2VsbCBhdCBncmlkIHBpeGVsIGNvb3JkaW5hdGUgeCBhbmQgeS5cbiAgICAgICAgICogQG1lbWJlcm9mIGNhbnZhc0RhdGFHcmlkI1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEByZXR1cm5zIHtjZWxsfSBjZWxsIGF0IHRoZSBzZWxlY3RlZCBsb2NhdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHggTnVtYmVyIG9mIHBpeGVscyBmcm9tIHRoZSBsZWZ0LlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0geSBOdW1iZXIgb2YgcGl4ZWxzIGZyb20gdGhlIHRvcC5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0Q2VsbEF0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBpLCBsID0gc2VsZi52aXNpYmxlQ2VsbHMubGVuZ3RoLCBjZWxsO1xuICAgICAgICAgICAgaWYgKCFzZWxmLnZpc2libGVDZWxscyB8fCAhc2VsZi52aXNpYmxlQ2VsbHMubGVuZ3RoKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgc2VsZi5oYXNGb2N1cyA9IHRydWU7XG4gICAgICAgICAgICBpZiAoISh5IDwgc2VsZi5oZWlnaHRcbiAgICAgICAgICAgICAgICAmJiB5ID4gMFxuICAgICAgICAgICAgICAgICYmIHggPCBzZWxmLndpZHRoXG4gICAgICAgICAgICAgICAgJiYgeCA+IDApKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5oYXNGb2N1cyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdDb250ZXh0OiAnaW5oZXJpdCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6ICdpbmhlcml0J1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY2VsbCA9IHNlbGYudmlzaWJsZUNlbGxzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjZWxsLnggLSBzZWxmLnN0eWxlLmNlbGxCb3JkZXJXaWR0aCA8IHhcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIGNlbGwueCArIGNlbGwud2lkdGggKyBzZWxmLnN0eWxlLmNlbGxCb3JkZXJXaWR0aCA+IHhcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIGNlbGwueSAtIHNlbGYuc3R5bGUuY2VsbEJvcmRlcldpZHRoIDwgeVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgY2VsbC55ICsgY2VsbC5oZWlnaHQgKyBzZWxmLnN0eWxlLmNlbGxCb3JkZXJXaWR0aCA+IHkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKC92ZXJ0aWNhbC1zY3JvbGwtKGJhcnxib3gpLy50ZXN0KGNlbGwuc3R5bGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsLmRyYWdDb250ZXh0ID0gJ3ZlcnRpY2FsLXNjcm9sbC1ib3gnO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5jb250ZXh0ID0gJ3ZlcnRpY2FsLXNjcm9sbC1ib3gnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHkgPiBzZWxmLnNjcm9sbEJveC5ib3gudi55ICsgc2VsZi5zY3JvbGxCb3guc2Nyb2xsQm94SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5kcmFnQ29udGV4dCA9ICd2ZXJ0aWNhbC1zY3JvbGwtYm90dG9tJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLmNvbnRleHQgPSAndmVydGljYWwtc2Nyb2xsLWJvdHRvbSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHkgPCBzZWxmLnNjcm9sbEJveC5ib3gudi55KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5kcmFnQ29udGV4dCA9ICd2ZXJ0aWNhbC1zY3JvbGwtdG9wJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLmNvbnRleHQgPSAndmVydGljYWwtc2Nyb2xsLXRvcCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNhbnZhcy5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2VsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoL2hvcml6b250YWwtc2Nyb2xsLShiYXJ8Ym94KS8udGVzdChjZWxsLnN0eWxlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5kcmFnQ29udGV4dCA9ICdob3Jpem9udGFsLXNjcm9sbC1ib3gnO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5jb250ZXh0ID0gJ2hvcml6b250YWwtc2Nyb2xsLWJveCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeCA+IHNlbGYuc2Nyb2xsQm94LmJveC5oLnggKyBzZWxmLnNjcm9sbEJveC5zY3JvbGxCb3hXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuZHJhZ0NvbnRleHQgPSAnaG9yaXpvbnRhbC1zY3JvbGwtcmlnaHQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuY29udGV4dCA9ICdob3Jpem9udGFsLXNjcm9sbC1yaWdodCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHggPCBzZWxmLnNjcm9sbEJveC5ib3guaC54KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5kcmFnQ29udGV4dCA9ICdob3Jpem9udGFsLXNjcm9sbC1sZWZ0JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLmNvbnRleHQgPSAnaG9yaXpvbnRhbC1zY3JvbGwtbGVmdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNhbnZhcy5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2VsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbC54ICsgY2VsbC53aWR0aCAtIChzZWxmLmF0dHJpYnV0ZXMuYm9yZGVyUmVzaXplWm9uZSAqIDAuNCkgPCB4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgY2VsbC54ICsgY2VsbC53aWR0aCArIChzZWxmLmF0dHJpYnV0ZXMuYm9yZGVyUmVzaXplWm9uZSAqIDAuNikgPiB4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgc2VsZi5hdHRyaWJ1dGVzLmFsbG93Q29sdW1uUmVzaXplXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKChzZWxmLmF0dHJpYnV0ZXMuYWxsb3dDb2x1bW5SZXNpemVGcm9tQ2VsbCAmJiBjZWxsLnN0eWxlID09PSAnY2VsbCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGNlbGwuc3R5bGUgIT09ICdjZWxsJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoKHNlbGYuYXR0cmlidXRlcy5hbGxvd1Jvd0hlYWRlclJlc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBbJ3Jvd0hlYWRlckNlbGwnLCAnY29ybmVyQ2VsbCddLmluZGV4T2YoY2VsbC5zdHlsZSkgIT09IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBbJ3Jvd0hlYWRlckNlbGwnLCAnY29ybmVyQ2VsbCddLmluZGV4T2YoY2VsbC5zdHlsZSkgPT09IC0xKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5jb250ZXh0ID0gJ2V3LXJlc2l6ZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsLmRyYWdDb250ZXh0ID0gJ2V3LXJlc2l6ZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2VsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbC55ICsgY2VsbC5oZWlnaHQgLSAoc2VsZi5hdHRyaWJ1dGVzLmJvcmRlclJlc2l6ZVpvbmUgKiAwLjQpIDwgeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGNlbGwueSArIGNlbGwuaGVpZ2h0ICsgKHNlbGYuYXR0cmlidXRlcy5ib3JkZXJSZXNpemVab25lICogMC42KSA+IHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBzZWxmLmF0dHJpYnV0ZXMuYWxsb3dSb3dSZXNpemVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoKHNlbGYuYXR0cmlidXRlcy5hbGxvd1Jvd1Jlc2l6ZUZyb21DZWxsICYmIGNlbGwuc3R5bGUgPT09ICdjZWxsJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgY2VsbC5zdHlsZSAhPT0gJ2NlbGwnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGNlbGwuc3R5bGUgIT09ICdoZWFkZXJDZWxsJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5jb250ZXh0ID0gJ25zLXJlc2l6ZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsLmRyYWdDb250ZXh0ID0gJ25zLXJlc2l6ZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2VsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbC5zdHlsZSA9PT0gJ2hlYWRlckNlbGwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsLmNvbnRleHQgPSAnY2VsbCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsLmRyYWdDb250ZXh0ID0gJ2NvbHVtbi1yZW9yZGVyJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjZWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjZWxsLnN0eWxlID09PSAncm93SGVhZGVyQ2VsbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuY29udGV4dCA9ICdjZWxsJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuZHJhZ0NvbnRleHQgPSAncm93LXJlb3JkZXInO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNlbGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGwuaXNHcmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmhhc0ZvY3VzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsLmRyYWdDb250ZXh0ID0gJ2NlbGwtZ3JpZCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsLmNvbnRleHQgPSAnY2VsbC1ncmlkJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjZWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjZWxsLnN0eWxlID09PSAndHJlZS1ncmlkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5oYXNGb2N1cyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5kcmFnQ29udGV4dCA9ICd0cmVlJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuY29udGV4dCA9ICd0cmVlJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjZWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNlbGwuZHJhZ0NvbnRleHQgPSAnY2VsbCc7XG4gICAgICAgICAgICAgICAgICAgIGNlbGwuY29udGV4dCA9ICdjZWxsJztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNlbGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5oYXNGb2N1cyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0OiAnaW5oZXJpdCdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBib3VuZHMgb2YgY3VycmVudCBzZWxlY3Rpb24uIFxuICAgICAgICAgKiBAcmV0dXJucyB7cmVjdH0gc2VsZWN0aW9uLlxuICAgICAgICAgKiBAbWVtYmVyb2YgY2FudmFzRGF0YUdyaWQjXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0U2VsZWN0aW9uQm91bmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxvdyA9IHt4OiBJbmZpbml0eSwgeTogSW5maW5pdHl9LFxuICAgICAgICAgICAgICAgIGhpZ2ggPSB7eDogLUluZmluaXR5LCB5OiAtSW5maW5pdHl9O1xuICAgICAgICAgICAgc2VsZi5kYXRhLmZvckVhY2goZnVuY3Rpb24gKHJvdywgcm93SW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF4Q29sLCBtaW5Db2w7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuc2VsZWN0aW9uc1tyb3dJbmRleF0gJiYgc2VsZi5zZWxlY3Rpb25zW3Jvd0luZGV4XS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbG93LnkgPSByb3dJbmRleCA8IGxvdy55ID8gcm93SW5kZXggOiBsb3cueTtcbiAgICAgICAgICAgICAgICAgICAgaGlnaC55ID0gcm93SW5kZXggPiBoaWdoLnkgPyByb3dJbmRleCA6IGhpZ2gueTtcbiAgICAgICAgICAgICAgICAgICAgbWF4Q29sID0gTWF0aC5tYXguYXBwbHkobnVsbCwgc2VsZi5zZWxlY3Rpb25zW3Jvd0luZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgIG1pbkNvbCA9IE1hdGgubWluLmFwcGx5KG51bGwsIHNlbGYuc2VsZWN0aW9uc1tyb3dJbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICBsb3cueCA9IG1pbkNvbCA8IGxvdy54ID8gbWluQ29sIDogbG93Lng7XG4gICAgICAgICAgICAgICAgICAgIGhpZ2gueCA9IG1heENvbCA+IGhpZ2gueCA/IG1heENvbCA6IGhpZ2gueDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9wOiBsb3cueSxcbiAgICAgICAgICAgICAgICBsZWZ0OiBsb3cueCxcbiAgICAgICAgICAgICAgICBib3R0b206IGhpZ2gueSxcbiAgICAgICAgICAgICAgICByaWdodDogaGlnaC54XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhbiBhdXRvIGdlbmVyYXRlZCBzY2hlbWEgYmFzZWQgb24gZGF0YSBzdHJ1Y3R1cmUuXG4gICAgICAgICAqIEBtZW1iZXJvZiBjYW52YXNEYXRhR3JpZCNcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAdHV0b3JpYWwgc2NoZW1hXG4gICAgICAgICAqIEByZXR1cm5zIHtzY2hlbWF9IHNjaGVtYSBBIHNjaGVtYSBiYXNlZCBvbiB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgZGF0YSBhcnJheS5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZ2V0U2NoZW1hRnJvbURhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoc2VsZi5kYXRhWzBdIHx8IHsnICc6ICcnfSkubWFwKGZ1bmN0aW9uIG1hcEVhY2hTY2hlbWFDb2x1bW4oa2V5LCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gc2VsZi5nZXRCZXN0R3Vlc3NEYXRhVHlwZShrZXkpLFxuICAgICAgICAgICAgICAgICAgICBpID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZToga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBzZWxmLnN0eWxlLmNvbHVtbldpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcjogc2VsZi5maWx0ZXIodHlwZSlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBzZWxmLnVuaXF1ZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGkuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaVtzZWxmLnVuaXF1ZUlkXSA9IHNlbGYuZ2V0U2NoZW1hTmFtZUhhc2goa2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2xlYXJzIHRoZSBjaGFuZ2UgbG9nIGdyaWQuY2hhbmdlcyB0aGF0IGtlZXBzIHRyYWNrIG9mIGNoYW5nZXMgdG8gdGhlIGRhdGEgc2V0LlxuICAgICAgICAgKiBUaGlzIGRvZXMgbm90IHVuZG8gY2hhbmdlcyBvciBhbHRlciBkYXRhIGl0IGlzIHNpbXBseSBhIGNvbnZpbmNlIGFycmF5IHRvIGtlZXBcbiAgICAgICAgICogdHJhY2sgb2YgY2hhbmdlcyBtYWRlIHRvIHRoZSBkYXRhIHNpbmNlIGxhc3QgdGhpcyBtZXRob2Qgd2FzIGNhbGxlZC5cbiAgICAgICAgICogQG1lbWJlcm9mIGNhbnZhc0RhdGFHcmlkI1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmNsZWFyQ2hhbmdlTG9nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi5jaGFuZ2VzID0gW107XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWxlY3RzIGFuIGFyZWEgb2YgdGhlIGdyaWQuXG4gICAgICAgICAqIEBtZW1iZXJvZiBjYW52YXNEYXRhR3JpZCNcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAcGFyYW0ge3JlY3R9IGJvdW5kcyBBIHJlY3Qgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc2VsZWN0ZWQgdmFsdWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5zZWxlY3RBcmVhID0gZnVuY3Rpb24gKGJvdW5kcywgY3RybCkge1xuICAgICAgICAgICAgc2VsZi5zZWxlY3Rpb25Cb3VuZHMgPSBib3VuZHMgfHwgc2VsZi5zZWxlY3Rpb25Cb3VuZHM7XG4gICAgICAgICAgICB2YXIgeCwgeSwgcyA9IHNlbGYuZ2V0U2NoZW1hKCk7XG4gICAgICAgICAgICBpZiAoIWN0cmwpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLnNlbGVjdGlvbkJvdW5kcy50b3AgPCAtMVxuICAgICAgICAgICAgICAgICAgICB8fCBzZWxmLnNlbGVjdGlvbkJvdW5kcy5ib3R0b20gPiBzZWxmLmRhdGEubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIHx8IHNlbGYuc2VsZWN0aW9uQm91bmRzLmxlZnQgPCAtMVxuICAgICAgICAgICAgICAgICAgICB8fCBzZWxmLnNlbGVjdGlvbkJvdW5kcy5yaWdodCA+IHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbXBvc3NpYmxlIHNlbGVjdGlvbiBhcmVhJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHggPSBzZWxmLnNlbGVjdGlvbkJvdW5kcy50b3A7IHggPD0gc2VsZi5zZWxlY3Rpb25Cb3VuZHMuYm90dG9tOyB4ICs9IDEpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGlvbnNbeF0gPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHkgPSBzZWxmLnNlbGVjdGlvbkJvdW5kcy5sZWZ0OyB5IDw9IHNlbGYuc2VsZWN0aW9uQm91bmRzLnJpZ2h0OyB5ICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuc2VsZWN0aW9uc1t4XS5pbmRleE9mKHkpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxlY3Rpb25zW3hdLnB1c2goeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ3NlbGVjdGlvbmNoYW5nZWQnLCBbc2VsZi5nZXRTZWxlY3RlZERhdGEoKSwgc2VsZi5zZWxlY3Rpb25zLCBzZWxmLnNlbGVjdGlvbkJvdW5kc10sIHNlbGYuaW50Zik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIHRleHQgd2lkdGggZm9yIGEgZ2l2ZW4gY29sdW1uIGJ5IGNvbHVtbiBuYW1lLlxuICAgICAgICAgKiBAbWVtYmVyb2YgY2FudmFzRGF0YUdyaWQjXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiBwaXhlbHMgd2lkZSB0aGUgbWF4aW11bSB3aWR0aCB2YWx1ZSBpbiB0aGUgc2VsZWN0ZWQgY29sdW1uLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgY29sdW1uIHRvIGNhbGN1bGF0ZSB0aGUgdmFsdWUncyB3aWR0aCBvZi5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZmluZENvbHVtbk1heFRleHRMZW5ndGggPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIG0gPSAtSW5maW5pdHk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2Nvcm5lckNlbGwnKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jdHguZm9udCA9IHNlbGYuc3R5bGUucm93SGVhZGVyQ2VsbEZvbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY3R4Lm1lYXN1cmVUZXh0KChzZWxmLmRhdGEubGVuZ3RoICsgKHNlbGYuYXR0cmlidXRlcy5zaG93TmV3Um93ID8gMSA6IDApKS50b1N0cmluZygpKS53aWR0aFxuICAgICAgICAgICAgICAgICAgICArIHNlbGYuc3R5bGUuYXV0b3NpemVQYWRkaW5nICsgc2VsZi5zdHlsZS5hdXRvc2l6ZUhlYWRlckNlbGxQYWRkaW5nXG4gICAgICAgICAgICAgICAgICAgICsgc2VsZi5zdHlsZS5yb3dIZWFkZXJDZWxsUGFkZGluZ1JpZ2h0XG4gICAgICAgICAgICAgICAgICAgICsgc2VsZi5zdHlsZS5yb3dIZWFkZXJDZWxsUGFkZGluZ0xlZnRcbiAgICAgICAgICAgICAgICAgICAgKyAoc2VsZi5hdHRyaWJ1dGVzLnRyZWUgPyBzZWxmLnN0eWxlLnRyZWVBcnJvd1dpZHRoXG4gICAgICAgICAgICAgICAgICAgICAgICArIHNlbGYuc3R5bGUudHJlZUFycm93TWFyZ2luTGVmdCArIHNlbGYuc3R5bGUudHJlZUFycm93TWFyZ2luUmlnaHQgOiAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuZ2V0U2NoZW1hKCkuZm9yRWFjaChmdW5jdGlvbiAoY29sKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbC5uYW1lICE9PSBuYW1lKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgICAgIHNlbGYuY3R4LmZvbnQgPSBzZWxmLnN0eWxlLmhlYWRlckNlbGxGb250O1xuICAgICAgICAgICAgICAgIHZhciB0ID0gc2VsZi5jdHgubWVhc3VyZVRleHQoY29sLnRpdGxlIHx8IGNvbC5uYW1lKS53aWR0aFxuICAgICAgICAgICAgICAgICAgICArIHNlbGYuc3R5bGUuaGVhZGVyQ2VsbFBhZGRpbmdSaWdodFxuICAgICAgICAgICAgICAgICAgICArIHNlbGYuc3R5bGUuaGVhZGVyQ2VsbFBhZGRpbmdMZWZ0O1xuICAgICAgICAgICAgICAgIG0gPSB0ID4gbSA/IHQgOiBtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxmLmRhdGEuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jdHguZm9udCA9IHNlbGYuc3R5bGUuY2VsbEZvbnQ7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSBzZWxmLmN0eC5tZWFzdXJlVGV4dChyb3dbbmFtZV0pLndpZHRoXG4gICAgICAgICAgICAgICAgICAgICsgc2VsZi5zdHlsZS5jZWxsUGFkZGluZ1JpZ2h0XG4gICAgICAgICAgICAgICAgICAgICsgc2VsZi5zdHlsZS5jZWxsUGFkZGluZ0xlZnQgKyBzZWxmLnN0eWxlLmNlbGxBdXRvUmVzaXplUGFkZGluZztcbiAgICAgICAgICAgICAgICBtID0gdCA+IG0gPyB0IDogbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSB0b3RhbCB3aWR0aCBvZiBhbGwgaGVhZGVyIGNvbHVtbnMuXG4gICAgICAgICAqIEBtZW1iZXJvZiBjYW52YXNEYXRhR3JpZCNcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5nZXRIZWFkZXJXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmdldFZpc2libGVTY2hlbWEoKS5yZWR1Y2UoZnVuY3Rpb24gKHRvdGFsLCBoZWFkZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG90YWwgKyBoZWFkZXIud2lkdGg7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5mb3JtYXR0ZXJzLnN0cmluZyA9IGZ1bmN0aW9uIGNlbGxGb3JtYXR0ZXJTdHJpbmcoY3R4LCBjZWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gY2VsbC52YWx1ZSAhPT0gdW5kZWZpbmVkID8gY2VsbC52YWx1ZSA6ICcnO1xuICAgICAgICB9O1xuICAgICAgICBzZWxmLmZvcm1hdHRlcnMucm93SGVhZGVyQ2VsbCA9IHNlbGYuZm9ybWF0dGVycy5zdHJpbmc7XG4gICAgICAgIHNlbGYuZm9ybWF0dGVycy5oZWFkZXJDZWxsID0gc2VsZi5mb3JtYXR0ZXJzLnN0cmluZztcbiAgICAgICAgc2VsZi5mb3JtYXR0ZXJzLm51bWJlciA9IHNlbGYuZm9ybWF0dGVycy5zdHJpbmc7XG4gICAgICAgIHNlbGYuZm9ybWF0dGVycy5pbnQgPSBzZWxmLmZvcm1hdHRlcnMuc3RyaW5nO1xuICAgICAgICBzZWxmLnNvcnRlcnMuc3RyaW5nID0gZnVuY3Rpb24gKGNvbHVtbk5hbWUsIGRpcmVjdGlvbikge1xuICAgICAgICAgICAgdmFyIGFzYyA9IGRpcmVjdGlvbiA9PT0gJ2FzYyc7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICBpZiAoYVtjb2x1bW5OYW1lXSA9PT0gdW5kZWZpbmVkIHx8IGFbY29sdW1uTmFtZV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChiW2NvbHVtbk5hbWVdID09PSB1bmRlZmluZWQgfHwgYltjb2x1bW5OYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFzYykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFbY29sdW1uTmFtZV0ubG9jYWxlQ29tcGFyZSkgeyByZXR1cm4gMTsgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYVtjb2x1bW5OYW1lXS5sb2NhbGVDb21wYXJlKGJbY29sdW1uTmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWJbY29sdW1uTmFtZV0ubG9jYWxlQ29tcGFyZSkgeyByZXR1cm4gMTsgfVxuICAgICAgICAgICAgICAgIHJldHVybiBiW2NvbHVtbk5hbWVdLmxvY2FsZUNvbXBhcmUoYVtjb2x1bW5OYW1lXSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBzZWxmLnNvcnRlcnMubnVtYmVyID0gZnVuY3Rpb24gKGNvbHVtbk5hbWUsIGRpcmVjdGlvbikge1xuICAgICAgICAgICAgdmFyIGFzYyA9IGRpcmVjdGlvbiA9PT0gJ2FzYyc7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXNjKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhW2NvbHVtbk5hbWVdIC0gYltjb2x1bW5OYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJbY29sdW1uTmFtZV0gLSBhW2NvbHVtbk5hbWVdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5zb3J0ZXJzLmRhdGUgPSBmdW5jdGlvbiAoY29sdW1uTmFtZSwgZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgYXNjID0gZGlyZWN0aW9uID09PSAnYXNjJztcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIGlmIChhc2MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGFbY29sdW1uTmFtZV0pLmdldFRpbWUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLSBuZXcgRGF0ZShiW2NvbHVtbk5hbWVdKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShiW2NvbHVtbk5hbWVdKS5nZXRUaW1lKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC0gbmV3IERhdGUoYVtjb2x1bW5OYW1lXSkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9wdWJsaWNNZXRob2RzLmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7\n");

/***/ })
/******/ ]);